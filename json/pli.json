{"types":{"Vulnerability":0,"Code Smell":26,"Bug":2,"Other":0},"rules":[{"summary":"\"STOP\" statements should not be called","type":"Code Smell","defaultSeverity":"Blocker","description":"<p><code>STOP</code> terminates the current application. Since it does not carry any information as to what went wrong it is not a good way to handle\nerrors and will most likely confuse the user, therefore it is highly recommended never to use the <code>STOP</code> statement.</p>","debt":"30min"},{"summary":"Columns to be read with a \"SELECT\" statement should be clearly defined","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>SELECT *</code> should be avoided because it releases control of the returned columns and could therefore lead to errors and potentially to\nperformance issues.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSELECT *\n       FROM persons\n       INTO newyorkers\n       WHERE city = 'NEW YORK'.\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSELECT firstname, lastname\n       FROM persons\n       INTO newyorkers\n       WHERE city = 'NEW YORK'.\n</pre>","debt":"30min"},{"summary":"Track parsing failures","type":"Code Smell","defaultSeverity":"Major","description":"<p>When the PL/I parser fails, it is possible to record the failure as a violation on the file.</p>\n<p>This way, not only it is possible to track the number of files that do not parse but also to easily find out why they do not parse.</p>","debt":"30min"},{"summary":"Parentheses should be used in factored variable declarations","type":"Bug","defaultSeverity":"Major","description":"<p>When multiple variables are <code>DECLARE</code>d in a single statement, parentheses must be used around the variable list to ensure the variable\nattributes in the statement are applied to all the variables in the declaration. Without parentheses, the attributes are applied only to the last\nvariable in the list.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE X,Y FIXED BIN(15);\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE (X,Y) FIXED BIN(15);\n</pre>","debt":"5min"},{"summary":"Procedure names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Major","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo#: proc options(main); /* Non-Compliant */\nend;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfoo: proc options(main);  /* Compliant */\nend;\n</pre>","debt":"10min"},{"summary":"Statements should be on separate lines","type":"Code Smell","defaultSeverity":"Major","description":"<p>For better readability, do not put more than one statement on a single line.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo: proc options(main);\n  declare i fixed decimal init(42); put list (i); /* Noncompliant - there are two statements */\nend;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfoo: proc options(main);\n  /* Compliant */\n  declare i fixed decimal init(42);\n  put list (i);\nend;\n</pre>","debt":"1min"},{"summary":"\"SELECT\" statements should end with \"OTHERWISE\" statements","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>If every <code>WHEN</code> test of a <code>SELECT</code> statement fails, an <code>ERROR</code> condition is raised if the <code>OTHERWISE</code>\nstatement is omitted. This can lead to the unexpected termination of the program.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo: proc options(main);\n  declare i fixed decimal init (42);\n\n  select (i); /* Non-Compliant - SELECT without OTHERWISE statement */\n    when (0) put list ('i = 0');\n    when (1) put list ('i = 1');\n  end;\n\n  put list ('Continuation'); /* This statement will not be executed */\nend;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfoo: proc options(main);\n  declare i fixed decimal init (42);\n\n  select (i); /* Compliant */\n    when (0) put list ('i = 0');\n    when (1) put list ('i = 1');\n    otherwise; /* No operation */\n  end;\n\n  put list ('Continuation'); /* This statement will be executed */\nend;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.0 - The MISRA C <em>switch</em> syntax shall be used. </li>\n  <li> MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause </li>\n  <li> MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. </li>\n  <li> MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause </li>\n  <li> MISRA C:2012, 16.1 - All switch statements shall be well-formed </li>\n  <li> MISRA C:2012, 16.4 - Every <em>switch</em> statement shall have a <em>default</em> label </li>\n  <li> MISRA C:2012, 16.5 - A <em>default</em> label shall appear as either the first or the last <em>switch label</em> of a <em>switch</em> statement\n  </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/478.html\">MITRE, CWE-478</a> - Missing Default Case in Switch Statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/YgE\">CERT, MSC01-C.</a> - Strive for logical completeness </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/JoIyAQ\">CERT, MSC01-CPP.</a> - Strive for logical completeness </li>\n</ul>","debt":"5min"},{"summary":"\"INONLY\" or \"NONASSIGNABLE\" parameters should not be written to","type":"Code Smell","defaultSeverity":"Major","description":"<p>Parameters that are declared as \"INONLY\" or \"NONASSIGNABLE\" are flagged as non-assignable by the compiler.</p>\n<p>This rule raises an issue when a non-assignable parameter is written to.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nsum: PROC(a, b);\n   dcl a fixed dec(15,2) NONASSIGNABLE;\n   dcl b fixed dec(15,2) NONASSIGNABLE;\n   a = a + b; /* Noncompliant */\n   return (a);\nend;\n</pre>","debt":"5min"},{"summary":"Lines should not be too long","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.</p>","debt":"1min"},{"summary":"\"if\" statements should not be nested too deeply","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Nested <code>if</code> statements are key ingredients for making what's known as \"Spaghetti code\".</p>\n<p>Such code is hard to read, refactor and therefore maintain.</p>","debt":"10min"},{"summary":"Track comments matching a regular expression","type":"Code Smell","defaultSeverity":"Major","description":"<p>This rule template can be used to create rules which will be triggered when a comment matches a given regular expression.</p>\n<p>For example, one can create a rule with the regular expression <code>.*REVIEW.*</code> to match all comment containing \"REVIEW\".</p>\n<p>Note that, in order to match REVIEW regardless of the case, the <code>(?i)</code> modifier should be prepended to the expression, as in\n<code>(?i).*REVIEW.*</code>.</p>"},{"summary":"The \"DCL\" abbreviation should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>For better readability, it is preferable to use <code>DECLARE</code> instead of the unpronounceable <code>DCL</code> abbreviation.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo: proc options(main);\n  dcl i fixed decimal init (0); /* Noncompliant */\nend;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfoo: proc options(main);\n  declare i fixed decimal init (0); /* Compliant */\nend;\n</pre>","debt":"5min"},{"summary":"Keywords should not be used as variable names","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>PL/I, unlike many other programming languages, does not reserve any word's usage.</p>\n<p>This implies that it is syntaxically valid to use the keyword <code>IF</code> as variable names for instance.</p>\n<p>But doing so results in confusing code which is hard to read, especially in editors without proper PL/I syntax highlighting support.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo: proc options(main);\n  declare if fixed decimal init (42); /* Non-Compliant */\n\n  if if = 42 then do; /* Cconfusing */\n    put list ('if = 42');\n  end;\n\n  go to goto; /* Confusing */\n\n  goto: /* Non-Compliant */\n  ;\nend;\n</pre>","debt":"10min"},{"summary":"File names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate effectively. For that reason, file names should conform to a defined standard. This rule\nraises an issue when the names of analyzed files don't match the provided regular expression.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/P4IyAQ\">CERT, MSC09-CPP.</a> - Character encoding: Use subset of ASCII for safety </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/lQAl\">CERT, MSC09-C.</a> - Character encoding: Use subset of ASCII for safety </li>\n</ul>","debt":"10min"},{"summary":"\"IF / ELSE\" statements should use \"DO ... END\" structures","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Not using a <code>DO ... END</code> compound statement can be error-prone.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo: proc options(main);\n  declare i fixed decimal init (0);\n\n  if i = 42 then\n    put list ('The answer is... '); /* Noncompliant; should be enclosed in DO ... END*/\n    put list ('42!'); /* Always unconditionally be executed! Indentation level is misleading. */\nend;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfoo: proc options(main);\n  declare i fixed decimal init (0);\n\n  if i = 42 then do;\n    put list ('The answer is... '); /* Compliant */\n    put list ('42!');\n  end;\nend;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.8 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement </li>\n  <li> MISRA C:2004, 14.9 - An if (expression) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement </li>\n  <li> MISRA C++:2008, 6-3-1 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement </li>\n  <li> MISRA C++:2008, 6-4-1 - An if (condition) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement </li>\n  <li> MISRA C:2012, 15.6 - The body of an iteration-statement or a selection-statement shall be a compound-statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/1QGMAg\">CERT, EXP19-C.</a> - Use braces for the body of an if, for, or while statement\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/3wHEAw\">CERT, EXP52-J.</a> - Use braces for the body of an if, for, or while statement\n  </li>\n</ul>","debt":"10min"},{"summary":"Variable names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Major","description":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all\nvariable names match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo: proc options(main);\n  declare bar# fixed decimal; /* Noncompliant */\nend;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfoo: proc options(main);\n  declare bar fixed decimal;  /* Compliant */\nend;\n</pre>","debt":"5min"},{"summary":"\"GO TO\" statements should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>goto</code> is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such\nas <code>if</code>, <code>for</code>, <code>while</code>, <code>continue</code> or <code>break</code> should be used instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo: proc options(main);\n  declare i fixed decimal init (0);\n\nloopLabel:\n  put list (i);\n  i = i + 1;\n  if i &lt; 10 then go to loopLabel;  /* Noncompliant - usage of the GO TO statement */\nend;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfoo: proc options(main);\n  declare i fixed decimal init (0);\n\n\n  do i = 0 to 9;   /* Compliant */\n    put list (i);\n  end;\nend;\n</pre>\n<h2>Exceptions</h2>\n<p>Exclusions format parameter can be used to allow specific <code>GO TO</code> targets which match the given regular expression.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.4 - The goto statement shall not be used. </li>\n  <li> MISRA C:2012, 15.1 - The goto statement should not be used </li>\n</ul>","debt":"10min"},{"summary":"FIXED DECIMAL declarations should be defined with odd length","type":"Code Smell","defaultSeverity":"Major","description":"<p>The storage of a <code>FIXED DECIMAL</code> is most efficient when you use an odd number of digits, so that the leftmost byte is fully used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n declare total fixed dec(10);\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n declare total fixed dec(9);\n</pre>","debt":"30min"},{"summary":"String constants should not span multiple lines","type":"Code Smell","defaultSeverity":"Minor","description":"<p>String literals written on multiple lines should not be used, especially since the new line characters are <strong>not</strong> part of the string\nanyway. The concatenation operator <code>||</code> should be used instead. Moreover, if trailing comments are present, they can be automatically\nremoved by text editors and lead to unexpected results.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo: proc options(main);\n  put list ('Hello,      /* Noncompliant; trailing space is not readable and may be stripped */\nworld');\nend;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfoo: proc options(main);\n  put list ('Hello, ' ||\n'world');\nend;\n</pre>","debt":"10min"},{"summary":"Track breaches of an XPath rule","type":"Code Smell","defaultSeverity":"Major","description":"<p>This rule allows the definition of custom rules using XPath expressions.</p>\n<p>Issues are created depending on the return value of the XPath expression. If the XPath expression returns:</p>\n<ul>\n  <li> a single or list of AST nodes, then a line issue with the given message is created for each node </li>\n  <li> a boolean, then a file issue with the given message is created only if the boolean is true </li>\n  <li> anything else, no issue is created </li>\n</ul>\n<p>Here is an example of an XPath expression to log an issue on each <code>GO TO</code> statement:</p>\n<pre>\n//gotoStatement\n</pre>"},{"summary":"Procedures should not have too many parameters","type":"Code Smell","defaultSeverity":"Major","description":"<p>Procedures with excessive parameters are difficult to use, as one needs to figure out what each parameter is.</p>\n<p>In many cases, the procedure can either be split into several smaller ones, or a better data structure can be found.</p>\n<p>This rule verifies that each procedure has at most the given number of parameters.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo: proc options(main);\n  declare myArray (9) fixed decimal init (1, 2, 3, 4, 5, 6, 7, 8, 9);\n\n  put list (mySum(myArray(1), myArray(2), myArray(3), myArray(4), myArray(5), myArray(6), myArray(7), myArray(8), myArray(9)));\nend;\n\nmySum: proc (a1, a2, a3, a4, a5, a6, a7, a8, a9) returns (fixed decimal); /* Non-Compliant - too many parameters */\n  declare (a1, a2, a3, a4, a5, a6, a7, a8, a9) fixed decimal;\n\n  return (a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9);\nend;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfoo: proc options(main);\n  declare myArray (9) fixed decimal init (1, 2, 3, 4, 5, 6, 7, 8, 9);\n\n  put list (sum(myArray));  /* Compliant - uses the built-in sum() function which works on an array */\nend;\n</pre>","debt":"20min"},{"summary":"\"END;\" statements should have the same indentation level as their matching \"PROCEDURE\", \"SELECT\", and \"DO\" statements","type":"Code Smell","defaultSeverity":"Major","description":"<p>For better readability, <code>END</code> statements must have the same indentation level as their matching opening <code>PROCEDURE</code>,\n<code>SELECT</code>, and <code>DO</code> statements.</p>\n<p>This rule does not verify the alignment of the compound statements <code>DO ... END;</code> (type 1) and <code>BEGIN ... END;</code>. They are\nmostly used together with the <code>IF</code> and <code>ON</code> statements and are subject to different indentation rules.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo: proc options(main);\n  declare i fixed decimal init (0);\n\n  do i = 0 to 9;\n    if i = 0 then /* The do was forgotten here */\n      put list ('Initialization...');\n      put list ('i = 0');\n      end; /* Non-Compliant - should be aligned with the DO statement */\n  end; /* Non-Compliant - should be aligned with the PROCEDURE statement */\n\n/* The procedure's end seems to be missing */\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfoo: proc options(main);\n  declare i fixed decimal init (0);\n\n  do i = 0 to 9;\n    if i = 0 then do;\n      put list ('Initialization...');\n      put list ('i = 0');\n    end; /* This end's alignment is not verified by this rule */\n  end; /* Compliant */\nend; /* Compliant */\n</pre>","debt":"5min"},{"summary":"Failed unit tests should be fixed","type":"Bug","defaultSeverity":"Major","description":"Test failures or errors generally indicate that regressions have been introduced. Those tests should be handled as soon as possible to reduce the cost to fix the corresponding regressions."},{"summary":"Skipped unit tests should be either removed or fixed","type":"Code Smell","defaultSeverity":"Major","description":"Skipped unit tests are considered as dead code. Either they should be activated again (and updated) or they should be removed."},{"summary":"Source files should not have any duplicated blocks","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as there is at least one block of duplicated code on this file","debt":"10min"},{"summary":"Source files should have a sufficient density of comment lines","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the density of comment lines on this file is less than the required threshold. The number of comment lines to be written in order to reach the required threshold is provided by each issue message."},{"summary":"Lines should have sufficient coverage by tests","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the line coverage on this file is less than the required threshold. It gives the number of lines to be covered in order to reach the required threshold."},{"summary":"Branches should have sufficient coverage by tests","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the branch coverage on this file is less than the required threshold.It gives the number of branches to be covered in order to reach the required threshold."}]}