{"types":{"Vulnerability":2,"Code Smell":175,"Bug":58,"Other":0},"rules":[{"summary":"Boolean expressions should not be gratuitous","type":"Code Smell","defaultSeverity":"Major","description":"<p>If a boolean expression doesn't change the evaluation of the condition, then it is entirely unnecessary, and can be removed. If it is gratuitous\nbecause it does not match the programmer's intent, then it's a bug and the expression should be fixed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\na = true;\nif (a) { // Noncompliant\n  doSomething();\n}\n\nif (b &amp;&amp; a) { // Noncompliant; \"a\" is always \"true\"\n  doSomething();\n}\n\nif (c || !a) { // Noncompliant; \"!a\" is always \"false\"\n  doSomething();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\na = true;\nif (foo(a)) {\n  doSomething();\n}\n\nif (b) {\n  doSomething();\n}\n\nif (c) {\n  doSomething();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. </li>\n  <li> MISRA C:2012, 14.3 - Controlling expressions shall not be invariant </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/489\">MITRE, CWE-489</a> - Leftover Debug Code </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/571\">MITRE, CWE-571</a> - Expression is Always True </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"10min"},{"summary":"Track uses of \"TODO\" tags","type":"Code Smell","defaultSeverity":"Info","description":"<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid foo() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"},{"summary":"Track uses of \"FIXME\" tags","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>FIXME</code> tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint divide(int numerator, int denominator) {\n  return numerator / denominator;              // FIXME denominator value might be  0\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"},{"summary":"\"abort\", \"exit\", \"getenv\" and \"system\" from <stdlib.h> should not be used","type":"Bug","defaultSeverity":"Critical","description":"<p><code>&lt;stdlib.h&gt;</code>'s <code>abort</code>, <code>exit</code>, <code>getenv</code>, and <code>system</code> have undefined, and\nimplementation-defined behaviors, and should therefore be used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;stdlib.h&gt;\n\nvoid f( ) {\n  exit(0); // Noncompliant\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.11 - The library functions abort, exit, getenv and system from library &lt;stdlib.h&gt; shall not be used. </li>\n  <li> MISRA C++:2008, 18-0-3 - The library functions abort, exit, getenv and system from library &lt;cstdlib&gt; shall not be used. </li>\n  <li> MISRA C:2012, 21.8 - The library functions abort, exit, getenv and system of &lt;stdlib.h&gt; shall not be used </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/1IAg\">CERT, ENV33-C.</a> - Do not call system() </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/5oEyAQ\">CERT, ENV02-CPP.</a> - Do not call system() if you do not need a command\n  processor </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/2gDOAQ\">CERT, ERR50-CPP.</a> - Do not abruptly terminate the program </li>\n</ul>","debt":"10min"},{"summary":"Deprecated code should be removed","type":"Code Smell","defaultSeverity":"Info","description":"<p>This rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// C++14 attribute\n[[deprecated]] // Noncompliant\nvoid fun();\n\n// GNU attribute\n__attribute__((deprecated)) // Noncompliant\nvoid fun();\n\n// Microsoft attribute\n__declspec(deprecated) // Noncompliant\nvoid fun();\n</pre>","debt":"10min"},{"summary":"Enumeration names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared naming conventions allow teams to collaborate efficiently. This rule checks that all <code>enum</code> names match a provided regular\nexpression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With default provided regular expression <code>[A-Z][a-zA-Z0-9]++</code>:</p>\n<pre>\nenum someEnumeration { // Noncompliant\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nenum SomeEnumeration {\n};\n</pre>","debt":"5min"},{"summary":"\"<signal.h>\" should not be used","type":"Bug","defaultSeverity":"Critical","description":"<p>Signal handling contains implementation-defined and undefined behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;signal.h&gt; /* Noncompliant */\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.8 - The signal handling facilities of &lt;signal.h&gt; shall not be used. </li>\n  <li> MISRA C:2012, 21.5 - The standard header file &lt;signal.h&gt; shall not be used </li>\n</ul>","debt":"4h"},{"summary":"Enumeration values should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all enumeration values match a provided regular\nexpression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With default provided regular expression:</p>\n<pre>\nenum SomeEnumeration {\n    some  // Non-Compliant\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nenum SomeEnumeration {\n    SOME\n};\n</pre>","debt":"5min"},{"summary":"Lines should not end with trailing whitespaces","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Trailing whitespaces are simply useless and should not stay in code. They may generate noise when comparing different versions of the same\nfile.</p>\n<p>If you encounter issues from this rule, this probably means that you are not using an automated code formatter - which you should if you have the\nopportunity to do so. </p>","debt":"1min"},{"summary":"Conditionally executed blocks should be reachable","type":"Bug","defaultSeverity":"Major","description":"<p>Conditional expressions which are always <code>true</code> or <code>false</code> can lead to dead code. Such code is always buggy and should never\nbe used in production.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\na = false;\nif (a) { // Noncompliant\n  doSomething(); // never executed\n}\n\nif (!a || b) { // Noncompliant; \"!a\" is always \"true\", \"b\" is never evaluated\n  doSomething();\n} else {\n  doSomethingElse(); // never executed\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule will not raise an issue when the condition is an integer constant or a <code>const</code> variable of integer type.</p>\n<p>In these cases it is obvious the code is as intended.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. </li>\n  <li> MISRA C:2012, 14.3 - Controlling expressions shall not be invariant </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/570.html\">MITRE, CWE-570</a> - Expression is Always False </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/571\">MITRE, CWE-571</a> - Expression is Always True </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"15min"},{"summary":"\"sizeof\" should not be used on expressions that contain side effects","type":"Bug","defaultSeverity":"Major","description":"<p>A possible programming error in C++ is to apply the <code>sizeof</code> operator to an expression and expect the expression to be evaluated.\nHowever, the expression is not evaluated because <code>sizeof</code> only acts on the <em>type</em> of the expression. To avoid this error,\n<code>sizeof</code> should not be used on expressions that would contain side effects if they were used elsewhere, since the side effects will not\noccur.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nj = sizeof( i = 1234 ); // Noncompliant - j is set to the sizeof the type of i which is an int. i is not set to 1234.\n\nj = sizeof ( b[i++] ); // Noncompliant - i won't be incremented.\n\nj = sizeof( isPtr(e) ); // Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ni = 1234;\nj = sizeof( i );\n\ni++;\nj = sizeof ( b[i] );\n\nj = sizeof( isPtr(e) );\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.3 - The sizeof operator shall not be used on expressions that contain side effects. </li>\n  <li> MISRA C++:2008, 5-3-4 - Evaluation of the operand to the sizeof operator shall not contain side effects. </li>\n  <li> MISRA C:2012, 13.6 - The operand of the sizeof operator shall not contain any expression which has potential side effects </li>\n</ul>","debt":"30min"},{"summary":"\"typedef\" should be used for function pointers","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Function pointer syntax can be hard on the eyes, particularly when one function is used as a parameter to another. Providing and using a\n<code>typedef</code> instead can make code easier to read, and should be preferred.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nextern void (*signal(int, void(*)(int)))(int);\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntypedef void (*SignalHandler)(int signum);\nextern SignalHandler signal(int signum, SignalHandler handler);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/fwAhAQ\">CERT, DCL05-CPP.</a> - Use typedefs to improve code readability </li>\n</ul>","debt":"15min"},{"summary":"Trigraphs should not be used","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Trigraphs are denoted by a sequence of 2 question marks followed by a specified third character (e.g. ??- represents a '~' (tilde) character and\n??) represents a ']'). They can cause accidental confusion with other uses of two question marks.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstatic const char str[] = \"(Date should be in the form ??-??-??)\"; // Noncompliant. Evaluates to \"(Date should be in the form ~~]\"\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstatic const char str[] = \"(Date should be in the form ?\" \"?-?\" \"?-?\" ?)\";  // adjacent string literals concatenated at compile time\nstatic const char str2[] = \"(Date should be in the form ?-?-?)\"; // problem avoided by eliminating 2nd '?' in each sequence\nstatic const char str3[] = \"(Date should be in the form ? ?-? ?-? ?)\"; // problem avoided by spacing '?'s out\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 4.2 - Trigraphs shall not be used </li>\n  <li> MISRA C++:2008, 2-3-1 - Trigraphs shall not be used </li>\n  <li> MISRA C:2012, 4.2 - Trigraphs shall not be used </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/nAE_\">CERT, PRE07-C.</a> - Avoid using repeated question marks </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KAAhAQ\">CERT, PRE07-CPP.</a> - Avoid using repeated question marks </li>\n</ul>","debt":"15min"},{"summary":"\"setjmp\" and \"longjmp\" should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p><code>setjmp.h</code> functions allow the normal function mechanisms to be bypassed and should be used only with extreme caution, if at all. </p>\n<p>Calling <code>setjmp</code> saves the program environment into the buffer passed into the call. Later calling <code>longjmp</code> returns\nexecution to the point at which <code>setjmp</code> was called and restores the context that was saved into the buffer. But the values of non-volatile\nlocal variables after <code>longjmp</code> are indeterminate. Additionally invoking <code>longjmp</code> from a nested signal handler is undefined, as\nis <code>longjmp</code>ing back to a method that has already completed execution.</p>\n<p>This rule flags all instances of <code>setjmp</code>, <code>_setjmp</code>, <code>longjmp</code>, <code>_longjmp</code>, <code>sigsetjmp</code>,\n<code>siglongjmp</code> and <code>&lt;setjmp.h&gt;</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;setjmp.h&gt;  // Noncompliant\n\njmp_buf buf;\n\nint main(int argc, char* argv[]) {\n  int i = setjmp(buf);  // Noncompliant\n  if (i == 0) { // value of i was assigned after env was saved &amp; will be indeterminate after longjmp();\n    // normal execution\n  } else {\n    // recover\n  }\n}\n\n//...\n\nvoid fun() {\n  //...\n  longjmp(buf, 1);  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint main(int argc, char* argv[]) {\n  // normal execution\n}\n\n//...\n\nvoid fun() {\n  //...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.7 - The setjmp macro and the longjmp function shall not be used. </li>\n  <li> MISRA C++:2008, 17-0-5 - The setjmp macro and the longjmp function shall not be used. </li>\n  <li> MISRA C:2012, 21.4 - The standard header file &lt;setjmp.h&gt; shall not be used </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/rgCMAg\">CERT, MSC22-C.</a> - Use the setjmp(), longjmp() facility securely </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/Kgc\">CERT, ERR52-CPP.</a> - Do not use setjmp() or longjmp() </li>\n</ul>","debt":"1d"},{"summary":"Limited dependence should be placed on operator precedence rules in expressions","type":"Code Smell","defaultSeverity":"Major","description":"<p>The rules of operator precedence are complicated and can lead to errors. For this reason, parentheses should be used for clarification in complex\nstatements. However, this does not mean that parentheses should be gratuitously added around every operation.</p>\n<p>Parentheses are not needed:</p>\n<ul>\n  <li> with a unary operator </li>\n  <li> when all the operators in an expression are the same </li>\n  <li> when only a single operator is involved </li>\n  <li> around the right-hand side of an assignment operator unless the right-hand side itself contains an assignment </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nx = a + b;\nx = a * -1;\nx = a + b + c;\nx = f ( a + b, c );\n\nx = a == b ? a : a - b; // Noncompliant\nx = a + b - c + d; // Noncompliant\nx = a * 3 + c + d; // Noncompliant\n\nif (a = f(b,c) == true) { ... } // Noncompliant; == evaluated first\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nx = a + b;\nx = a * -1;\nx = a + b + c;\nx = f ( a + b, c );\n\nx = ( a == b ) ? a : ( a - b );\nx = ( a + b ) - ( c + d );\nx = ( a * 3 ) + c + d;\n\nif ( (a = f(b,c)) == true) { ... }\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.1 - Limited dependence should be placed on C's operator precedence rules in expressions </li>\n  <li> MISRA C:2004, 12.2 - The value of an expression shall be the same under any order of evaluation that the standard permits. </li>\n  <li> MISRA C:2004, 12.5 - The operands of a logical &amp;&amp; or || shall be primary-expressions. </li>\n  <li> MISRA C++:2008, 5-0-1 - The value of an expression shall be the same under any order of evaluation that the standard permits. </li>\n  <li> MISRA C++:2008, 5-0-2 - Limited dependence should be placed on C++ operator precedence rules in expressions </li>\n  <li> MISRA C++:2008, 5-2-1 - Each operand of a logical &amp;&amp; or || shall be a postfix-expression. </li>\n  <li> MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/_wI\">CERT, EXP00-C.</a> - Use parentheses for precedence of operation </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/VoAyAQ\">CERT, EXP00-CPP.</a> - Use parentheses for precedence of operation </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/9wHEAw\">CERT, EXP53-J.</a> - Use parentheses for precedence of operation </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/783.html\">MITRE, CWE-783</a> - Operator Precedence Logic Error </li>\n</ul>","debt":"2min"},{"summary":"\"errno\" should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p><code>errno</code> is a facility of C++ which should in theory be useful, but which in practice is poorly defined by ISO/IEC 14882:2003. A non-zero\nvalue may or may not indicate that a problem has occurred; therefore <code>errno</code> shall not be used.</p>\n<p>Even for those functions for which the behaviour of <code>errno</code> is well defined, it is preferable to check the values of inputs before\ncalling the function rather than relying on using <code>errno</code> to trap errors.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;cstdlib&gt;\n#include &lt;cerrno&gt;\n\nvoid f1 ( const char_t * str )\n{\n  errno = 0; // Noncompliant\n  int32_t i = atoi ( str );\n  if ( 0 != errno ) // Noncompliant\n  {\n    // handle error case???\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.5 - The error indicator errno shall not be used. </li>\n  <li> MISRA C++:2008, 19-3-1 - The error indicator errno shall not be used. </li>\n</ul>\n<h3>See Also</h3>\n<ul>\n  <li> ISO/IEC 14882:2003 </li>\n</ul>","debt":"10min"},{"summary":"Dynamic heap memory allocation should not be used","type":"Bug","defaultSeverity":"Critical","description":"<p>The use of dynamic memory can lead to out-of-storage run-time failures, which are undesirable.</p>\n<p>The built-in <code>new</code> and <code>delete</code> operators, other than the placement versions, use dynamic heap memory. The functions\n<code>calloc</code>, <code>malloc</code>, <code>realloc</code> and <code>free</code> also use dynamic heap memory.</p>\n<p>There is a range of unspecified, undefined and implementation-defined behaviour associated with dynamic memory allocation, as well as a number of\nother potential pitfalls. Dynamic heap memory allocation may lead to memory leaks, data inconsistency, memory exhaustion, non-deterministic behaviour,\netc.</p>\n<p>Note that some implementations may use dynamic heap memory allocation to implement other functions (for example, functions in the library\n<code>cstring</code>). If this is the case, then these functions shall also be avoided.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint *b;\nvoid initialize()\n{\n  b = (int *b) alloc ( 1024 * sizeof ( int ) ); // Noncompliant, could lead to an out-of-storage run-time failure.\n  if( b == 0 )\n  {\n    // handle case when dynamic allocation failed.\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint b[1024]; // Compliant solution.\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.4 - Dynamic heap memory allocation shall not be used. </li>\n  <li> MISRA C++:2008, 18-4-1 - Dynamic heap memory allocation shall not be used. </li>\n  <li> MISRA C:2012, 21.3 The memory allocation and deallocation functions of &lt;stdlib.h&gt; shall not be used </li>\n</ul>","debt":"1h"},{"summary":"\"goto\" statement should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>goto</code> is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such\nas <code>if</code>, <code>for</code>, <code>while</code>, <code>continue</code> or <code>break</code> should be used instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint i = 0;\nloop:\n  printf(\"i = %d\\n\", i);\n  i++;\n  if (i &lt; 10){\n    goto loop; // Noncompliant\n  }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfor (int i = 0; i &lt; 10; i++) {\n  printf(\"i = %d\\n\", i);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.4 - The goto statement shall not be used. </li>\n  <li> MISRA C:2012, 15.1 - The goto statement should not be used </li>\n</ul>","debt":"10min"},{"summary":"\"offsetof\" macro from <stddef.h> should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p><code>offsetof</code> can lead to undefined behavior when the argument types are incompatible or when bit fields are used. Therefore\n<code>offsetof</code> should be avoided.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;stddef.h&gt;\n\nstruct A\n{\n  int32_t i;\n};\n\nvoid f1 ( )\n{\n  offsetof ( A, i ); // Noncompliant\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.6 - The macro offsetof, in library &lt;stddef.h&gt;, shall not be used. </li>\n  <li> MISRA C++:2008, 18-2-1 - The macro offsetof, in library &lt;stddef.h&gt;, shall not be used. </li>\n</ul>","debt":"20min"},{"summary":"\"atof\", \"atoi\" and \"atol\" from <stdlib.h> should not be used","type":"Bug","defaultSeverity":"Critical","description":"<p><code>&lt;stdlib.h&gt;</code>'s <code>atof</code>, <code>atoi</code>, and <code>atol</code> functions, which convert strings to numbers, have\nundefined behavior when the strings cannot be converted, and should therefore be avoided.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint converter (const char * numstr) {\n  return atoi(numstr); // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint converter (const char * numstr) {\n  return strtol(numstr, NULL, 10);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.10 - The library functions atof, atoi and atol from library &lt;stdlib.h&gt; shall not be used. </li>\n  <li> MISRA C++:2008, 18-0-2 - The library functions atof, atoi and atol from library &lt;cstdlib&gt; shall not be used. </li>\n  <li> MISRA C:2012, 21.7 - The atof, atoi, atol and atoll functions of &lt;stdlib.h&gt; shall not be used </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/6AQ\">CERT, ERR34-C.</a> - Detect errors when converting a string to a number </li>\n</ul>","debt":"10min"},{"summary":"Loops should not have more than one \"break\" or \"goto\" statement","type":"Code Smell","defaultSeverity":"Major","description":"<p>Restricting the number of exits from a loop is done in the interests of good structured programming. One <code>break</code> or <code>goto</code>\nstatement is acceptable in a loop since this allows, for example, for dual-outcome loops or optimal coding.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold of 1:</p>\n<pre>\nfor (int i = 0; i &lt; 10; i++) {\n  if (...) {\n    break;      //  Compliant\n  }\n  else if (...) {\n    break;      //  Non-compliant - second jump from loop\n  }\n  else {\n    ...\n  }\n}\nwhile (...) {\n  if (...) {\n    break;      // Compliant\n  }\n  if (...) {\n    break;      // Non-compliant - second jump from loop\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfor (int i = 0; i &lt; 10; i++) {\n  if (...) {\n    break;      //  Compliant\n  }\n}\nwhile (...) {\n  if (...) {\n    break;    // Compliant\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.6 - For any iteration statement there shall be at most one break statement used for loop termination. </li>\n  <li> MISRA C++:2008, 6-6-4 - For any iteration statement there shall be no more than one break or goto statement used for loop termination. </li>\n  <li> MISRA C:2012, 15.4 - There should be no more than one break or goto statement used to terminate any iteration statement </li>\n</ul>","debt":"20min"},{"summary":"Boolean operators should have boolean operands","type":"Bug","defaultSeverity":"Major","description":"<p>The use of operands with types other than <code>bool</code> with these operators is unlikely to be meaningful (or intended). This rule allows the\ndetection of such uses, which often occur because the logical operators (<code>&amp;&amp;</code>, <code>||</code> and <code>!</code>) can be easily\nconfused with the bitwise operators (<code>&amp;</code>, <code>|</code> and <code>~</code>).</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ( 1 &amp;&amp; ( c &lt; d ) ) // Noncompliant\nif ( ( a &lt; b ) &amp;&amp; ( c + d ) ) // Noncompliant\nif ( u8_a &amp;&amp; ( c + d ) ) // Noncompliant\nif ( !0 ) // Noncompliant, always true\nif ( !ptr ) // Noncompliant\nif ( ( a &lt; b ) &amp;&amp; ( c &lt; d ) ) // Compliant\nif ( !false ) // Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif ( 1 != 0 &amp;&amp; ( c &lt; d ) ) // Compliant, but left operand is always true\nif ( ( a &lt; b ) &amp;&amp; ( c + d ) != 0 ) // Compliant\nif ( u8_a != 0 &amp;&amp; ( c + d ) != 0) // Compliant\nif ( 0 == 0 ) // Compliant, always true\nif ( ptr != NULL ) // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.6 - The operands of logical operators (&amp;&amp;, || and !) should be effectively Boolean. Expressions that are effectively\n  Boolean should not be used as operands to operators other than (&amp;&amp;, || and !). </li>\n  <li> MISRA C++:2008, 5-3-1 - Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KQHEAw\">CERT, EXP54-J.</a> - Understand the differences between bitwise and logical\n  operators </li>\n</ul>","debt":"10min"},{"summary":"Declaration specifiers should not be redundant","type":"Bug","defaultSeverity":"Major","description":"<p>Redundant declaration specifiers should be removed or corrected. Typically, they represent bugs. A specifier modifies the type or pointer to its\nleft. Only when it is at the far left does it apply to the right.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst int const * v1a; // Noncompliant; both const specifiers apply to int\nconst int const * v1b; // Noncompliant\nstatic static int v2;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst int *       v1a;  // pointer to a const int. same meaning as before but less confusing\nint const * const v1b;  // const pointer to a const int\nstatic int         v2;\n</pre>","debt":"5min"},{"summary":"Parameters should be passed in the correct order","type":"Code Smell","defaultSeverity":"Major","description":"<p>When the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when\nthe names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead\nto unexpected results.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint divide(int divisor, int dividend) {\n  return divisor / dividend;\n}\n\nvoid doTheThing() {\n  int divisor = 15;\n  int dividend = 5;\n\n  int result = divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected\n  //...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint divide(int divisor, int dividend) {\n  return divisor / dividend;\n}\n\npublic void doTheThing() {\n  int divisor = 15;\n  int dividend = 5;\n\n  int result = divide(divisor, dividend);\n  //...\n}\n</pre>","debt":"5min"},{"summary":"Atomic types should be used instead of \"volatile\" types","type":"Code Smell","defaultSeverity":"Major","description":"<p>Except for interactions with <code>extern volatile</code> variables provided by libraries, C/C++ programmers should consider <code>volatile</code>\nan esoteric feature that is best avoided. In most cases, it is used in an attempt to provide atomicity, memory ordering, or inter-thread\nsynchronization, but <code>volatile</code> does not provide those guarantees. It is only really needed for the kind of low-level code found in\nkernels, i.e. using memory-mapped I/O registers to manipulate hardware directly. </p>\n<p>According to the C standard:</p>\n<blockquote>\n  <p><code>volatile</code> is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might\n  be changed by means undetectable by an implementation.</p>\n</blockquote>\n<p>Only C11/C++11 \"atomic types\" are free from data races.</p>\n<p>This rule raises an issue when a <code>volatile</code> type is declared.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvolatile int counter; // Noncompliant\nUser * volatile vpUser; // Noncompliant; pointer is volatile\nUser volatile * pvUser;  // Compliant; User instance is volatile, not the pointer\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\natomic_int counter;\nstd::atomic&lt;User*&gt; vpUser;\nUser volatile * pvUser;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/lwBlAQ\">CERT, CON01-CPP.</a> - Do not use volatile as a synchronization primitive </li>\n</ul>","debt":"1h"},{"summary":"A \"while\" loop should be used instead of a \"for\" loop","type":"Code Smell","defaultSeverity":"Minor","description":"<p>When only the condition expression is defined in a <code>for</code> loop, and the initialization and increment expressions are missing, a\n<code>while</code> loop should be used instead to increase readability. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (;condition;) { /*...*/ }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nwhile (condition) { /*...*/ }\n</pre>","debt":"5min"},{"summary":"Functions should not contain too many return statements","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having too many return statements in a function increases the function's essential complexity because the flow of execution is broken each time a\nreturn statement is encountered. This makes it harder to read and understand the logic of the function.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold of 3:</p>\n<pre>\nint fun() {\n  if (condition1) {\n    return 1;\n  } else {\n    if (condition2) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  return 0;\n}\n</pre>","debt":"20min"},{"summary":"\"switch\" statements should cover all cases","type":"Code Smell","defaultSeverity":"Major","description":"<p>For completeness, a <code>switch</code> over the values of an <code>enum</code> must either address each value in the <code>enum</code> or contain\na <code>default</code> case. <code>switch</code> statements that are not over <code>enum</code> must end with a <code>default</code> case.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f, int i) {\n  switch (f) {  // Noncompliant; no case for KIWI\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    case 3: // Noncompliant; case value not in enum\n      // ...\n  }\n\n  switch (i) { // Noncompliant; no default\n    case 0:\n      // ...\n    case 1:\n      // ...\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    default:\n      // ...\n  }\n\n  switch (i) {\n    case 0:\n      // ...\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n</pre>\n<p>or</p>\n<pre>\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    case KIWI:\n      //...\n  }\n\n  switch (i) {\n    case 0:\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n</pre>\n<h2>See also</h2>\n<ul>\n  <li> <a href='/coding_rules#rule_key=c%3ASwitchWithoutDefault'>SwitchWithoutDefault</a> </li>\n</ul>","debt":"10min"},{"summary":"The prefix increment/decrement form should be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Postfix increment and decrement typically involves making a copy of the object being incremented or decremented, whereas its prefix form does not.\nTherefore the prefix form is usually the more efficient form, and should be preferred.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid myFunc(int lim)\n{\n  int i;\n  for (i = 0; i &lt; lim; i++)\n  {\n    // do something\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid myFunc(int lim)\n{\n  int i;\n  for (i = 0; i &lt; lim; ++i)\n  {\n    // do something\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/TABi\">CERT, EXP18-CPP.</a> - Prefer the prefix forms of <code>++</code> and\n  <code>--</code> </li>\n</ul>","debt":"2min"},{"summary":"\"switch\" statements should not be nested","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Nested <code>switch</code> structures are difficult to understand because you can easily confuse the cases of an inner <code>switch</code> as\nbelonging to an outer statement. Therefore nested <code>switch</code> statements should be avoided.</p>\n<p>Specifically, you should structure your code to avoid the need for nested <code>switch</code> statements, but if you cannot, then consider moving\nthe inner <code>switch</code> to another function.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      // ...\n    case 2:\n      // ...\n    case 3:\n      switch (m) {  // Noncompliant\n    case 4:  // Bad indentation makes this particularly hard to read properly\n      // ...\n    case 5:\n      // ...\n    case 6:\n      // ...\n    }\n    case 4:\n      // ...\n    default:\n      // ...\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      // ...\n    case 2:\n      // ...\n    case 3:\n      int m2 = handle_m(m);\n    case 4:\n      // ...\n    default:\n      // ...\n  }\n}\n</pre>","debt":"10min"},{"summary":"Structures should not have too many fields","type":"Code Smell","defaultSeverity":"Major","description":"<p>A structure, such as a <code>struct</code>, <code>union</code> or <code>class</code> that grows too much tends to aggregate too many\nresponsibilities and inevitably becomes harder to understand and therefore to maintain, and having a lot of fields is an indication that a structure\nhas grown too large.</p>\n<p>Above a specific threshold, it is strongly advised to refactor the structure into smaller ones that focus on well defined topics.</p>","debt":"1h"},{"summary":"Narrow and wide string literals should not be concatenated","type":"Bug","defaultSeverity":"Major","description":"<p>Concatenation of wide and narrow string literals leads to undefined behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nwchar_t n_array[] = \"Hello\" L\"World\";     // Noncompliant\nwchar_t w_array[] = L\"Hello\" \"World\";     // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nchar_t n_array[] = \"Hello\" \"World\";     // Compliant\nwchar_t w_array[] = L\"Hello\" L\"World\";\t// Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 2-13-5 - Narrow and wide string literals shall not be concatenated. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/QIEzAg\">CERT STR10-C.</a> - Do not concatenate different type of string literals </li>\n</ul>","debt":"15min"},{"summary":"\"enum\" values should not be used as operands to built-in operators other than [ ], =, ==, !=, unary &, and the relational operators <, <=, >, >=","type":"Code Smell","defaultSeverity":"Major","description":"<p>Enumerations have implementation-defined representation and so should not be used in arithmetic contexts.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nenum { COLOUR_0, COLOUR_1, COLOUR_2, COLOUR_COUNT } colour;\nif ( COLOUR_0 == colour ) { ... }\nif ( ( COLOUR_0 + COLOUR_1 ) == colour ) { ... } // Noncompliant, arithmetic used\nif ( colour &lt; COLOUR_COUNT ) { ... }\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 4-5-2 - Expressions with type enum shall not be used as operands to builtin operators other than the subscript operator [ ],\n  the assignment operator =, the equality operators == and !=, the unary &amp; operator, and the relational operators &lt;, &lt;=, &gt;, &gt;= </li>\n</ul>","debt":"10min"},{"summary":"\"bool\" expressions should not be used as operands to built-in operators other than =, &&, ||, !, ==, !=, unary &, and the conditional operator","type":"Bug","defaultSeverity":"Major","description":"<p>The use of <code>bool</code> operands with other operators is unlikely to be meaningful (or intended). This rule allows the detection of such uses,\nwhich often occur because the logical operators (<code>&amp;&amp;</code>, <code>||</code> and <code>!</code>) can be easily confused with the bitwise\noperators (<code>&amp;</code>, <code>|</code> and <code>~</code>).</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nbool b1 = true;\nbool b2 = false;\nint8_t s8a;\nif ( b1 &amp; b2 ) // Noncompliant\nif ( ~b1 ) // Noncompliant\nif ( b1 &lt; b2 ) // Noncompliant\nif ( b1 ^ b2 ) // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif ( b1 &amp;&amp; b2 )\nif ( !b1 )\nif ( b1 == false )\nif ( b1 == b2 )\nif ( b1 != b2 )\ns8a = b1 ? 3 : 7;\n</pre>\n<h2>Exceptions</h2>\n<p>Operators <code>|=</code> and <code>&amp;=</code> are ignored when used with <code>bool</code> operands as a statement.</p>\n<pre>\nvoid test(bool b1, bool b2, int i1) {\n  b1 |= b2; // ignored\n  b1 &amp;= b2; // ignored\n  b1 &amp;= i1; // Noncompliant; right operand is not a bool\n  if (b1 |= b2) { // Noncompliant, \"|=\" on \"bool\" should not be used as expression\n    // ...\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 4-5-1 - Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator =,\n  the logical operators &amp;&amp;, ||, !, the equality operators == and !=, the unary &amp; operator, and the conditional operator. </li>\n</ul>","debt":"10min"},{"summary":"Bitwise operators should not be applied to signed operands","type":"Bug","defaultSeverity":"Major","description":"<p>Most bitwise operators (<code>~</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;=</code>, <code>&amp;</code>, <code>&amp;=</code>, <code>^</code>,\n<code>^=</code>, <code>|</code>, and <code>|=</code>) have implementation-dependent results when performed on signed operands, and bitwise left shift\n(<code>&lt;&lt;</code> and <code>&lt;&lt;=</code>) has undefined behavior when performed on negative operands. Therefore bitwise operations should not\nbe performed on signed operands.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ( ( uint16_a &amp; int16_b ) == 0x1234U )\nif ( ~int16_a == 0x1234U )\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif ( ( uint16_a | uint16_b ) == 0x1234U )\nif ( ~uint16_a == 0x1234U )\n</pre>\n<h2>Exceptions</h2>\n<p>When used as bit flags, it is acceptable to use preprocessor macros as arguments to the &amp; and | operators even if the value is not explicitly\ndeclared as unsigned.</p>\n<pre>\nfd = open(file_name, UO_WRONLY | UO_CREAT | UO_EXCL | UO_TRUNC, 0600);\n</pre>\n<p>If the right-side operand to a shift operator is known at compile time, it is acceptable for the value to be represented with a signed type\nprovided it is positive.</p>\n<pre>\n#define SHIFT 24\nfoo = 15u &gt;&gt; SHIFT;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.7 - Bitwise operators shall not be applied to operands whose underlying type is signed </li>\n  <li> MISRA C++:2008, 5-0-21 - Bitwise operators shall only be applied to operands of unsigned underlying type </li>\n  <li> MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/BoAD\">CERT, INT13-C.</a> - Use bitwise operators only on unsigned operands </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/vIAyAQ\">CERT, INT13-CPP.</a> - Use bitwise operators only on unsigned operands </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/682.html\">MITRE, CWE-682</a> - Incorrect Calculation </li>\n</ul>","debt":"30min"},{"summary":"Pointer and reference parameters should be \"const\" if the corresponding object is not modified","type":"Code Smell","defaultSeverity":"Minor","description":"<p>This rule leads to greater precision in the definition of the function interface. The <code>const</code> qualification shall be applied to the\nobject pointed to, not to the pointer, since it is the object itself that is being protected.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid myfunc (      int * param1,  // object is modified\n             const int * param2,\n                   int * param3, // Noncompliant\n                   int * param4) // Noncompliant\n{\n  *param1 = *param2 + *param3 + *param4;\n}\n\nint main (int argc,\n          const char * * argv) // Noncompliant\n{\n  return argc;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid myfunc (      int * param1,  // object is modified\n             const int * param2,\n             const int * param3,\n             const int * param4)\n{\n  *param1 = *param2 + *param3 + *param4;\n}\n\nint main (int argc,\n          const char * const * argv)\n{\n  return argc;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify\n  the addressed object. </li>\n  <li> MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the\n  corresponding object is not modified. </li>\n  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/lwAhAQ\">CERT, DCL13-CPP.</a> - Declare function parameters that are pointers to values\n  not changed by the function as const </li>\n</ul>","debt":"2min"},{"summary":"Unary minus should not be applied to an unsigned expression","type":"Bug","defaultSeverity":"Major","description":"<p>Applying the unary minus operator to an unsigned variable or expression will always yield another unsigned expression. More plainly, in some cases\nthe operation itself is meaningless, and in some other cases the result will be unexpected. In all cases it is bad practice. Therefore the unary minus\noperator should not be applied to unsigned variables or expressions.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nuint8_t a = -1U;\nint32_t b = -a; // Noncompliant; b is assigned -255\nuint32_t c = 1U;\nint64_t d = -c; // Noncompliant; d is assigned MAX_UINT\n</pre>\n<h2>Exceptions</h2>\n<p>This rule ignores <code>-1U</code> because it is commonly used as shorthand for <code>MAX_UINT</code>.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.9 - The unary minus operator shall not be applied to an expression whose underlying type is unsigned. </li>\n  <li> MISRA C++:2008, 5-3-2 - The unary minus operator shall not be applied to an expression whose underlying type is unsigned. </li>\n  <li> MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type </li>\n</ul>","debt":"30min"},{"summary":"Comma operator should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>The comma operator takes two expressions, executes them from left to right and returns the result of the second one. Use of this operator is\ngenerally detrimental to the readability and reliability of code, and the same effect can be achieved by other means.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ni = a += 2, a + b;  // What's the value of i ?\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\na +=  2;\ni = a + b;\n</pre>\n<h2>Exceptions</h2>\n<p>Use of comma operator is tolerated in initialization and increment expressions of <code>for</code> loops.</p>\n<pre>\nfor(i = 0, j = 5; i &lt; 6; i++, j++) { ... }\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.10 - The comma operator shall not be used. </li>\n  <li> MISRA C++:2008, 5-18-1 - The comma operator shall not be used. </li>\n  <li> MISRA C:2012, 12.3 - The comma operator should not be used </li>\n</ul>","debt":"5min"},{"summary":"Flexible array members should not be declared","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Flexible array members are most likely to be used in conjunction with dynamic memory allocation.</p>\n<p>The presence of flexible array members modifies the behaviour of the <code>sizeof</code> operator in ways that might not be expected by a\nprogrammer. The assignment of a structure that contains a flexible array member to another structure of the same type may not behave in the expected\nmanner as it copies only those elements up to but not including the start of the flexible array member.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;stdlib.h&gt;\nstruct s\n{\n  uint16_t len;\n  uint32_t data[ ]; // Noncompliant - flexible array member\n} str;\n\nstruct s *copy ( struct s *s1 )\n{\n  struct s *s2 = malloc ( sizeof ( struct s ) + ( s1-&gt;len * sizeof ( uint32_t ) ) );\n  /* Omit malloc ( ) return check for brevity */\n  *s2 = *s1; /* Only copies s1-&gt;len */\n  return s2;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 18.7 - Flexible array members shall not be declared. </li>\n</ul>","debt":"10min"},{"summary":"Cognitive Complexity of functions should not be too high","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>","debt":"5min"},{"summary":"Line-splicing should not be used in \"//\" comments","type":"Bug","defaultSeverity":"Minor","description":"<p>Line-splicing occurs when the \\ character is immediately followed by a new-line character. If the source line containing a <code>//</code> comment\nends with a '\\', the next line becomes part of the comment. This may result in unintentional removal of code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid f ( void )\n{\n  int x = 0; // comment \\\n  if (x)\n  {\n    ++x; /* This is always executed */\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 3.2 - Line-splicing shall not be used in // comments </li>\n</ul>","debt":"2min"},{"summary":"Redundant pairs of parentheses should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>The use of parentheses, even those not required to enforce a desired order of operations, can clarify the intent behind a piece of code. But\nredundant pairs of parentheses could be misleading, and should be removed. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint x = (y / 2 + 1);   //Compliant even if the parenthesis are ignored by the compiler\n\nif (a &amp;&amp; ((x+y &gt; 0))) {  // Noncompliant\n  //...\n}\n\nreturn ((x + 1));  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint x = (y / 2 + 1);\n\nif (a &amp;&amp; (x+y &gt; 0)) {\n  //...\n}\n\nreturn (x + 1);\n</pre>\n<h2>Exceptions</h2>\n<p>When the result of an assignment is used as a condition, clang raises a warning to make sure the purpose was not to use <code>==</code> in place of\n<code>=</code>. Adding some parentheses around the assignment is a common way to silence this clang warning. So, no issue is raised in such case.</p>\n<pre>\nif ((x = 7)) {} // Compliant\n</pre>","debt":"1min"},{"summary":"Multiline blocks should be enclosed in curly braces","type":"Code Smell","defaultSeverity":"Major","description":"<p>Curly braces can be omitted from a one-line block, such as with an <code>if</code> statement or <code>for</code> loop, but doing so can be\nmisleading and induce bugs. </p>\n<p>This rule raises an issue when the whitespacing of the lines after a one line block indicates an intent to include those lines in the block, but\nthe omission of curly braces means the lines will be unconditionally executed once.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition)\n  firstActionInBlock();\n  secondAction();  // Noncompliant; executed unconditionally\nthirdAction();\n\nif (condition) firstActionInBlock(); secondAction();  // Noncompliant; secondAction executed unconditionally\n\nif (condition) firstActionInBlock();  // Noncompliant\n  secondAction();  // Executed unconditionally\n\nif (condition); secondAction();  // Noncompliant; secondAction executed unconditionally\n\nString str = null;\nfor (int i = 0; i &lt; array.length; i++)\n  str = array[i];\n  doTheThing(str);  // Noncompliant; executed only on last array element\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition) {\n  firstActionInBlock();\n  secondAction();\n}\nthirdAction();\n\nString str = null;\nfor (int i = 0; i &lt; array.length; i++) {\n  str = array[i];\n  doTheThing(str);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/483.html\">MITRE, CWE-483</a> - Incorrect Block Delimitation </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/3wHEAw\">CERT, EXP52-J.</a> - Use braces for the body of an if, for, or while statement\n  </li>\n</ul>","debt":"5min"},{"summary":"\"switch\" statements should not have too many \"case\" clauses","type":"Code Smell","defaultSeverity":"Major","description":"<p>When <code>switch</code> statements have large sets of <code>case</code> clauses, it is usually an attempt to map two sets of data. A real map\nstructure would be more readable and maintainable, and should be used instead.</p>","debt":"30min"},{"summary":"Empty statements should be removed","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Empty statements, i.e. <code>;</code>, are usually introduced by mistake, for example because:</p>\n<ul>\n  <li> It was meant to be replaced by an actual statement, but this was forgotten. </li>\n  <li> There was a typo which lead the semicolon to be doubled, i.e. <code>;;</code>. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid doSomething() {\n  ;                                                       // Noncompliant - was used as a kind of TODO marker\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doSomething() {\n}\n</pre>\n<h2>Exceptions</h2>\n<p>In the case of 2 consecutive semi-colons, if one of the two is part of a macro-definition then the issue is not raised.</p>\n<p>Example:</p>\n<pre>\n#define A(x) x;\n\nvoid fun() {\n  A(5);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that\n  the first character following the null statement is a white-space character. </li>\n  <li> MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided\n  that the first character following the null statement is a white-space character. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/7gCTAw\">CERT, MSC51-J.</a> - Do not place a semicolon immediately following an if, for,\n  or while condition </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/i4FtAg\">CERT, EXP15-C.</a> - Do not place a semicolon on the same line as an if, for,\n  or while statement </li>\n</ul>","debt":"2min"},{"summary":"Only standard forms of the \"defined\" directive should be used","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>The <code>defined</code> preprocessing directive is used in the context of <code>#if</code> and <code>#elif</code> expressions to see whether a\ngiven identifier has been defined as a macro. It returns a value of 0 (false) or 1 (true), and has two valid forms, <code>defined IDENTIFIER</code>\nand <code>defined ( IDENTIFIER )</code>. Since it is essentially a macro existence check, it cannot take expressions as arguments.</p>\n<p>Note that since</p>\n<p><code>#if defined AN_IDENTIFIER</code></p>\n<p>is equivalent to</p>\n<p><code>#ifdef AN_IDENTIFIER</code></p>\n<p><code>defined</code> is most useful when there are multiple arguments to check, E.G.</p>\n<p><code>#if defined AAA || defined BBB</code></p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#if defined ( X &gt; Y ) // Noncompliant; expressions not allowed\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#if defined X &amp;&amp; defined Y &amp;&amp; X &gt; Y\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.14 - The defined preprocessor operator shall only be used in one of the two standard forms. </li>\n  <li> MISRA C++:2008, 16-1-1 - The defined preprocessor operator shall only be used in one of the two standard forms. </li>\n</ul>","debt":"5min"},{"summary":"Operands of \"&&\" and \"||\" should be primary (C) or postfix (C++) expressions","type":"Code Smell","defaultSeverity":"Major","description":"<p>The effect of this rule is to require that operands are appropriately parenthesized. Parentheses are important in this situation both for\nreadability of code and for ensuring that the behavior is as the developer intended.</p>\n<p>Where an expression consists of either a sequence of only logical <code>&amp;&amp;</code> or a sequence of logical <code>||</code>, extra\nparentheses are not required.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (x == 0 &amp;&amp; ishigh);                   // Noncompliant\nif (x || y || z);\nif (x || y &amp;&amp; z);                        // Noncompliant\nif (x &amp;&amp; !y);                            // Noncompliant\nif (is_odd(y) &amp;&amp; x);\nif ((x &gt; c1) &amp;&amp; (y &gt; c2) &amp;&amp; (z &gt; c3));\nif ((x &gt; c1) &amp;&amp; (y &gt; c2) || (z &gt; c3));   // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif ((x == 0) &amp;&amp; ishigh);\nif (x || y || z);\nif (x || (y &amp;&amp; z));\nif (x &amp;&amp; (!y));\nif (is_odd(y) &amp;&amp; x);\nif ((x &gt; c1) &amp;&amp; (y &gt; c2) &amp;&amp; (z &gt; c3));\nif ((x &gt; c1) &amp;&amp; ((y &gt; c2) || (z &gt; c3)));\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.5 - The operands of a logical &amp;&amp; or || shall be primary-expressions. </li>\n  <li> MISRA C++:2008, 5-2-1 - Each operand of a logical &amp;&amp; or || shall be a postfix-expression. </li>\n</ul>","debt":"10min"},{"summary":"Function-like macros should not be invoked without all of their arguments","type":"Bug","defaultSeverity":"Blocker","description":"<p>This is a constraint error, but preprocessors have been known to ignore this problem. Each argument in a function-like macro must consist of at\nleast one preprocessing token otherwise the behaviour is undefined.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.8 - A function-like macro shall not be invoked without all of its arguments. </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/628.html\">MITRE, CWE-628</a> - Function Call with Incorrectly Specified Arguments </li>\n</ul>","debt":"10min"},{"summary":"Function-like macros should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>It is tempting to treat function-like macros as functions, but the two things work differently. For instance, the use of functions offers parameter\ntype-checking, while the use of macros does not. Additionally, with macros, there is the potential for a macro to be evaluated multiple times. In\ngeneral, functions offer a safer, more robust mechanism than function-like macros, and that safety usually outweighs the speed advantages offered by\nmacros. Therefore functions should be used instead when possible.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#define CUBE (X) ((X) * (X) * (X)) // Noncompliant\n\nvoid func(void) {\n  int i = 2;\n  int a = CUBE(++i); // Noncompliant. Expands to: int a = ((++i) * (++i) * (++i))\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ninline int cube(int i) {\n  return i * i * i;\n}\n\nvoid func(void) {\n  int i = 2;\n  int a = cube(++i); // yields 27\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.7 - A function should be used in preference to a function-like macro. </li>\n  <li> MISRA C++:2008, 16-0-4 - Function-like macros shall not be defined. </li>\n  <li> MISRA C:2012, Dir. 4.9 - A function should be used in preference to a function-like macro where they are interchangeable </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/VIbu\">CERT, PRE00-C.</a> - Prefer inline or static functions to function-like macros\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/EwAhAQ\">CERT, PRE00-CPP.</a> - Avoid defining macros </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/N4B8Ag\">CERT, PRE10-CPP.</a> - Do not define unsafe macros </li>\n</ul>","debt":"30min"},{"summary":"Macros used in preprocessor directives should be defined before use","type":"Bug","defaultSeverity":"Major","description":"<p>An attempt to use an undefined identifier may elicit a warning from the preprocessor. Or it may not; the preprocessor may simply assume that the\nundefined token has a value of 0. </p>\n<p>Therefore macro identifiers should not be used in preprocessor directives until after they have been defined, and this limited usage should be\nenforced with the use of definition tests.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#if x &gt; 0  /* x assumed to be zero if not defined */\n#include SOMETHING_IMPORTANT\n#endif\n\n#ifdef y  /* Okay; y is not evaluated */\n#if y &gt; 0 /* Okay; y must be defined to reach this point */\n...\n#endif\n#endif\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#define x 10\n...\n#if x &gt; 0\n#include SOMETHING_IMPORTANT\n#endif\n\n#if defined ( y ) &amp;&amp; ( y &gt; 0 )  /* more compact form, same result as before */\n...\n#endif\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.11 - All macro identifiers in preprocessor directives shall be defined before use, except in #ifdef and #ifndef preprocessor\n  directives and the defined() operator. </li>\n  <li> MISRA C:2012, 20.9 - All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define’d before\n  evaluation </li>\n</ul>","debt":"5min"},{"summary":"Octal and hexadecimal escape sequences should be terminated","type":"Code Smell","defaultSeverity":"Critical","description":"<p>There is potential for confusion if an octal or hexadecimal escape sequence is immediately followed by other characters. Instead, such sequences\nshall be terminated by either:</p>\n<ul>\n  <li> The start of another escape sequence. </li>\n  <li> The end of the character constant or the end of a string literal. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst char *s1 = \"\\x41g\";  // Noncompliant\nint c1 = '\\141t'; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst char *s2 = \"\\x41\" \"g\"; // Compliant - terminated by end of literal\nconst char *s3 = \"\\x41\\x67\"; // Compliant - terminated by another escape\nint c2 = '\\141\\t'; // Compliant - terminated by another escape\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 4.1 - Octal and hexadecimal escape sequences shall be terminated </li>\n</ul>","debt":"5min"},{"summary":"Floating point numbers should not be tested for equality","type":"Bug","defaultSeverity":"Major","description":"<p>Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a <code>float</code> or a <code>double</code> through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.</p>\n<p>Even simple floating point assignments are not simple:</p>\n<pre>\nfloat f = 0.1; // 0.100000001490116119384765625\ndouble d = 0.1; // 0.1000000000000000055511151231257827021181583404541015625\n</pre>\n<p>(Results will vary based on compiler and compiler settings.)</p>\n<p>Therefore, the use of the equality (<code>==</code>) and inequality (<code>!=</code>) operators on <code>float</code> or <code>double</code> values\nis almost always an error. </p>\n<p>The accepted solution is to use or write a float comparison library that takes floating-point granularity (FLT_EPSILON) and the magnitude of the\nnumbers being compared into account.</p>\n<p>This rule checks for the use of direct and indirect equality/inequailty tests on floats and doubles.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfloat myNumber = 3.146;\nif ( myNumber == 3.146 ) {  //Noncompliant. Because of floating point imprecision, this will be false\n  // ...\n}\n\nif (myNumber &lt;= 3.146 &amp;&amp; mNumber &gt;= 3.146) { // Noncompliant indirect equality test\n  // ...\n}\n\nif (myNumber &lt; 4 || myNumber &gt; 4) { // Noncompliant indirect inequality test\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality. </li>\n  <li> MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality </li>\n</ul>","debt":"5min"},{"summary":"Deprecated attributes should include explanations","type":"Code Smell","defaultSeverity":"Major","description":"<p>The <code>deprecated</code> attribute can be applied with or without explanations, but marking something <code>deprecated</code> without including\nadvice as to why it's deprecated or on what to use instead will lead maintainers to waste time trying to figure those things out - every single time\nthe warning is encountered.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[[deprecated]] // Noncompliant\nvoid foo1();\n\n__attribute__((deprecated)) // Noncompliant\nvoid foo2();\n\n__declspec(deprecated) // Noncompliant\nvoid foo3();\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[[deprecated(\"use 'bar' instead\")]]\nvoid foo1();\n\n__attribute__((deprecated(\"use 'bar' instead\")))\nvoid foo2();\n\n__declspec(deprecated(\"use 'bar' instead\"))\nvoid foo3();\n</pre>","debt":"5min"},{"summary":"Single-bit named bit fields should not be of a signed type","type":"Bug","defaultSeverity":"Major","description":"<p>The values that can be represented by a signed bit field with a length of one bit may not meet developer expectations. For example according to the\nC99 Standard, Section 6.2.6.2, a single-bit signed bit-field has a single (one) sign bit and no (zero) value bits.</p>\n<p>This rule does not apply to unnamed bit fields, as their values cannot be accessed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nsigned int f:1;  // Noncompliant; there's only room here for the sign\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nunsigned int f:1;\n</pre>\n<p>or</p>\n<pre>\nsigned int:1; // unnamed\n</pre>\n<p>or</p>\n<pre>\nsigned int f:2;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 6.5 - Bit fields of type signed int shall be at least 2 bits long </li>\n  <li> MISRA C:2012, 6.2 - Single-bit named bit fields shall not be of a signed type </li>\n  <li> MISRA C++:2008, 9-6-4 - Named bit-fields with signed integer type shall have a length of more than one bit </li>\n</ul>","debt":"5min"},{"summary":"Only escape sequences defined in the ISO C standard should be used","type":"Bug","defaultSeverity":"Major","description":"<p>The use of an undefined escape sequence leads to undefined behavior. The defined escape sequences (ISO/IEC 14882:2003 [1] §2.13.2) are:\n<code>\\n</code>, <code>\\t</code>, <code>\\v</code>, <code>\\b</code>, <code>\\r</code>, <code>\\f</code>, <code>\\a</code>, <code>\\\\</code>,\n<code>?</code>, <code>\\'</code>, <code>\\\"</code>, <code>\\&lt;Octal Number&gt;</code>, and <code>\\x&lt;Hexadecimal Number&gt;</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst char_t a[ 2 ] = \"\\k\";   // Noncompliant\nconst char_t b[ 2 ] = \"\\b\";   // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 4.1 - Only those escape sequences that are defined in ISO C standard shall be used. </li>\n  <li> MISRA C++:2008, 2-13-1 - Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used. </li>\n</ul>","debt":"5min"},{"summary":"Octal values should not be used","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Integer literals starting with a zero are octal rather than decimal values. While using octal values is fully supported, most developers do not\nhave experience with them. They may not recognize octal values as such, mistaking them instead for decimal values.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint myNumber = 010;   // Noncompliant. myNumber will hold 8, not 10 - was this really expected?\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint myNumber = 8;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 7.1 - Octal constants (other than zero) and octal escape sequences shall not be used. </li>\n  <li> MISRA C++:2008, 2-13-2 - Octal constants (other than zero) and octal escape sequences (other than \"\\0\") shall not be used </li>\n  <li> MISRA C:2012, 7.1 - Octal constants shall not be used </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/_QC7AQ\">CERT, DCL18-C.</a> - Do not begin integer constants with 0 when specifying a\n  decimal value </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/hYClBg\">CERT, DCL50-J.</a> - Use visually distinct identifiers </li>\n</ul>","debt":"5min"},{"summary":"Unused local variables should be removed","type":"Code Smell","defaultSeverity":"Minor","description":"<p>If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will\nnot wonder what the variable is used for.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint numberOfMinutes(int hours) {\n  int seconds = 0; // never used\n  return hours * 60;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint numberOfMinutes(int hours) {\n  return hours * 60;\n}\n</pre>\n<h2>Exceptions</h2>\n<p>No issue is raised on local variables having the attribute \"unused\", on exception handler parameters and on object declarations with non-empty\narguments.</p>","debt":"5min"},{"summary":"The value of a complex expression should only be cast to a type that is narrower and of the same signedness as the underlying type of the expression","type":"Code Smell","defaultSeverity":"Major","description":"<p>If a cast is to be used on any complex expression, the type of cast that may be applied is severely restricted. As explained in MISRA C 2004,\nsection 6.10, conversions on complex expressions are often a source of confusion and it is therefore wise to be cautious. In order to comply with\nthese rules, it may be necessary to use a temporary variable and introduce an extra statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n  ... (float32_t)(f64a + f64b)\n  ... (float64_t)(f32a + f32b) // Noncompliant\n  ... (float64_t)f32a\n  ... (float64_t)(s32a / s32b) // Noncompliant\n  ... (float64_t)(s32a &gt; s32b) // Noncompliant\n  ... (float64_t)s32a / (float32_t)s32b\n  ... (uint32_t)(u16a + u16b) // Noncompliant\n  ... (uint32_t)u16a + u16b\n  ... (uint32_t)u16a + (uint32_t)u16b\n  ... (int16_t)(s32a - 12345)\n  ... (uint8_t)(u16a * u16b)\n  ... (uint16_t)(u8a * u8b) // Noncompliant\n  ... (int16_t)(s32a * s32b)\n  ... (int32_t)(s16a * s16b) // Noncompliant\n  ... (uint16_t)(f64a + f64b) // Noncompliant\n  ... (float32_t)(u16a + u16b) // Noncompliant\n  ... (float64_t)foo1(u16a + u16b)\n  ... (int32_t)buf16a[u16a + u16b]\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 10.3 - The value of a complex expression of integer type may only be cast to a type that is narrower and of the same signedness\n  as the underlying type of the expression. </li>\n  <li> MISRA C:2004, 10.4 - The value of a complex expression of floating type may only be cast to a narrower floating type. </li>\n</ul>\n<h3>See Also</h3>\n<ul>\n  <li> MISRA C:2004, section 6.10 </li>\n</ul>","debt":"10min"},{"summary":"Results of ~ and << operations on operands of underlying types unsigned char and unsigned short should immediately be cast to the operand's underlying type","type":"Bug","defaultSeverity":"Major","description":"<p>When <code>~</code> and <code>&lt;&lt;</code> are applied to small integer types (<code>unsigned char</code> or <code>unsigned short</code>), the\noperations are preceded by integral promotion, and the result may contain high-order bits which have not been anticipated.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nunsigned char port = 0x5aU;\nunsigned char result_8;\nunsigned short result_16;\nunsigned short mode;\nresult_8 = (~port) &gt;&gt; 4; // Noncompliant; '~port' is 0xFFA5 on a 16-bit machine but 0xFFFFFFA5 on a 32-bit machine. Result is 0xFA for both, but 0x0A may have been expected.\nresult_16 = ((port &lt;&lt; 4) &amp; mode) &gt;&gt; 6; // Noncompliant; result_16 value depends on the implemented size of an int.\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nresult_8 = ((unsigned char)(~port)) &gt;&gt; 4; // Compliant\nresult_16 = ((unsigned short)((unsigned short) port &lt;&lt; 4) &amp; mode) &gt;&gt; 6; // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 10.5 - If the bitwise operators ~ and &lt;&lt; are applied to an operand of underlying type unsigned char or unsigned short, the\n  result shall be immediately cast to the underlying type of the operand. </li>\n  <li> MISRA C++:2008, 5-0-10 - If the bitwise operators ~ and &lt;&lt; are applied to an operand with an underlying type of unsigned char or unsigned\n  short, the result shall be immediately cast to the underlying type of the operand. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SADFAQ\">CERT, EXP15-CPP.</a> - Beware of integer promotion when performing bitwise\n  operations on chars or shorts </li>\n</ul>","debt":"10min"},{"summary":"Function pointers should not be converted to any other type","type":"Bug","defaultSeverity":"Major","description":"<p>Conversion of a function pointer to a different type of pointer results in undefined behaviour. This means, for example, that a pointer to a\nfunction cannot be converted to a pointer to a different type of function.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint f(int a)\n{\n  float (*p)(float) = (float (*)(float)) &amp; f; // Noncompliant\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 11.1 - Conversions shall not be performed between a pointer to a function and any type other than an integral type. </li>\n  <li> MISRA C++:2008, 5-2-6 - A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type. </li>\n  <li> MISRA C:2012, 11.1 - Conversions shall not be performed between a pointer to a function and any other type </li>\n</ul>","debt":"10min"},{"summary":"Constants of unsigned type should have a \"U\" suffix","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The type of an integer is dependent on a complex combination of factors including:</p>\n<ul>\n  <li> The magnitude of the constant; </li>\n  <li> The implemented sizes of the integer types; </li>\n  <li> The presence of any suffixes; </li>\n  <li> The number base in which the value is expressed (i.e. decimal, octal or hexadecimal). </li>\n</ul>\n<p>For example, the value 0x8000 is of type <code>unsigned int</code> in a 16-bit environment, but of type (<code>signed</code>) <code>int</code> in a\n32-bit environment.</p>\n<p>Note:</p>\n<ul>\n  <li> Any value with a \"U\" suffix is of unsigned type; </li>\n  <li> An unsuffixed decimal value less than 2^31 is of signed type. </li>\n</ul>\n<p>But:</p>\n<ul>\n  <li> An unsuffixed hexadecimal value greater than or equal to 2^15 may be of signed or unsigned type; </li>\n  <li> For C90, an unsuffixed decimal value greater than or equal to 2^31 may be of signed or unsigned type. </li>\n</ul>\n<p>In C++, if an overload set includes candidates for an <code>unsigned int</code> and an <code>int</code>, then the overload that would be matched by\n0x8000 is therefore dependent on the implemented integer size. Adding a \"U\" suffix to the value specifies that it is unsigned.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 10.6 - A \"U\" suffix shall be applied to all constants of unsigned type. </li>\n  <li> MISRA C++:2008, 2-13-3 - A \"U\" suffix shall be applied to all octal or hexadecimal integer literals of unsigned type. </li>\n  <li> MISRA C:2012, 7.2 - A \"u\" or \"U\" suffix shall be applied to all integer constants that are represented in an unsigned type. </li>\n</ul>","debt":"5min"},{"summary":"Reserved identifiers and functions in the standard library should not be defined or declared","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Defining or declaring identifiers with reserved names may lead to undefined behavior. Similarly, defining macros, variables or functions/methods\nwith the same names as functions from the standard library is likely to lead to unexpected results. </p>\n<p>Additionally, such identifiers have the potential to thoroughly confuse people who are unfamiliar with the code base, possibly leading them to\nintroduce additional errors. Therefore reserved words and the names of standard library functions should not be used as identifiers.</p>\n<p>This rule applies to:</p>\n<ul>\n  <li> <code>defined</code> </li>\n  <li> standard library function names </li>\n  <li> identifiers that begin with two underscores </li>\n  <li> identifiers that begin with an underscore, followed by an uppercase letter </li>\n  <li> identifiers in the global namespace that start with an underscore </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#ifndef _MY_FILE\n#define _MY_FILE   // Noncompliant: starts with '_'\n\nint free(void *pArg, int len) {  // Noncompliant: free is a standard function\n  int __i; // Noncompliant: starts with \"__\"\n  //...\n}\n#endif\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#ifndef MY_FILE\n#define MY_FILE\n\nint clean(void *pArg, int len) {\n  int i;\n  //...\n}\n#endif\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.1 - Reserved identifiers, macros and functions in the standard library, shall not be defined redefined or undefined. </li>\n  <li> MISRA C++:2008, 17-0-1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined.\n  </li>\n  <li> MISRA C:2012, 21.2 - A reserved identifier or macro name shall not be declared </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/-4AzAg\">CERT, DCL37-C.</a> - Do not declare or define a reserved identifier </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/Qg8\">CERT, DCL51-CPP.</a> - Do not declare or define a reserved identifier </li>\n</ul>","debt":"10min"},{"summary":"Lines starting with \"#\" should contain valid preprocessing directives","type":"Bug","defaultSeverity":"Major","description":"<p>Preprocessing directives (lines that start with <code>#</code>) can be used to conditionally include or exclude code from compilation. Malformed\npreprocessing directives could lead to the exclusion or inclusion of more code than was intended. Therefore all preprocessing directives should be\nsyntactically meaningful.</p>\n<p>Recognized preprocessing directives are <code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>, <code>#define</code>,\n<code>#undef</code>, <code>#ifdef</code>, <code>#ifndef</code>, <code>#include</code>, <code>#line</code>, <code>#error</code>, and\n<code>#pragma</code>. Note that whitespace is allowed between the <code>#</code> and the directive.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#define AAA 2\n...\nint foo(void)\n{\n  int x = 0;\n  ...\n\n#ifndef AAA\n  x = 1;\n#else1  /* Noncompliant */\n  x = AAA;\n#endif\n\n  ...\n  return x;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#define AAA 2\n...\nint foo(void)\n{\n  int x = 0;\n  ...\n\n#ifndef AAA\n  x = 1;\n#else\n  x = AAA;\n#endif\n\n  ...\n  return x;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.16 - Preprocessing directives shall be syntactically meaningful even when excluded by preprocessor. </li>\n  <li> MISRA C++:2008, 16-0-8 - If the # token appears as the first token on a line, then it shall be immediately followed by a preprocessing token.\n  </li>\n  <li> MISRA C:2012, 20.13 - A line whose first token is # shall be a valid preprocessing directive </li>\n</ul>","debt":"5min"},{"summary":"Object pointers should only be converted to other object pointers, integral types or \"void\" pointers","type":"Bug","defaultSeverity":"Major","description":"<p>Such conversions are undefined.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct S1 *p1;\nstruct S2;\nvoid f ()\n{\n  (float) p1; // Noncompliant, conversion to floating point type\n  (int *) p1; // Noncompliant\n  (int) p1; // Compliant, conversion to an integral type\n  (void *) p1; // Compliant, conversion to 'void *'\n  (struct S2 *)p1; // Compliant, conversion to another type.\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 11.2 - Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer\n  to object type or a pointer to void. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/toAyAQ\">CERT, INT11-CPP.</a> - Take care when converting from pointer to integer or\n  integer to pointer </li>\n</ul>","debt":"10min"},{"summary":"Conditional operators should not be nested","type":"Code Smell","defaultSeverity":"Major","description":"<p>Just because you <em>can</em> do something, doesn't mean you should, and that's the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint max(int p1, int p2, int p3) {\n  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint max(int p1, int p2, int p3) {\n  if (p1 &gt; p2) {\n    return p1 &gt; p3 ? p1 : p3;\n  } else {\n    return p2 &gt; p3 ? p2 : p3;\n  }\n}\n</pre>","debt":"5min"},{"summary":"Line continuation characters '\\' should not be followed by trailing whitespace","type":"Bug","defaultSeverity":"Minor","description":"<p>The standard mentions that the line continuation character (<code>\\</code>) should be immediately followed by a newline or be the very last\ncharacter of the file in order for the lines to be joined.</p>\n<p>Several compilers relax this requirement by allowing whitespace after the <code>\\</code> character, but this is not portable because other\ncompilers may not do the same.</p>\n<h2>Compliant Solution</h2>\n<pre>\n// There should be no whitespace after the '\\'\n#define FOO BAR \\\n            BAZ\n</pre>","debt":"5min"},{"summary":"Forward declarations should not be redundant","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Redundant forward declarations simply clutter the code, and like any duplications, should be removed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct S {\n  // ...\n};\n// ...\nstruct S;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct S {\n  // ...\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"2min"},{"summary":"Macro names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all macro\nnames match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#define foo // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#define FOO\n</pre>","debt":"10min"},{"summary":"\"goto\" statements should not be used to jump into blocks","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Use of <code>goto</code> can lead to programs that are extremely difficult to comprehend and analyse, and possibly to unspecified behavior.</p>\n<p>Unfortunately, removing <code>goto</code> from some code can lead to a rewritten version that is even more difficult to understand than the\noriginal. Therefore, limited use of <code>goto</code> is sometimes advised. </p>\n<p>However, the use of <code>goto</code> to jump into or out of a sub-block of code, such as into the body of a <code>for</code> loop is never\nacceptable, because it is extremely difficult to understand and will likely yield results other than what is intended. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid f1 (int a) {\n  if (a &lt;=0) {\n    goto L2;  // Noncompliant; jumps into a different block\n  }\n\n  if (a == 0) {\n  {\n    goto L1; // Compliant\n  }\n  goto L2;  // Noncompliant; jumps into a block\n\nL1:\n  for (int i = 0; i &lt; a; i++) {\n  L2:\n    //...  Should only have come here with a &gt;=0. Loop is infinite if a &lt; 0\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid f1 (int a) {\n  if (a &lt;=0) {\n    // ...\n  }\n\n  if (a == 0) {\n  {\n    goto L1; // Compliant\n  }\n\nL1:\n  for (int i = 0; i &lt; a; i++) {\n  L2:\n    //...\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 6-6-1 - Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto\n  statement </li>\n  <li> MISRA C:2012, 15.3 - Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement\n  </li>\n</ul>","debt":"1h"},{"summary":"Dead stores should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value\nonly to then overwrite it or throw it away, could indicate a serious error in the code. Even if it's not an error, it is at best a waste of resources.\nTherefore all calculated values should be used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid pow(int a, int b) {\n  if (b == 0) {\n    return 0;\n  }\n  int x = a;\n  for (int i = 1; i &lt; b; i++) {\n    x = x * a;  // Dead store because the last return statement should return x instead of returning a\n  }\n  return a;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid pow(int a, int b) {\n  if (b == 0) {\n    return 0;\n  }\n  int x = a;\n  for (int i = 1; i &lt; b; i++) {\n    x = x * a;\n  }\n  return x;\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule ignores:</p>\n<ul>\n  <li> variable declarations initializers </li>\n  <li> prefix and postfix increments and decrements <code>x++;</code> </li>\n  <li> null pointer assignments <code>x = NULL;</code> </li>\n  <li> self assignments (i.e. <code>x = x;</code>) </li>\n</ul>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/563.html\">MITRE, CWE-563</a> - Assignment to Variable without Use ('Unused Variable') </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/QYA5\">CERT, MSC13-C.</a> - Detect and remove unused values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/S4IyAQ\">CERT, MSC13-CPP.</a> - Detect and remove unused values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/uQCSBg\">CERT, MSC56-J.</a> - Detect and remove superfluous code and values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"15min"},{"summary":"Preprocessor directives should not be indented","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Indenting preprocessor directives reduces the code readability, because it make preprocessor directives harder to spot.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid optimal()\n{\n  #if INTEL             /* Noncompliant - hard to spot */\n  specificIntelStuff();\n  #endif                /* Noncompliant - hard to spot */\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid optimal()\n{\n#if INTEL               /* Compliant */\n  specificIntelStuff();\n#endif                  /* Compliant */\n}\n</pre>","debt":"5min"},{"summary":"Unused function parameters should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid doSomething(int a, int b) { // Noncompliant, \"b\" is unused\n  compute(a);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doSomething(int a) {\n  compute(a);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>\n  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"5min"},{"summary":"Assignments should not be made from within sub-expressions","type":"Code Smell","defaultSeverity":"Major","description":"<p>Assignments within sub-expressions are hard to spot and therefore make the code less readable. Ideally, sub-expressions should not have\nside-effects.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ((str = cont.substring(pos1, pos2)).isEmpty()) {  // Noncompliant\n  //...\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstr = cont.substring(pos1, pos2);\nif (str.isEmpty()) {\n  //...\n</pre>\n<h2>Exceptions</h2>\n<p>Assignments explicitly enclosed in parentheses are ignored.</p>\n<pre>\nwhile ((run = keepRunning())) {\n  //...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.1 - Assignment operators shall not be used in expressions that yield a Boolean value </li>\n  <li> MISRA C++:2008, 6-2-1 - Assignment operators shall not be used in sub-expressions </li>\n  <li> MISRA C:2012, 13.4 - The result of an assignment operator should not be used </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/481.html\">MITRE, CWE-481</a> - Assigning instead of Comparing </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/nYFtAg\">CERT, EXP45-C.</a> - Do not perform assignments in selection statements </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/1gCTAw\">CERT, EXP51-J.</a> - Do not perform assignments in conditional expressions\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KQvhAg\">CERT, EXP19-CPP.</a> - Do not perform assignments in conditional expressions\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KYIyAQ\">CERT, MSC02-CPP.</a> - Avoid errors of omission </li>\n</ul>","debt":"5min"},{"summary":"Stack allocated memory should not be freed","type":"Bug","defaultSeverity":"Blocker","description":"<p>Stack allocated memory allocated with functions <code>alloca</code>, <code>_alloca</code>, <code>_malloca</code>, <code>__builtin_alloca</code> is\nautomatically released at the end of the function, it should not be released with <code>free</code>. Explicitly <code>free</code>-ing such memory\nresults in undefined behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fun() {\n  char *name = (char *) alloca(size);\n  // ...\n  free(name); // Noncompliant, memory allocated on the stack\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid fun() {\n  char *name = (char *) alloca(size);\n  // ...\n}\n</pre>","debt":"2min"},{"summary":"Object and function types should be explicitly stated in their declarations and definitions","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The C90 standard allows implicit typing of variables and functions, and some C compilers still support legacy code by allowing implicit typing. But\nit should not be used for new code because it might lead to confusion.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nextern x;\nconst x;\nstatic fun(void);\ntypedef ( *pfi ) ( void );\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nextern int16_t x;\nconst int16_t x;\nstatic int16_t fun(void);\ntypedef int16_t ( *pfi ) ( void );\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 8.2 - Whenever an object or function is declared or defined, its type shall be explicitly stated </li>\n  <li> MISRA C:2012, 8.1 - Types shall be explicitly specified </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/tgDI\">CERT, DCL31-C.</a> - Declare identifiers before using them </li>\n</ul>","debt":"5min"},{"summary":"Track uses of \"NOSONAR\" comments","type":"Code Smell","defaultSeverity":"Major","description":"<p>Any issue to quality rule can be deactivated with the <code>NOSONAR</code> marker. This marker is pretty useful to exclude false-positive results\nbut it can also be used abusively to hide real quality flaws.</p>\n<p>This rule raises an issue when <code>NOSONAR</code> is used.</p>","debt":"1min"},{"summary":"Object declarations should contain no more than 2 levels of pointer indirection","type":"Code Smell","defaultSeverity":"Critical","description":"<p>While they are extraordinarily useful, pointers are not the most intuitive concept in the world. Pointers to pointers are even harder to understand\nand use correctly. And with each additional level of indirection, pointer variables become more difficult to use correctly. Therefore pointer\ndeclarators should be limited to no more than two levels of nesting. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntypedef int * INTPTR;\nstruct s {\n int ** s1;\n int *** s2; // Noncompliant\n};\n\nstruct s ** ps1;\nstruct s *** ps2; // Noncompliant\n\nint ** ( *pfunc1)();\nint ** ( **pfunc2)();\nint ** (***pfunc3)(); // Noncompliant\nint *** ( **pfunc4)(); // Noncompliant\n\nvoid function( int ** par1,\n               int *** par2, // Noncompliant\n               INTPTR * par3,\n               int * par4[],\n               int ** par5[]) // Noncompliant\n{\n  int ** ptr1;\n  int *** ptr2; // Noncompliant\n  INTPTR * ptr3;\n  int * ptr4[ 10 ];\n  int ** ptr5[ 10 ]; //Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntypedef int * INTPTR;\nstruct s {\n int ** s1;\n int ** s2;\n};\n\nstruct s ** ps1;\nstruct s ** ps2;\n\nint ** (*pfunc1)();\nint ** (**pfunc2)();\nint ** (**pfunc3)();\nint ** (**pfunc4)();\n\nvoid function( int ** par1,\n               int ** par2,\n               INTPTR * par3,\n               int * par4[],\n               int * par5[])\n{\n  int ** ptr1;\n  int ** ptr2;\n  INTPTR * ptr3;\n  int * ptr4[ 10 ];\n  int * ptr5[ 10 ];\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 17.5 - The declaration of objects should contain no more than 2 levels of pointer indirection </li>\n  <li> MISRA C++:2008, 5-0-19 - The declaration of objects shall contain no more than two levels of pointer indirection </li>\n  <li> MISRA C:2012, 18.5 - Declarations should contain no more than two levels of pointer nesting </li>\n</ul>","debt":"15min"},{"summary":"Functions should not be declared at block scope","type":"Code Smell","defaultSeverity":"Major","description":"<p>A function declared at block scope will refer to a member of the enclosing namespace, and so the declaration should be explicitly placed at the\nnamespace level.</p>\n<p>Additionally, where a declaration statement could either declare a function or an object, the compiler will choose to declare the function. To\navoid potential developer confusion over the meaning of a declaration, functions should not be declared at block scope.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass A {\n};\n\nvoid fun() {\n  void nestedFun();  // Noncompliant; declares a function in block scope\n\n  A a();      // Noncompliant; declares a function at block scope, not an object\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 8.6 - Functions shall be declared at file scope </li>\n  <li> MISRA C++:2008, 3-1-2 - Functions shall not be declared at block scope </li>\n</ul>","debt":"5min"},{"summary":"The name \"main\" should not be used for any function other than the global \"main\" function","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>A global function named <code>main</code> is the entry point to the program, and is the only identifier which must be in the global namespace. The\nuse of <code>main</code> for other functions may not meet developer expectations.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint main() {       // Compliant\n}\n\nnamespace {\n  int main() {     // Noncompliant\n  }\n}\nnamespace NS {\n  int main() {     // Noncompliant\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 7-3-2 - The identifier main shall not be used for a function other than global function main. </li>\n</ul>","debt":"20min"},{"summary":"Related \"if/else if\" statements should not have the same condition","type":"Bug","defaultSeverity":"Major","description":"<p>A chain of <code>if</code>/<code>else if</code> statements is evaluated from top to bottom. At most, only one branch will be executed: the first\none with a condition that evaluates to <code>true</code>. </p>\n<p>Therefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it's simply dead code and\nat worst, it's a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (param == 1)\n  openWindow();\nelse if (param == 2)\n  closeWindow();\nelse if (param == 1)  // Noncompliant\n  moveWindowToTheBackground();\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (param == 1)\n  openWindow();\nelse if (param == 2)\n  closeWindow();\nelse if (param == 3)\n  moveWindowToTheBackground();\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"10min"},{"summary":"Expressions should not be too complex","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The complexity of an expression is defined by the number of <code>&amp;&amp;</code>, <code>||</code> and <code>condition ? ifTrue : ifFalse</code>\noperators it contains.</p>\n<p>A single expression's complexity should not become too high to keep the code readable.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold value 3.</p>\n<pre>\nif (((condition1 &amp;&amp; condition2) || (condition3 &amp;&amp; condition4)) &amp;&amp; condition5) { ... }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif ((myFirstCondition() || mySecondCondition()) &amp;&amp; myLastCondition()) { ... }\n</pre>","debt":"5min"},{"summary":"Collapsible \"if\" statements should be merged","type":"Code Smell","defaultSeverity":"Major","description":"<p>Merging collapsible <code>if</code> statements increases the code's readability.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition1) {\n  if (condition2) {             // NonCompliant\n    /* ... */\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition1 &amp;&amp; condition2) { // Compliant\n  /* ... */\n}\n</pre>","debt":"5min"},{"summary":"Unused labels should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>If a label is declared but not used in the program, it can be considered as dead code and should therefore be removed.</p>\n<p>This will improve maintainability as developers will not wonder what this label is used for.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fun() {\n  label: doSomething();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid fun() {\n  doSomething();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 2.6 - A function should not contain unused label declarations </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"2min"},{"summary":"Methods should not be empty","type":"Code Smell","defaultSeverity":"Critical","description":"<p>There are several reasons for a method not to have a method body:</p>\n<ul>\n  <li> It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. </li>\n  <li> It is not yet, or never will be, supported. In this case an exception should be thrown in languages where that mechanism is available. </li>\n  <li> The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fun(int p1) {\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid fun(int p1) {\n  int a = doSomething(p1);\n  int threshold = 42;\n  if (a &gt; threshold) {\n    // ...\n  }\n}\n</pre>\n<p>or </p>\n<pre>\nvoid fun(int p1) {\n  // Intentionally unimplemented...\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule doesn't raise an issue for empty class constructors or destructors. For instance this is the only way to define user-defined default\nconstructors.</p>","debt":"5min"},{"summary":"\"#include\" paths should be portable","type":"Code Smell","defaultSeverity":"Major","description":"<p>The path provided here doesn't match the actual path on this file system (e.g. the case is different). While this may work on a particular\nenvironment, this is not portable and may fail on a different environment.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include \"Foo.h\" // Noncompliant, the file name is \"foo.h\"\n</pre>","debt":"5min"},{"summary":"Non-reentrant POSIX functions should be replaced with their reentrant versions","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>A function is called reentrant if it can be interrupted in the middle of its execution and then safely called again (\"re-entered\") before its\nprevious invocations complete execution.</p>\n<p>It is especially important that multi-threaded applications do not call the same non-reentrant function from different threads.</p>\n<p>This rule will trigger an issue each time a function in the configurable list is invoked.</p>\n<h2>Noncompliant Code Example</h2>\n<p>Given a function that includes <code>localtime</code>:</p>\n<pre>\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nvoid print_date_and_time(struct tm *time_ptr)\n{\n  printf(\n    \"Current date and time: %d/%02d/%02d %02d:%02d:%02d\\n\",\n    time_ptr-&gt;tm_year + 1900,\n    time_ptr-&gt;tm_mon,\n    time_ptr-&gt;tm_mday,\n    time_ptr-&gt;tm_hour,\n    time_ptr-&gt;tm_min,\n    time_ptr-&gt;tm_sec);\n}\n\nvoid print_unix_epoch_date_and_time()\n{\n  time_t unix_epoch_time = (time_t)0;\n  struct tm *local_time_ptr = localtime(&amp;unix_epoch_time); // Noncompliant, call to the non-reentrant localtime() function\n  print_date_and_time(local_time_ptr);\n}\n\nint main(int argc, char* argv[])\n{\n  time_t current_time;\n  struct tm *local_time_ptr;\n\n  time(&amp;current_time);\n\n  local_time_ptr = localtime(&amp;current_time); // Noncompliant, call to the non-reentrant localtime() function\n\n  // As expected, this will print: Current date and time: 1970/00/01 01:00:00\n  print_unix_epoch_date_and_time();\n\n  // This will actually also print Current date and time: 1970/00/01 01:00:00\n  // Indeed, localtime() is non-reentrant, and always returns the same pointer\n  print_date_and_time(local_time_ptr);\n\n  return 0;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nvoid print_date_and_time(struct tm *time_ptr)\n{\n  printf(\n    \"Current date and time: %d/%02d/%02d %02d:%02d:%02d\\n\",\n    time_ptr-&gt;tm_year + 1900,\n    time_ptr-&gt;tm_mon,\n    time_ptr-&gt;tm_mday,\n    time_ptr-&gt;tm_hour,\n    time_ptr-&gt;tm_min,\n    time_ptr-&gt;tm_sec);\n}\n\nvoid print_unix_epoch_date_and_time()\n{\n  time_t unix_epoch_time = (time_t)0;\n  struct tm local_time;\n  localtime_r(&amp;unix_epoch_time, &amp;local_time); // Compliant\n  print_date_and_time(&amp;local_time);\n}\n\nint main(int argc, char* argv[])\n{\n  time_t current_time;\n  struct tm local_time;\n\n  time(&amp;current_time);\n\n  localtime_r(&amp;current_time, &amp;local_time); // Compliant\n\n  // As expected, this will print: Current date and time: 1970/00/01 01:00:00\n  print_unix_epoch_date_and_time();\n\n  // As expected, this will print the current date and time, as expected\n  print_date_and_time(&amp;local_time);\n\n  return 0;\n}\n</pre>","debt":"30min"},{"summary":"Comment styles \"//\" and \"/* ... */\" should not be mixed within a file","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Use either the <code>// ...</code> or <code>/* ... */</code> comment syntax, but be consistent and do not mix them within the same file.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n/* Noncompliant; both comment syntaxes are used in the same file */\n// Foo\n/* Bar */\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// Compliant; uniform comment syntax\n// Foo\n// Bar\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/DQBWB\">CERT, MSC55-J.</a> - Use comments consistently and in a readable fashion </li>\n</ul>","debt":"5min"},{"summary":"Parameter values should be appropriate","type":"Bug","defaultSeverity":"Critical","description":"<p>The standard C library includes a number of functions for string and memory manipulation. They take pointers and a lengths as parameters. Passing\n<code>NULL</code> for the pointers will at best do nothing and at worst crash the application.</p>\n<p>This rule raises an issue when <code>NULL</code> is passed as a pointer in to any of the following functions:</p>\n<ul>\n  <li> <code>void *memcpy(void *dest, const void *src, size_t n);</code> </li>\n  <li> <code>void *memmove(void *dest, const void *src, size_t n);</code> </li>\n  <li> <code>void *memccpy(void *dest, const void *src, int c, size_t n);</code> </li>\n  <li> <code>void *memset(void *s, int c, size_t n);</code> </li>\n  <li> <code>int memcmp(const void *s1, const void *s2, size_t n);</code> </li>\n  <li> <code>void *memchr(const void *s, int c, size_t n);</code> </li>\n  <li> <code>void *rawmemchr(const void *s, int c);</code> </li>\n  <li> <code>void *memrchr(const void *s, int c, size_t n);</code> </li>\n  <li> <code>char *strcpy(char *dest, const char *src);</code> </li>\n  <li> <code>char *strncpy(char *dest, const char *src, size_t n);</code> </li>\n  <li> <code>char *strcat(char *dest, const char *src);</code> </li>\n  <li> <code>char *strncat(char *dest, const char *src, size_t n);</code> </li>\n  <li> <code>int strcmp(const char *s1, const char *s2);</code> </li>\n  <li> <code>int strncmp(const char *s1, const char *s2, size_t n);</code> </li>\n  <li> <code>int strcoll(const char *s1, const char *s2);</code> </li>\n  <li> <code>size_t strxfrm(char *dest, const char *src, size_t n);</code> </li>\n  <li> <code>int strcoll_l(const char *s1, const char *s2, locale_t loc);</code> </li>\n  <li> <code>size_t strxfrm_l(char *restrict s1, const char *restrict s2, size_t n, locale_t loc);</code> </li>\n  <li> <code>char *strdup(const char *s);</code> </li>\n  <li> <code>char *strndup(const char *s, size_t n);</code> </li>\n  <li> <code>char *strchr(const char *s, int c);</code> </li>\n  <li> <code>char *strrchr(const char *s, int c);</code> </li>\n  <li> <code>char *strchrnul(const char *s, int c);</code> </li>\n  <li> <code>size_t strcspn(const char *s, const char *reject);</code> </li>\n  <li> <code>size_t strspn(const char *s, const char *accept);</code> </li>\n  <li> <code>char *strpbrk(const char *s, const char *accept);</code> </li>\n  <li> <code>char *strstr(const char *haystack, const char *needle);</code> </li>\n  <li> <code>char *strtok(char *s, const char *delim);</code> </li>\n  <li> <code>char *strtok_r(char *str, const char *delim, char **saveptr);</code> </li>\n  <li> <code>char *strcasestr(const char *haystack, const char *needle);</code> </li>\n  <li> <code>void *memmem(const void *haystack, size_t haystacklen, const void *needle, size_t needlelen);</code> </li>\n  <li> <code>void *mempcpy(void *dest, const void *src, size_t n);</code> </li>\n  <li> <code>size_t strlen(const char *s);</code> </li>\n  <li> <code>size_t strnlen(const char *s, size_t maxlen);</code> </li>\n  <li> <code>char *strerror_r(int errnum, char *buf, size_t buflen);</code> </li>\n  <li> <code>void bcopy(const void *src, void *dest, size_t n);</code> </li>\n  <li> <code>void bzero(void *s, size_t n);</code> </li>\n  <li> <code>int bcmp(const void *s1, const void *s2, size_t n);</code> </li>\n  <li> <code>char *index(const char *s, int c);</code> </li>\n  <li> <code>char *rindex(const char *s, int c);</code> </li>\n  <li> <code>int strcasecmp(const char *s1, const char *s2);</code> </li>\n  <li> <code>int strncasecmp(const char *s1, const char *s2, size_t n);</code> </li>\n  <li> <code>int strcasecmp_l(const char *s1, const char *s2, locale_t loc);</code> </li>\n  <li> <code>int strncasecmp_l(const char *s1, const char *s2, size_t n, locale_t loc);</code> </li>\n  <li> <code>char *strsep(char **stringp, const char *delim);</code> </li>\n  <li> <code>char *stpcpy(char *dest, const char *src);</code> </li>\n  <li> <code>char *stpncpy(char *dest, const char *src, size_t n);</code> </li>\n  <li> <code>int strverscmp(const char *s1, const char *s2);</code> </li>\n  <li> <code>char *strfry(char *string);</code> </li>\n  <li> <code>void *memfrob(void *s, size_t n);</code> </li>\n  <li> <code>char *basename(char *path);</code> </li>\n</ul>\n<p>This rule raises an issue when 0 is passed as a length to any of the following functions, since the last two parameters might have been swapped by\nmistake:</p>\n<ul>\n  <li> <code>void *memccpy(void *dest, const void *src, int c, size_t n);</code> </li>\n  <li> <code>void *memset(void *s, int c, size_t n);</code> </li>\n  <li> <code>void *memchr(const void *s, int c, size_t n);</code> </li>\n  <li> <code>void *memrchr(const void *s, int c, size_t n);</code> </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nmemcpy(NULL, src, 10); // Noncompliant, null pointer\nmemset(ptr, 0, 0); // Noncompliant, length is zero\n</pre>","debt":"5min"},{"summary":"Type specifiers should be listed in a standard order","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that type specifiers always appear in the following order:</p>\n<ol>\n  <li> <code>typedef</code> </li>\n  <li> <code>const</code> </li>\n  <li> type name, spelling of built-in types with more than one type-specifier:\n    <ol>\n      <li> signedness - <code>signed</code> or <code>unsigned</code> </li>\n      <li> last single type-specifier or\n        <ul>\n          <li> <code>short int</code> </li>\n          <li> <code>long int</code> </li>\n          <li> <code>long long int</code> </li>\n          <li> <code>long double</code> </li>\n        </ul> </li>\n    </ol> </li>\n</ol>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint typedef T;\n\ndouble long d;\nchar unsigned ch;\nlong signed int i;\n\nint const *p;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntypedef int T;\n\nlong double d;\nunsigned char ch;\nsigned long int i;\n\nconst int *p; // or \"int * const p;\"\n</pre>","debt":"2min"},{"summary":"\"#import\" should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>#import</code> comes from Objective-C and is a variant of <code>#include</code>. GCC does support it, but it requires the users of a header\nfile to know that it should only be included once. It is much better for the header file's implementor to write the file so that users don't need to\nknow this. Using a wrapper <code>#ifndef</code> accomplishes this goal.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#import \"foo.h\" // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include \"foo.h\"\n</pre>","debt":"1min"},{"summary":"All branches in a conditional structure should not have exactly the same implementation","type":"Bug","defaultSeverity":"Major","description":"<p>Having all branches in a <code>switch</code> or <code>if</code> chain with the same implementation is an error. Either a copy-paste error was made\nand something different should be executed, or there shouldn't be a <code>switch</code>/<code>if</code> chain at all. Note that this rule does not\napply to <code>if</code> chains without <code>else</code>-s, or to <code>switch</code>-es without <code>default</code> clauses.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (b == 0) {  // Noncompliant\n  doOneMoreThing();\n}\nelse {\n  doOneMoreThing();\n}\n\nint b = a &gt; 12 ? 4 : 4;  // Noncompliant\n\nswitch (i) {  // Noncompliant\n  case 1:\n    doSomething();\n    break;\n  case 2:\n    doSomething();\n    break;\n  case 3:\n    doSomething();\n    break;\n  default:\n    doSomething();\n}\n</pre>","debt":"15min"},{"summary":"Variables should be initialized before use","type":"Bug","defaultSeverity":"Major","description":"<p>Variables should be initialized before their use to avoid unexpected behaviors due to garbage values.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid function(int flag, int b) {\n  int a;\n  if (flag) {\n    a = b;\n  }\n  return a; // Noncompliant - \"a\" has not been initialized in all paths\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid function(int flag, int b) {\n  int a = 0;\n  if (flag) {\n    a = b;\n  }\n  return a;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/457.html\">MITRE, CWE-457</a> - Use of Uninitialized Variable </li>\n  <li> MISRA C:2004, 9.1 - All automatic variables shall have been assigned a value before being used. </li>\n  <li> MISRA C++:2008, 8-5-1 - All variables shall have a defined value before they are used. </li>\n</ul>","debt":"15min"},{"summary":"Literal suffixes shall be upper case","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Using upper case literal suffixes removes the potential ambiguity between \"1\" (digit 1) and \"l\" (letter el) for declaring literals.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst int        a = 0u;      // Noncompliant\nconst int        b = 0l;      // Noncompliant\nconst int        c = 0Ul;     // Noncompliant\nconst int        d = 0x12bu;  // Noncompliant\nconst float      m = 1.2f;    // Noncompliant\nconst float      n = 1.2l;    // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst int        a = 0U;\nconst int        b = 0L;\nconst int        c = 0UL;\nconst int        d = 0x12bU;\nconst float      m = 1.2F;\nconst float      n = 1.2L;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 2-13-4 - Literal suffixes shall be upper case </li>\n  <li> MISRA C:2012, 7.3 - The lowercase character \"l\" shall not be used in a literal suffix </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/koAtAQ\">CERT DCL16-C.</a> - Use \"L,\" not \"l,\" to indicate a long value </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/n4AtAQ\">CERT DCL16-CPP.</a> - Use \"L,\" not \"l,\" to indicate a long value </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/hYClBg\">CERT, DCL50-J.</a> - Use visually distinct identifiers </li>\n</ul>","debt":"2min"},{"summary":"Macros should not be #define'd or #undef'd within a block","type":"Code Smell","defaultSeverity":"Critical","description":"<p>While it is legal to place <code>#define</code> and <code>#undef</code> directives anywhere in a source file, placing them outside of the global\nnamespace is misleading since their scope is not actually restricted. This may be inconsistent with developer expectations.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnamespace NS\n{\n  #ifndef MY_HDR\n  #define MY_HDR    /* Noncompliant */\n  #undef FOO        /* Noncompliant */\n  #endif\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#ifndef MY_HDR\n#define MY_HDR\n#undef FOO\n#endif\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.5 - Macros shall not be #define'd or #undef'd within a block. </li>\n  <li> MISRA C++:2008, 16-0-2 - Macros shall only be #define'd or #undef'd in the global namespace. </li>\n</ul>","debt":"10min"},{"summary":"Structure and union types should be complete at the end of a translation unit","type":"Code Smell","defaultSeverity":"Minor","description":"<p>A complete declaration of the structure or union shall be included within any translation unit that refers to that structure. See section 6.1.2.5\nof ISO 9899:1990 [2] for a full description of incomplete types.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct tnode * pt; // tnode is incomplete\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct tnode * pt; // tnode is incomplete at this point\nstruct tnode\n{\n  int count;\n  struct tnode * left;\n  struct tnode * right;\n}; // type tnode is now complete\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 18.1 - All structure and union types shall be complete at the end of a translation unit. </li>\n</ul>","debt":"10min"},{"summary":"The \"<stdlib.h>\" functions \"bsearch\" and \"qsort\" should not be used","type":"Bug","defaultSeverity":"Major","description":"<p>The identifiers <code>bsearch</code> and <code>qsort</code> shall not be used and no macro with one of these names shall be expanded. </p>\n<p>These two functions take as arguments a caller-defined comparison function. If the comparison function does not behave consistently when comparing\nelements, or if it modifies any of the elements, the behavior is undefined.</p>\n<p>Note: the unspecified behavior, which relates to the treatment of elements that compare as equal, can be avoided by ensuring that the comparison\nfunction never returns 0. When two elements are otherwise equal, the comparison function could return a value that indicates their relative order in\nthe initial array. </p>\n<p>Further, the implementation of <code>qsort</code> is likely to be recursive and will therefore place unknown demands on stack resources. This is of\nconcern in embedded systems because the stack is likely to have a fixed, often small, size.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 21.9 - The library functions <code>bsearch</code> and <code>qsort</code> of <code>&lt;stdlib.h&gt;</code> shall not be used.\n  </li>\n</ul>","debt":"10min"},{"summary":"Braces should be used to indicate and match the structure in the non-zero initialization of arrays and structures","type":"Code Smell","defaultSeverity":"Major","description":"<p>ISO/IEC 14882:2003 [1] requires initializer lists for arrays, structures and union types to be enclosed in a single pair of braces (though the\nbehaviour if this is not done is undefined). The rule given here goes further in requiring the use of additional braces to indicate nested\nstructures.</p>\n<p>This forces the developer to explicitly consider and demonstrate the order in which elements of complex data types are initialized (e.g.\nmulti-dimensional arrays).</p>\n<p>The zero initialization of arrays or structures shall only be applied at the top level.</p>\n<p>The non-zero initialization of arrays or structures requires an explicit initializer for each element.</p>\n<p>A similar principle applies to structures, and nested combinations of structures, arrays and other types.</p>\n<p>Note also that all the elements of arrays or structures can be initialized (to zero or NULL) by giving an explicit initializer for the first\nelement only. If this method of initialization is chosen then the first element should be initialized to zero (or NULL), and nested braces need not be\nused.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint a1[3][2] = { 1, 2, 3, 4, 5, 6 }; // Noncompliant\nint a2[5] = { 1, 2, 3 }; // Noncompliant, partial initialization\nint a3[2][2] = { { }, { 1, 2 } }; // Noncompliant, zero initialization at sub-level\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint a1[3][2] = { { 1, 2 }, { 3, 4 }, { 5, 6 } }; // Compliant\nint a2[5] = { 1, 2, 3, 0, 0 }; // Compliant, Non-zero initialization\nint a2[5] = { 0 }; // Compliant, zero initialization\nint a3[2][2] = { }; // Compliant, zero initialization\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 9.2 - Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures. </li>\n  <li> MISRA C++:2008, 8-5-2 - Braces shall be used to indicate and match the structure in the nonzero initialization of arrays and structures. </li>\n  <li> MISRA C:2012, 9.2 - The initializer of an aggregate or union shall be enclosed in braces. </li>\n</ul>","debt":"5min"},{"summary":"Array declarations should include an explicit size specification","type":"Code Smell","defaultSeverity":"Major","description":"<p>It is possible to declare an array without explicitly specifying its size, but using an explicit size declaration is clearer, and is therefore\npreferred.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint arr1 [ ];  // Noncompliant; nothing specified\nint arr2 [ ] = { [0] = 1, [12] = 36, [4] = 93 }; // Noncompliant; highest index determines size. May be difficult to spot\nint pirate [ ] = { 2, 4, 8, 42, 501, 90210, 7, 1776 }; // Noncompliant; size is implicit, not explicit\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint arr1 [10];\nint arr2 [13] = { [0] = 1, [12] = 36, [4] = 93 };\nint pirate [10] = { 2, 4, 8, 42, 501, 90210, 7, 1776 }; // Implicitly-assigned size was 8. Desired size was 10.\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 8.12 - When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by\n  initialisation </li>\n  <li> MISRA C++:2008, 3-1-3 - When an array is declared, its size shall either be stated explicitly or defined implicitly by initialization </li>\n  <li> MISRA C:2012, 8.11 - When an array with external linkage is declared, its size should be explicitely specified </li>\n  <li> MISRA C:2012, 9.5 - Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/HQEOAQ\">CERT, ARR02-C.</a> - Explicitly specify array bounds, even if implicitly\n  defined by an initializer </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/_IAyAQ\">CERT, CTR02-CPP.</a> - Explicitly specify array bounds, even if implicitly\n  defined by an initializer </li>\n</ul>","debt":"2min"},{"summary":"Empty \"case\" clauses that fall through to the \"default\" should be omitted","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Empty <code>case</code> clauses that fall through to the default are useless. Whether or not such a <code>case</code> is present, the\n<code>default</code> clause will be invoked. Such <code>case</code>s simply clutter the code, and should be removed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch(ch)\n{\n  case 'a' :\n    handleA();\n    break;\n  case 'b' :\n    handleB();\n    break;\n  case 'c' :  // Noncompliant\n  default:\n    handleTheRest();\n    break;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch(ch)\n{\n  case 'a' :\n    handleA();\n    break;\n  case 'b' :\n    handleB();\n    break;\n  default:\n    handleTheRest();\n    break;\n}\n</pre>","debt":"1min"},{"summary":"Nested blocks of code should not be left empty","type":"Code Smell","defaultSeverity":"Major","description":"<p>Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid foo()\n{\n  int x;\n  if (x == 42)\n  {                     /* Noncompliant */\n    /* do nothing */\n  }\n  else\n  {\n    printf(\"x != 42\");\n  }\n}\n\nvoid bar()\n{                       /* Compliant - functions are not nested blocks */\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid foo()\n{\n  int x;\n  if (x != 42)\n  {                     /* Compliant */\n    printf(\"x != 42\");\n  }\n}\n\n/* ... */\n</pre>\n<h2>Exceptions</h2>\n<p>When a block contains a comment, this block is not considered to be empty.</p>","debt":"5min"},{"summary":"Control should not be transferred into a complex logic block using a \"goto\" or a \"switch\" statement","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Having a <code>switch</code> and its cases wholly encompassed by a control structure such as a <code>try</code>, <code>@try</code>,\n<code>catch</code>, <code>@catch</code>, or a loop is perfectly acceptable. (<code>try</code> and <code>catch</code> are used hereafter to refer to\nboth variants.) It is also acceptable to have a <code>goto</code> and its target label wholly encompassed in a control structure. </p>\n<p>What is not acceptable is using a <code>goto</code> or <code>case</code> to suddenly jump into the body of a <code>try</code>, <code>catch</code>,\nObjective-C <code>@finally</code>, or loop structure. Tangling labels or <code>switch</code> blocks with other control structures results in code that\nis difficult, if not impossible to understand. More importantly, when it compiles (some of these constructs won't compile under ISO-conformant\ncompilers), it can lead to unexpected results. Therefore this usage should be strictly avoided.</p>\n<p>This C++ code sample, which is also applicable to Objective-C if <code>try</code> and <code>catch</code> are converted to <code>@try</code> and\n<code>@catch</code>, demonstrates jumping into a <code>switch</code> and into a <code>try</code> and <code>catch</code> :</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid f ( int32_t i )\n{\n  if ( 10 == i )\n  {\n    goto Label_10; // Noncompliant; goto transfers control into try block\n  }\n\n  if ( 11 == i )\n  {\n    goto Label_11; // Noncompliant; goto transfers control into catch block\n  }\n\n  switch ( i )\n  {\n    case 1:\n      try\n      {\n        Label_10:\n        case 2:  // Noncompliant; switch transfers control into try block\n          // Action\n          break;\n      }\n      catch ( ... )\n      {\n        Label_11:\n        case 3: // Noncompliant; switch transfers control into catch block\n          // Action\n          break;\n      }\n      break;\n    default:\n    {\n      // Default Action\n      break;\n    }\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid f ( int32_t i )\n{\n  switch ( i )\n  {\n    case 1:\n    case 2:\n      // Action\n      break;\n    case 3:\n      // Action\n      break;\n    case 10:\n\n    default:\n    {\n      // Default Action\n      break;\n    }\n  }\n\n  try\n  {\n    if ( 2 == i || 10 == i)\n    {\n      // Action\n    }\n  }\n  catch ( ... )\n  {\n    if (3 == i || 11 == i)\n    {\n      // Action\n    }\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 15-0-3 - Control shall not be transferred into a try or catch block using goto or switch statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/DgDFAQ\">CERT, MSC20-C.</a> - Do not use a switch statement to transfer control into a\n  complex block </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/wwDAAQ\">CERT, MSC20-CPP.</a> - Do not use a switch statement to transfer control into a\n  complex block </li>\n</ul>","debt":"15min"},{"summary":"Values should not be uselessly incremented","type":"Bug","defaultSeverity":"Major","description":"<p>A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint pickNumber() {\n  int i = 0;\n  int j = 0;\n\n  i = i++; // Noncompliant; i is still zero\n\n  return j++; // Noncompliant; 0 returned\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint pickNumber() {\n  int i = 0;\n  int j = 0;\n\n  i++;\n  return ++j;\n}\n</pre>","debt":"5min"},{"summary":"Control flow statements \"if\", \"for\", \"while\", \"switch\" and \"try\" should not be nested too deeply","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Nested <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> statements is a key\ningredient for making what's known as \"Spaghetti code\".</p>\n<p>Such code is hard to read, refactor and therefore maintain.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold of 3:</p>\n<pre>\n  if (condition1) {                  // Compliant; depth = 1\n    /* ... */\n    if (condition2) {                // Compliant; depth = 2\n      /* ... */\n      for(int i = 0; i &lt; 10; i++) {  // Compliant; depth = 3, not exceeding the limit\n        /* ... */\n        if (condition4) {            // Noncompliant; depth = 4\n          if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4\n            /* ... */\n          }\n          return;\n        }\n      }\n    }\n  }\n</pre>\n<h2>Exceptions</h2>\n<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow\nstatement.</p>\n<pre>\n  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)\n\n  if (condition1) {       // Compliant; depth = 1\n    if (condition2) {     // Compliant; depth = 2\n      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)\n        if (condition3) {   // Noncompliant; depth = 4\n          /* ... */\n        }\n      }\n    }\n  }\n</pre>","debt":"10min"},{"summary":"Bit fields should not be used","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>The real need for bit fields is narrow and highly specialized. Previously, they were used to save memory, but that's less a concern in modern\nsystems than are the extra instructions required to interact with them. Today, they may be needed in direct hardware interaction, but since their\nbehavior is platform-dependent, getting them right can be tricky, and since their use is increasingly rare these days, they're likely to confuse\nmaintainers. For these reasons, it's simpler and more performant to use another field type instead of bit fields.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nunsigned int b1 : 3;  // Noncompliant\nunsigned char b2 : 3;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nunsigned int b1;\nunsigned char b2;\n</pre>","debt":"10min"},{"summary":"\"restrict\" should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The <code>restrict</code> type qualifier is a guarantee by the programmer that there are no other pointers with access to the referenced object,\nand that the object does not overlap with any other object in memory. Its use may allow the compiler to generate more efficient byte code. </p>\n<p>However, this is a tricky language feature to use correctly, and there is significant risk of unexpected program behavior if <code>restrict</code>\nis misused. Therefore, <code>restrict</code> should not be used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid user_copy (\n  void * restrict p,  // Noncompliant parameter\n  void * restrict q,  // Noncompliant parameter\n  size_t n\n) {\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 8.14 - The restrict type qualifier shall not be used </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/QQBLBw\">CERT, EXP43-C.</a> - Avoid undefined behavior when using restrict-qualified\n  pointers </li>\n</ul>","debt":"10min"},{"summary":"Digraphs should not be used","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>The use of digraphs may not meet developer expectations.</p>\n<p>The digraphs are: </p>\n<ul>\n  <li> <code>&lt;%</code> </li>\n  <li> <code>%&gt;</code> </li>\n  <li> <code>&lt;:</code> </li>\n  <li> <code>:&gt;</code> </li>\n  <li> <code>%:</code> </li>\n  <li> <code>%:%:</code> </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntemplate &lt;typename T&gt;\nclass A\n{\n  public:\n    template&lt;int32_t i&gt;\n    void f2();\n};\n\nvoid f(A&lt;int32_t&gt; * a&lt;:10:&gt;)    /* Noncompliant - usage of '&lt;:' instead of '[' and ':&gt;' instead of ']' */\n&lt;%                              /* Noncompliant - usage of '&lt;%' instead of '{' */\n  a&lt;:0:&gt;-&gt;f2&lt;20&gt;();             /* Noncompliant - usage of '&lt;:' and ':&gt;' */\n%&gt;                              /* Noncompliant - usage of '%&gt;' instead of '}' */\n</pre>\n<h2>Compliant Solution</h2>\n<pre>/* ... */\n\nvoid f(A&lt;int32_t&gt; * a[10])      /* Compliant */\n{                               /* Compliant */\n  a[0]-&gt;f2&lt;20&gt;();               /* Compliant */\n}                               /* Compliant */\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 2-5-1 - Digraphs should not be used. </li>\n</ul>","debt":"5min"},{"summary":"Functions should not be too complex","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The Cyclomatic Complexity of functions should not exceed a defined threshold. Complex code may perform poorly and can be difficult to test\nthoroughly.</p>","debt":"10min"},{"summary":"\"<time.h>\" should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Includes <code>time</code>, <code>strftime</code>. This library is associated with clock times. Various aspects are implementation dependent or\nunspecified, such as the formats of times. If any of the facilities of <code>time.h</code> are used, then the exact implementation for the compiler\nbeing used must be determined, and a deviation raised.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;time.h&gt;  /* Noncompliant */\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.12 - The time handling functions of library &lt;time.h&gt; shall not be used. </li>\n  <li> MISRA C:2012, 21.10 - The Standard Library time and date functions shall not be used </li>\n</ul>","debt":"4h"},{"summary":"\"static\" should not be used for the size of an array parameter","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Theoretically, the use of the <code>static</code> keyword on the size of an array parameter means you can assume that only arrays of at least that\nsize will be passed as arguments to the function. I.e. a function parameter of <code>int my_array[static 10]</code> means that <code>my_array</code>\nwill always be <em>at least</em> 10 elements long. If it is not, the behavior is undefined.</p>\n<p>In practice, the use of <code>static</code> on the size of an array parameter means the compiler might issue a warning if a noncompliant array is\npassed to the function - a warning that might or might not be ignored. Therefore, in practice the use of <code>static</code> on an array parameter's\nsize merely lends a false sense of security, and <code>static</code> should not be used in this context.</p>\n<p>Note that for some compiler/processor combinations, more efficient code can be generated when <code>static</code> is used, but these combinations\nare limited, and the benefit does not outweigh the cost.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint total (int size, int my_array[static 10]) {...}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint total (int size, int my_array[10]) {...}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 17.6 - The declaration of an array parameter shall not contain the static keyword between the [] </li>\n</ul>","debt":"10min"},{"summary":"Recursion should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Recursion is a powerful tool, but it can be tricky to get right. Getting it wrong can lead to stack overflow errors and cause system problems. Even\nwhen you do get it right, recursive code can be difficult to understand, perhaps leading to maintenance problems in the future. Therefore recursion\nshould be avoided in general and used only with due deliberation and caution when it is strictly necessary.</p>\n<p>This rule checks for direct recursion (when a function calls itself).</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint pow(int num, int exponent) {\n  if (exponent &gt; 1) {\n    num = num * pow(num, exponent-1);  // Noncompliant; direct recursion\n  }\n  return num;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint pow(int num, int exponent) {\n  int val = num;\n  while (exponent &gt; 0) {\n    val *= num;\n    --exponent;\n  }\n  return val;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.2 - Functions shall not call themselves, either directly or indirectly. </li>\n  <li> MISRA C++:2008, 7-5-4 - Functions should not call themselves, either directly or indirectly. </li>\n  <li> MISRA C:2012, 17.2 - Functions shall not call themselves, either directly or indirectly </li>\n</ul>","debt":"30min"},{"summary":"Track comments matching a regular expression","type":"Code Smell","defaultSeverity":"Major","description":"<p>This rule template can be used to create rules which will be triggered when a comment matches a given regular expression.</p>\n<p>For example, one can create a rule with the regular expression <code>.*REVIEW.*</code> to match all comment containing \"REVIEW\".</p>\n<p>Note that, in order to match REVIEW regardless of the case, the <code>(?i)</code> modifier should be prepended to the expression, as in\n<code>(?i).*REVIEW.*</code>.</p>"},{"summary":"Sections of code should not be \"commented out\"","type":"Code Smell","defaultSeverity":"Major","description":"<p>Programmers should not comment out code as it bloats programs and reduces readability.</p>\n<p>Unused code should be deleted and can be retrieved from source control history if required.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 2.4 - Sections of code should not be \"commented out\". </li>\n  <li> MISRA C++:2008, 2-7-2 - Sections of code shall not be \"commented out\" using C-style comments. </li>\n  <li> MISRA C++:2008, 2-7-3 - Sections of code should not be \"commented out\" using C++ comments. </li>\n  <li> MISRA C:2012, Dir. 4.4 - Sections of code should not be \"commented out\" </li>\n</ul>","debt":"5min"},{"summary":"Parameters in a function prototype should be named","type":"Code Smell","defaultSeverity":"Major","description":"<p>Naming the parameters in a function prototype helps identify how they'll be used by the function, thereby acting as a thin layer of documentation\nfor the function.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid divide (int, int);\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid divide (int numerator, int denominator);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.3 - Identifiers shall be given for all of the parameters in a function prototype declaration </li>\n  <li> MISRA C:2012, 8.2 - Function types shall be in prototype form with named parameters </li>\n</ul>","debt":"5min"},{"summary":"Functions without parameters should be declared with parameter type \"void\"","type":"Code Smell","defaultSeverity":"Critical","description":"<p>There is a real, functional difference between a function with an empty parameter list and one with an explicitly <code>void</code> parameter list:\nIt is possible to pass parameters to a function with an empty list; the compiler won't complain. That is not the case for a function with a\n<code>void</code> list. Thus, it is possible, and even easy to invoke empty-list functions incorrectly without knowing it, and thereby introduce the\nkind of subtle bug that can be very difficult to track down.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid myfunc ();  // Noncompliant\n\n//...\n\nvoid otherFunc() {\n  int a = 4;\n  //...\n  myfunc(a); // Compiler allows this\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid myfunc ( void );\n\n//...\n\nvoid otherFunc() {\n  int a = 4;\n  //...\n  myfunc(a); // Compiler error!\n}\n\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.5 - Functions with no parameters shall be declared with parameter type void </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/9YAzAg\">CERT, DCL20-C.</a> - Explicitly specify void when a function accepts no\n  arguments </li>\n</ul>","debt":"1min"},{"summary":"Track \"TODO\" and \"FIXME\" comments that do not contain a reference to a person","type":"Code Smell","defaultSeverity":"Minor","description":"<p>TODO and FIXME comments are typically intended to be short-lived; they are placeholders and reminders that programmers leave for themselves.\nUnfortunately, even with the best of intentions, those comments are not always acted on and removed in a timely manner. Thus, they can become\nmysterious, lingering cruft in a code base, reducing both readability and understand-ability.</p>\n<p>This rule flags all FIXME and TODO comments that do not have an attribution matching the specified regular expression immediately after the FIXME\nor TODO. Ideally, such comments will also contain information about what needs to be fixed or done, but this rule does not enforce that.</p>\n<h2>Noncompliant Code Example</h2>\n<p>Using the default regular expression: <code>[ ]*\\([ _a-zA-Z0-9@.]+\\)</code>:</p>\n<pre>\n// TODO\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// TODO(ganncamp) per the business partners, more checks needed\n</pre>"},{"summary":"\"switch case\" clauses should not have too many lines of code","type":"Code Smell","defaultSeverity":"Major","description":"<p>The <code>switch</code> statement should be used only to clearly define some new branches in the control flow. As soon as a <code>case</code>\nclause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of\n<code>case</code> clause should be extracted in a dedicated function.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold of 5:</p>\n<pre>\nswitch (myVariable) {\n  case 0: // 6 lines till next case\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    break;\n  case 1:\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch (myVariable) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n  // ...\n}\n// ...\nvoid doSomething(){\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n}\n</pre>","debt":"5min"},{"summary":"\"for\" loop stop conditions should be invariant","type":"Code Smell","defaultSeverity":"Major","description":"<p>A <code>for</code> loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and\nending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins. </p>\n<p>Stop conditions that are not invariant are slightly less efficient, as well as being difficult to understand and maintain, and likely lead to the\nintroduction of errors in the future.</p>\n<p>This rule tracks three types of non-invariant stop conditions:</p>\n<ul>\n  <li> When the loop counters are updated in the body of the <code>for</code> loop </li>\n  <li> When the stop condition depend upon a method call </li>\n  <li> When the stop condition depends on an object property, since such properties could change during the execution of the loop. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (int i = 0; i &lt; 10; i++) {\n  ...\n  i = i - 1; // Noncompliant\n  ...\n}\nfor (int i = 0; i &lt; getMaximumNumber(); i++) {\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfor (int i = 0; i &lt; 10; i++) {\n  ...\n}\nint stopCondition = getMaximumNumber();\nfor (int i = 0; i &lt; stopCondition; i++) {\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.6 - Numeric variables being used within a <em>for</em> loop for iteration counting shall not be modified in the body of the\n  loop. </li>\n  <li> MISRA C++:2008, 6-5-3 - The <em>loop-counter</em> shall not be modified within <em>condition</em> or <em>statement</em>. </li>\n</ul>","debt":"10min"},{"summary":"Switch statement conditions should not have essentially boolean type","type":"Code Smell","defaultSeverity":"Minor","description":"<p>When there is only a single condition to test, you have the option of using either a <code>switch</code> statement or an <code>if</code>-<code>else\nif</code>-<code>else</code> statement. For a larger set of potential values, a <code>switch</code> can be easier to read, but when the condition being\ntested is essentially boolean, then an <code>if</code>/<code>else</code> statement should be used instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n_Bool b = p &gt; 0;\nswitch (b) { // Noncompliant\n...\n}\nswitch (x == 0) { // Noncompliant\n...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n_Bool b = p &gt; 0;\nif (b) {\n...\n} else {\n...\n}\nif (x == 0) {\n...\n} else {\n...\n}\n</pre> \n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.4 - A switch expression shall not represent a value that is effectively Boolean </li>\n  <li> MISRA C++:2008, 6-4-7 - The condition of a switch statement shall not have bool type </li>\n  <li> MISRA C:2012, 16.7 - A switch-expression shall not have essentially Boolean type </li>\n</ul>","debt":"10min"},{"summary":"\"typedef\" names should be unique identifiers","type":"Code Smell","defaultSeverity":"Major","description":"<p>Reusing a <code>typedef</code> name either as another <code>typedef</code> name or for any other purpose may lead to developer confusion.</p>\n<p>The same <code>typedef</code> shall not be duplicated anywhere in the project, even if the declarations are identical.</p>\n<p>Note that where the type definition is made in a header file, and that header file is included in multiple source files, this rule is not\nviolated.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n{\n  typedef unsigned char uint8_t;\n}\n\n{\n  typedef unsigned char uint8_t; // Noncompliant, redefinition\n}\n\n{\n  unsigned char uint8_t; // Noncompliant, reuse of uint8_t for another purpose\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntypedef unsigned char uint8_t;\n{\n}\n\n{\n}\n\n{\n  unsigned char myChar;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 5.3 - A typedef name shall be a unique identifier. </li>\n  <li> MISRA C++:2008, 2-10-3 - A typedef name (including qualification, if any) shall be a unique identifier. </li>\n</ul>","debt":"10min"},{"summary":"Functions should not be defined with a variable number of arguments","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Passing arguments via an ellipsis bypasses the type checking performed by the compiler. Additionally, passing an argument with non-POD class type\nleads to undefined behavior. Note that the rule specifies \"defined\" (and not \"declared\") so as to permit the use of existing library functions.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid MyPrintf ( char_t * pFormat, ... )\t// Noncompliant\n{\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.1 - Functions shall not be defined with a variable number of arguments. </li>\n  <li> MISRA C++:2008, 8-4-1 - Functions shall not be defined using the ellipsis notation. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/i4CW\">CERT, DCL50-CPP.</a> - Do not define a C-style variadic function </li>\n</ul>","debt":"30min"},{"summary":"Null pointers should not be dereferenced","type":"Bug","defaultSeverity":"Major","description":"<p>A pointer to null (the 0 memory address) should never be dereferenced/accessed. Doing so will at best cause abrupt program termination, without the\nability to run any cleanup processes. At worst, it could expose debugging formation that would be useful to an attacker or it could allow an attacker\nto bypass security measures.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nchar *p1 = ... ;\nif (p1 == NULL &amp;&amp; *p1 == '\\t') { // Noncompliant, p1 will be dereferenced IFF it is null\n  // ...\n}\n\nchar *p2 = ... ;\nif (p2 != NULL) {\n    // ...\n}\n*p2 = '\\t'; // Noncompliant; potential null-dereference\n\nchar *p3, *p4;\np3 = NULL;\n// ...\np4 = p3;\n*p4;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nchar *p1 = ... ;\nif (p1 != NULL &amp;&amp; *p1 == '\\t') { // Compliant, *p1 cannot be evaluated when p1 is NULL\n  // ...\n}\n\nchar *p2 = ... ;\nif (p2 != NULL) {\n    // ...\n  *p2 = '\\t'; // Compliant\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/476.html\">MITRE, CWE-476</a> - NULL Pointer Dereference </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/PAw\">CERT, EXP34-C.</a> - Do not dereference null pointers </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ZwDOAQ\">CERT, EXP01-J.</a> - Do not use a null in a case where an object is required\n  </li>\n</ul>","debt":"10min"},{"summary":"Closed resources should not be accessed","type":"Bug","defaultSeverity":"Blocker","description":"<p>Using the value of a pointer to a <code>FILE</code> object after the associated file is closed is undefined behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fun() {\n  FILE * pFile;\n  pFile = fopen(fileName, \"w\");\n\n  if (condition) {\n    fclose(pFile);\n    // ...\n  }\n\n  fclose(pFile); // Noncompliant, the file has already been closed\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid fun() {\n  FILE * pFile;\n  pFile = fopen(fileName, \"w\");\n\n  if (condition) {\n    // ...\n  }\n\n  fclose(pFile);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KAGQBw\">CERT, FIO46-C.</a> - Do not access a closed file </li>\n</ul>","debt":"15min"},{"summary":"Label names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate effectively. This rule checks that labels match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With default provided regular expression <code>[A-Z][A-Z0-9-_]++</code>:</p>\n<pre>\nexit:  // Noncompliant\n  doCleanup();\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nEXIT:  // Compliant\n  doCleanup();\n</pre>","debt":"5min"},{"summary":"Dynamically allocated memory should be released","type":"Bug","defaultSeverity":"Blocker","description":"<p>Memory allocated dynamically with <code>calloc(...)</code>, <code>malloc(...)</code>, <code>realloc(...)</code> or <code>new</code> should be\nreleased when it's not needed anymore. Failure to do so will result in a memory leak that could bring the box to its knees.</p>\n<p>This rule raises an issue when memory is allocated and not freed in the same function. Allocated memory is ignored if a pointer to it is\n<code>return</code>ed to the caller or stored in a structure that's external to the function.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint fun() {\n  char* name = (char *) malloc (size);\n  if (!name) {\n    return 1;\n  }\n  // ...\n  return 0; // Noncompliant, memory pointed by \"name\" has not been released\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint fun() {\n  char* name = (char *) malloc (size);\n  if (!name) {\n    return 1;\n  }\n  // ...\n  free(name);\n  return 0;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://cwe.mitre.org/data/definitions/401.html\">MITRE, CWE-401</a> - Improper Release of Memory Before Removing Last Reference\n  ('Memory Leak') </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/twE\">MEM00-C.</a> - Allocate and free memory in the same module, at the same level of\n  abstraction </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIEyAQ\">CERT, MEM11-CPP.</a> - Allocate and free memory in the same module, at the same\n  level of abstraction </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/vQE\">CERT, MEM31-C.</a> - Free dynamically allocated memory when no longer needed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/rgCuAQ\">CERT, MEM12-CPP.</a> - Do not assume infinite heap space </li>\n</ul>","debt":"20min"},{"summary":"\"sizeof(sizeof(...))\" should not be used","type":"Bug","defaultSeverity":"Major","description":"<p>A call to <code>sizeof(sizeof(...))</code> is equivalent to <code>sizeof(size_t)</code>, and indicates a misuse or misunderstanding of the\n<code>sizeof</code> construct.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;string.h&gt;\n\nint main(int argc, char* argv[])\n{\n  char buffer[42];\n  char buffer2[sizeof(sizeof(buffer))]; /* Noncompliant - a single sizeof() was intended */\n\n  memcpy(buffer, \"Hello, world!\", strlen(\"Hello, world!\")+1);\n  memcpy(buffer2, buffer, sizeof(buffer)); /* Buffer overflow */\n\n  return 0;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include &lt;string.h&gt;\n\nint main(int argc, char* argv[])\n{\n  char buffer[42];\n  char buffer2[sizeof(buffer)]; /* Compliant */\n\n  memcpy(buffer, \"Hello, world!\", strlen(\"Hello, world!\")+1);\n  memcpy(buffer2, buffer, sizeof(buffer));\n\n  return 0;\n}\n</pre>","debt":"20min"},{"summary":"Function names should be used either as a call with a parameter list or with the \"&\" operator","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Using a \"bald\" function name is likely a bug. Rather than testing the return value of a function with a <code>void</code> parameter list, it\nimplicitly retrieves the address of that function in memory. If that's truly what's intended, then it should be made explicit with the use of the\n<code>&amp;</code> (address-of) operator. If it's not, then a parameter list (even an empty one) should be added after the function name.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint func(void) {\n  // ...\n}\n\nvoid f2(int a, int b) {\n  // ...\n  if (func) {  // Noncompliant - tests that the memory address of func() is non-null\n    //...\n  }\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid f2(int a, int b) {\n  // ...\n  if (func()) {  // tests that the return value of func() &gt; 0\n    //...\n  }\n  // ...\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Callback functions are a common occurrence and are usually not passed with a preceding &amp;. There is however little ambiguity so this rule\nignores function identifiers when used as a parameter of a function call.</p>\n<pre>\nvoid foo() {\n  // ...\n}\n\nregisterEvent(AnEvent, foo);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.9 - A function identifier shall only be used with either a preceding &amp;, or with a parenthesized parameter list, which may\n  be empty. </li>\n  <li> MISRA C++:2008, 8-4-4 - A function identifier shall only be used to call the function or it shall be preceded by &amp;. </li>\n</ul>","debt":"10min"},{"summary":"Bit fields should be declared with appropriate types","type":"Code Smell","defaultSeverity":"Major","description":"<p>The use of any type other than <code>signed short</code>, <code>unsigned short</code>, <code>signed char</code>, <code>unsigned char</code>,\n<code>signed int</code>, <code>unsigned int</code> or <code>_Bool</code> for a bit field is implementation-defined, and therefore not portable.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint b:3; // Noncompliant - may have the range of values 0..7 or -4..3\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nunsigned int b:3;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 6.4 - Bit fields shall only be defined to be of type <em>unsigned int</em> or <em>signed int</em>. </li>\n  <li> MISRA C++:2008, 9-6-2 - Bit-fields shall be either <em>bool</em> type or an explicitly <em>unsigned</em> or <em>signed</em> integral type.\n  </li>\n  <li> MISRA C:2012, 6.1 - Bit-fields shall only be declared with an appropriate type </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/RAE\">CERT, INT12-C.</a> - Do not make assumptions about the type of a plain int\n  bit-field when used in an expression </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/uYAyAQ\">CERT, INT12-CPP.</a> - Do not make assumptions about the type of a plain int\n  bit-field when used in an expression </li>\n</ul>","debt":"2min"},{"summary":"Function exit paths should have appropriate return values","type":"Bug","defaultSeverity":"Critical","description":"<p>Every call to a function with a non-void return type is expected to return some value. Including a return path in a non-void function that does not\nexplicitly return a value results in undefined behavior. </p>\n<p>Conversely, every call to a function with a void return type is expected to not return any value. Returning a value from a void function probably\nindicates a programming error.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint my_func (int a)\n{\n  if (a &gt; 100)\n  {\n    return; // Noncompliant\n  }\n\n  if (a &gt; 80)\n  {\n    throw new Exception(); // Compliant\n  }\n\n  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint my_func (int a)\n{\n  if (a &gt; 100)\n  {\n    return 12;\n  }\n\n  if (a &gt; 80)\n  {\n    throw new Exception();\n  }\n\n  return a;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.8 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression </li>\n  <li> MISRA C++:2008, 8-4-3 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression\n  </li>\n  <li> MISRA C:2012, 17.4 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/394.html\">MITRE, CWE-394</a> - Unexpected Status Code or Return Value </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/goCGAg\">CERT, MSC37-C.</a> - Ensure that control never reaches the end of a non-void\n  function </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ZoCKC\">CERT, MSC52-CPP.</a> - Value-returning functions must return a value from all\n  exit paths </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/dICKC\">CERT, MSC53-CPP.</a> - Do not return from a function declared [[noreturn]] </li>\n</ul>","debt":"5min"},{"summary":"Functions should be declared explicitly","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The use of prototypes enables the compiler to check the integrity of function definitions and calls. Without prototypes the compiler is not obliged\nto pick up certain errors in function calls (e.g. different number of arguments from the function body, mismatch in types of arguments between call\nand definition). Function interfaces have been shown to be a cause of considerable problems, and therefore this rule is considered very important.</p>\n<p>The recommended method of implementing function prototypes for external functions is to declare the function (i.e. give the function prototype) in\na header file, and then include the header file in all those code files that need the prototype (see MISRA C 2004, Rule 8.8).</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid example() {\n  fun(); // Noncompliant\n}\n\nvoid fun() {\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid fun();\n\nvoid example() {\n  fun();\n}\n\nvoid fun() {\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 8.1 - Functions shall have prototype declarations and the prototype shall be visible at both the function definition and call\n  </li>\n  <li> MISRA C:2012, 17.3 - A function shall not be declared implicitly </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/LoAg\">CERT, DCL07-C.</a> - Include the appropriate type information in function\n  declarators </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/tgDI\">CERT, DCL31-C.</a> - Declare identifiers before using them </li>\n</ul>\n<h3>See Also</h3>\n<ul>\n  <li> MISRA C:2004, 8.8 - An external object or function shall be declared in one and only one file </li>\n</ul>","debt":"10min"},{"summary":"Functions/methods should not have too many lines","type":"Code Smell","defaultSeverity":"Major","description":"<p>A function that grows too large tends to aggregate too many responsibilities.</p>\n<p>Such functions inevitably become harder to understand and therefore harder to maintain. </p>\n<p>Above a specific threshold, it is strongly advised to refactor into smaller functions which focus on well-defined tasks.</p>\n<p>Those smaller functions will not only be easier to understand, but also probably easier to test.</p>","debt":"20min"},{"summary":"The number of arguments passed to a function should match the number of parameters","type":"Bug","defaultSeverity":"Major","description":"<p>This problem is completely avoided by the use of function prototypes. See MISRA C:2004 Rule 8.1. This rule is retained since compilers may not flag\nthis constraint error.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.6 - The number of arguments passed to a function shall match the number of parameters. </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/628.html\">MITRE, CWE-628</a> - Function Call with Incorrectly Specified Arguments </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/LoAg\">CERT, DCL07-C.</a> - Include the appropriate type information in function\n  declarators </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/VQBc\">CERT, EXP37-C.</a> - Call functions with the correct number and type of arguments\n  </li>\n</ul>","debt":"10min"},{"summary":"Comments should not be located at the end of lines of code","type":"Code Smell","defaultSeverity":"Minor","description":"<p>This rule verifies that single-line comments are not located at the ends of lines of code. The main idea behind this rule is that in order to be\nreally readable, trailing comments would have to be properly written and formatted (correct alignment, no interference with the visual structure of\nthe code, not too long to be visible) but most often, automatic code formatters would not handle this correctly: the code would end up less readable.\nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\na = b + c;   // This is a trailing comment that could be very very long\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// This very long comment is better placed before the line of code\na = b + c;\n</pre>","debt":"1min"},{"summary":"Appropriate char types should be used for character and integer values","type":"Code Smell","defaultSeverity":"Minor","description":"<p>There are three distinct <code>char</code> types, (plain) <code>char</code>, <code>signed char</code> and <code>unsigned char</code>. <code>signed\nchar</code> and <code>unsigned char</code> should only be used for numeric data, and plain <code>char</code> should only be used for character data.\nSince it is implementation-defined, the signedness of the plain <code>char</code> type should not be assumed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nsigned char a = 'a'; // Noncompliant, explicitly signed\nunsigned char b = '\\r'; // Noncompliant, explicitly unsigned\nchar c = 10; // Noncompliant\n\nunsigned char d = c; // Noncompliant, d is explicitly signed while c is not\nchar e = a; // Noncompliant, a is explicitly signed while e is not\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nchar a = 'a'; // Compliant, explicitly signed\nchar b = '\\r'; // Compliant, explicitly unsigned\nunsigned char c = 10; // Compliant, or\nsigned char c = 10; // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 6.1 - The plain char type shall be used only for the storage and use of character values </li>\n  <li> MISRA C:2004, 6.2 - signed and unsigned char type shall be used only for the storage and use of number values </li>\n  <li> MISRA C++:2008, 5-0-11 - The plain char type shall only be used for the storage and use of character values </li>\n  <li> MISRA C++:2008, 5-0-12 - signed char and unsigned char type shall only be used for the storage and use of numeric values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/-As\">CERT, INT07-C.</a> - Use only explicitly signed or unsigned char type for numeric\n  values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/rYAyAQ\">CERT, INT07-CPP.</a> - Use only explicitly signed or unsigned char type for\n  numeric values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/5AD7\">CERT, STR00-C.</a> - Represent characters using an appropriate type </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/IoEyAQ\">CERT, STR04-CPP.</a> - Use plain char for characters in the basic character set\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/JABi\">CERT, STR04-C.</a> - Use plain char for characters in the basic character set\n  </li>\n</ul>","debt":"10min"},{"summary":"typedefs that indicate size and signedness should be used in place of the basic types","type":"Code Smell","defaultSeverity":"Minor","description":"<p>The basic numeric types <code>char</code>, <code>int</code>, <code>short</code>, <code>long</code>, <code>float</code>, <code>double</code>, and\n<code>long double</code> should not be used. Instead, specific-length typedefs should be. This rule helps to clarify the size of the storage, but does\nnot guarantee portability because of the asymmetric behavior of integral promotion. </p>\n<p>Note that it is still important to understand the integer size of the implementation, and developers should be aware of the actual implementation\nof the typedefs under these definitions.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint function(unsigned short a) // Noncompliant\n{\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include &lt;stdint.h&gt;\nint32_t function(uint16_t a) // Compliant\n{\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 6.3 - typedefs that indicate size and signedness should be used in place of the basic types </li>\n  <li> MISRA C++:2008, 3-9-2 - typedefs that indicate size and signedness should be used in place of the basic numerical types </li>\n</ul>\n<h3>See Also</h3>\n<ul>\n  <li> MISRA C++ 2008 Section 6.5.0 on integral promotion </li>\n</ul>","debt":"10min"},{"summary":"The ternary operator should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>While the ternary operator is pleasingly compact, its use can make code more difficult to read. It should therefore be avoided in favor of the more\nverbose <code>if</code>/<code>else</code> structure.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nprintf(\"%s\", (i&gt;10?\"yes\":\"no\"));\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (i &gt; 10) {\n  printf(\"yes\");\n} else {\n  printf(\"no\");\n}\n</pre>","debt":"5min"},{"summary":"Constants should come first in equality tests","type":"Code Smell","defaultSeverity":"Minor","description":"<p>The result of the comparison is the same, regardless of whether the constant is on the left or right-hand side. But following this convention will\nhelp pinpoint the occasional error where <code>=</code> (assignment) is substituted for <code>==</code> (comparison). </p>\n<p>If the constant is on the right-hand side of the expression in such cases, the code will still compile and run - just not as expected. If the\nconstant is on the left-hand side, the error will be caught at the first attempt to compile.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ( var == constant )\nif ( pointer == NULL )\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif ( constant == var )\nif ( NULL == pointer )\n</pre>","debt":"10min"},{"summary":"Identifiers should not be longer than 31 characters","type":"Code Smell","defaultSeverity":"Major","description":"<p>In addition to being difficult to use, too-long variable names can limit code portability. The ISO standard requires that variable, type, function\nand label names be no more than 31 characters long. </p>\n<p>Note that 31 characters is an upper bound, rather than a length recommendation. Shorter names are better, as long as they're still\ncommunicative.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint this_is_a_very_long_identifier_that_definitely_should_be_renamed = 0;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint reasonable_identifier = 0;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 5.1 - Identifiers (internal and external) shall not rely on the significance of more than 31 character. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/QAU\">CERT, DCL23-C.</a> - Guarantee that mutually visible identifiers are unique </li>\n</ul>","debt":"10min"},{"summary":"Track parsing failures","type":"Code Smell","defaultSeverity":"Major","description":"<p>When the parser fails, it is possible to record the failure as an issue on the file. This way, not only is it possible to track the number of files\nthat do not parse but also to easily find out why they do not parse.</p>","debt":"0min"},{"summary":"Lines should not be too long","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.</p>","debt":"1min"},{"summary":"GNU extensions should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Proprietary compiler extensions can be handy, but they commit you to always using that compiler. This rule raises an issue when the following GNU\nextensions are used:</p>\n<ul>\n  <li> A array initializer without <code>=</code>, which has been obsolete since GCC 2.5 </li>\n  <li> A structure member initializer with a colon, which has been obsolete since GCC 2.5. </li>\n  <li> Case ranges </li>\n  <li> Ternary operator with omitted second operand </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct S {\n  int f;\n};\n\nstruct S s[] = {\n  [0] { // Noncompliant\n    f : 0 // Noncompliant\n  }\n};\n\nint fun(int p) {\n  switch (p) {\n    case 0 ... 1: // Noncompliant\n      do_the_thing();\n      break;\n    case 2:\n      //...\n  }\n\n  return p ?: 0; // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct S {\n  int f;\n};\n\nstruct S s[] = {\n  [0] = {\n    .f = 0\n  }\n};\n\nint fun(int p) {\n  switch (p) {\n    case 0:\n    case 1:\n      do_the_thing();\n      break;\n    case 2:\n      //...\n  }\n\n  return p ? p: 0;\n}\n</pre>","debt":"5min"},{"summary":"Variables should not be self-assigned","type":"Bug","defaultSeverity":"Major","description":"<p>There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid setValue(int value) {\n  value = value;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid setValue(int value) {\n  this-&gt;value = value;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"3min"},{"summary":"Non-empty statements should change control flow or have at least one side-effect","type":"Bug","defaultSeverity":"Major","description":"<p>Any statement (other than a null statement, which means a statement containing only a semicolon <code>;</code>) which has no side effect and does\nnot result in a change of control flow will normally indicate a programming error, and therefore should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint func(int a, int b) {\n  int result = 0;\n  a + b; // Noncompliant, no side effect.\n  return result;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint func(int a, int b) {\n  int result = a + b; // Compliant\n  return result;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/482\">MITRE, CWE-482</a> - Comparing instead of Assigning </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n  <li> MISRA C:2004, 14.2 - All non-null statements shall either have at least one side-effect however executed, or cause control flow to change.\n  </li>\n</ul>","debt":"10min"},{"summary":"Functions should not have too many parameters","type":"Code Smell","defaultSeverity":"Major","description":"<p>A long parameter list can indicate that a new structure should be created to wrap the numerous parameters or that the function is doing too many\nthings.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With a maximum number of 4 parameters:</p>\n<pre>\nvoid doSomething(int param1, int param2, int param3, int param4, int param5) {\n  ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doSomething(int param1, int param2, int param3, int param4) {\n  ...\n}\n</pre>","debt":"20min"},{"summary":"Magic numbers should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>A magic number is a number that comes out of nowhere, and is directly used in a statement. Magic numbers are often used, for instance to limit the\nnumber of iterations of a loops, to test the value of a property, etc.</p>\n<p>Using magic numbers may seem obvious and straightforward when you're writing a piece of code, but they are much less obvious and straightforward at\ndebugging time.</p>\n<p>That is why magic numbers must be demystified by first being assigned to clearly named variables before being used.</p>\n<p>-1, 0 and 1 are not considered magic numbers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid doSomething() {\n  for(int i = 0; i &lt; 42; i++) {               // Noncompliant - 42 is a magic number\n    // ...\n  }\n\n  if (var == 42) {                            // Noncompliant - magic number\n    // ...\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#define STATUS_OK 42\n\nvoid doSomething() {\n  int maxIterations = 42;                     // Compliant - in a declaration\n  for(int i = 0; i &lt; maxIterations ; i++){    // Compliant\n    // ...\n  }\n\n  if (var == 0) {                             // Compliant - 0 is excluded\n    // ...\n  }\n\n  if (var == STATUS_OK) {                     // Compliant - number comes from a macro\n    // ...\n  }\n}\n</pre>","debt":"5min"},{"summary":"Values of different \"enum\" types should not be compared","type":"Bug","defaultSeverity":"Minor","description":"<p>Just as comparing apples and oranges is seen as a classic folly, comparing values from different enumerations against each other is nonsensical.\nTrue, at root <code>enum</code>s are simply named numbers, and it's certainly valid to compare numbers. But an added layer of meaning is created by an\n<code>enum</code>, one that goes beyond simple numerical values.</p>\n<p>Ignoring that extra layer of meaning is at best a trap for maintainers, who are likely to be hopelessly confused by the code. At worst, it is a\nbug, which will lead to unexpected results.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nenum apple {BRAEBURN, FUJI, GRANNY_SMITH, RED_DELICIOUS};\nenum orange {BLOOD, NAVEL, BITTER, BERGAMOT, MANDARIN};\n\nbool fun(apple v1, orange v2) {\n  return v1 != v2;  // Noncompliant\n}\n</pre>","debt":"15min"},{"summary":"Declarations should not be empty","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Empty declarations are cruft; they (may) compile, but they violate the language standards, don't contribute anything of value, and clutter up the\nprogram. Like cobwebs, they should be swept away.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint;  // Noncompliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> ISO/IEC 9899:2011, 6.7p2 </li>\n  <li> ISO/IEC 14882:2011, 7p3. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"2min"},{"summary":"\"switch\" statements should have at least 3 \"case\" clauses","type":"Code Smell","defaultSeverity":"Minor","description":"<p><code>switch</code> statements are useful when there are many different cases depending on the value of the same expression.</p>\n<p>For just one or two cases however, the code will be more readable with <code>if</code> statements.</p>\n<p>Moreover, <code>if</code> statements are obviously more suitable when the condition of the <code>switch</code> is boolean.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (variable == 0) {\n  doSomething();\n} else {\n  doSomethingElse();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.5 - Every switch statement shall have at least one case clause. </li>\n  <li> MISRA C++:2008, 6-4-8 - Every switch statement shall have at least one case-clause. </li>\n  <li> MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses </li>\n</ul>","debt":"5min"},{"summary":"The right-hand operands of && and || should not contain side effects","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>There are some situations in C++ where certain parts of expressions may not be evaluated. If these sub-expressions contain side effects then those\nside effects may or may not occur, depending on the values of other sub expressions. The operators which can lead to this problem are\n<code>&amp;&amp;</code> and <code>||</code>, where the evaluation of the right-hand operand is conditional on the value of the left-hand operand. The\nconditional evaluation of the right-hand operand of one of the logical operators can easily cause problems if the developer relies on a side effect\noccurring.</p>\n<p>Operations that cause side effects are: </p>\n<ul>\n  <li> accessing a volatile object </li>\n  <li> modifying an object </li>\n  <li> modifying a file </li>\n  <li> calling a function that performs any operations that cause changes in the state of the execution environment of the calling function. </li>\n</ul>\n<p>This rule raises an issue when there is assignment or the use of the increment/decrement operators in right-hand operands.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ( ishigh &amp;&amp; ( x == i++ ) ) // Noncompliant\n...\nif ( ishigh &amp;&amp; ( x ==  getX() ) ) // Only acceptable if getX() is known to have no side effects\n</pre>\n<p>The operations that cause side effects are accessing a volatile object, modifying an object, modifying a file, or calling a function</p>\n<p>that does any of those operations, which cause changes in the state of the execution environment of the calling function.</p>\n<p>For the time being, this rule only check that there is no assignment or no use of increment/decrement operators made in right hand operands.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.4 - The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>\n  <li> MISRA C++:2008, 5-14-1 - The right hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>\n  <li> MISRA C:2012, 13.5 - The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/loAD\">CERT, EXP02-C.</a> - Be aware of the short-circuit behavior of the logical AND\n  and OR operators </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/XIAyAQ\">CERT, EXP02-CPP.</a> - Be aware of the short-circuit behavior of the logical\n  AND and OR operators </li>\n</ul>","debt":"15min"},{"summary":"Control structures should use curly braces","type":"Code Smell","defaultSeverity":"Critical","description":"<p>While not technically incorrect, the omission of curly braces can be misleading, and may lead to the introduction of errors during maintenance.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition)  // Noncompliant\n  executeSomething();\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition) {\n  executeSomething();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.8 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement </li>\n  <li> MISRA C:2004, 14.9 - An if (expression) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement </li>\n  <li> MISRA C++:2008, 6-3-1 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement </li>\n  <li> MISRA C++:2008, 6-4-1 - An if (condition) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement </li>\n  <li> MISRA C:2012, 15.6 - The body of an iteration-statement or a selection-statement shall be a compound-statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/1QGMAg\">CERT, EXP19-C.</a> - Use braces for the body of an if, for, or while statement\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/3wHEAw\">CERT, EXP52-J.</a> - Use braces for the body of an if, for, or while statement\n  </li>\n</ul>","debt":"2min"},{"summary":"\"#undef\" should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p><code>#undef</code> should not normally be needed. Its use can lead to confusion with respect to the existence or meaning of a macro when it is\nused in the code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#ifndef MY_HDR\n#define MY_HDR\n#endif\n...\n#undef MY_HDR    /* Noncompliant */\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.6 - #undef shall not be used. </li>\n  <li> MISRA C++:2008, 16-0-3 - #undef shall not be used. </li>\n  <li> MISRA C:2012, 20.5 - #undef should not be used </li>\n</ul>","debt":"2h"},{"summary":"Array indices should be placed between brackets","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>While C syntax considers array subscripts (<code>[]</code>) as symmetrical, meaning that <code>a[i]</code> and <code>i[a]</code> are equivalent,\nthe convention is to put the index in the brackets rather than the array name. Inverting the index and array name serves no purpose, and is very\nconfusing.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n10[P1] = 0; // Noncompliant\ndostuff(i[arr]); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nP1[10] = 0;\ndostuff(arr[i]);\n</pre>","debt":"5min"},{"summary":"String literals should not be concatenated implicitly","type":"Code Smell","defaultSeverity":"Minor","description":"<p>While in C, and derived languages, it is legal to concatenate two literals by putting them next to each other, this is only justified in a few\ncases. For instance if one is a macro or if the layout makes it clearer.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n  const char * v1 = \"a\"\"b\";      // Noncompliant; same as \"ab\"\n  const char * v2 = \"a\\n\" \"b\\n\"; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n  const char * v1 = \"ab\"\n  const char * v2 = \"a\\n\"\n                    \"b\\n\";\n</pre>\n<h2>Exceptions</h2>\n<pre>\n  const char * v3 = \"a\" /* comment */ \"b\";\n\n  #define _s \"b\"\n  const char * v4 = \"a\" _s; // concatenation with macro ignored\n</pre>","debt":"5min"},{"summary":"\"=+\" should not be used instead of \"+=\"","type":"Bug","defaultSeverity":"Major","description":"<p>The use of operators pairs (<code>=+</code>) where the reversed, single operator was meant (<code>+=</code>) will compile and run, but not produce\nthe expected results.</p>\n<p>This rule raises an issue when <code>=+</code>, <code>=-</code>, <code>=!</code>, <code>=&amp;</code>, <code>=*</code>, <code>+=+</code>, and\n<code>-=-</code> are used without any space between the two operators and when there is at least one whitespace after.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint target = -5;\nint num = 3;\n\ntarget =- num;  // Noncompliant; target = -3. Is that really what's meant?\ntarget =+ num; // Noncompliant; target = 3\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint target = -5;\nint num = 3;\n\ntarget = -num;  // Compliant; intent to assign inverse value of num is clear\ntarget += num;\n</pre>","debt":"2min"},{"summary":"\"nonnull\" pointers should not be set to null","type":"Bug","defaultSeverity":"Minor","description":"<p>Functions return values and parameters values marked <code>nonnull</code> are assumed to have non-null values and are not typically null-checked\nbefore use. Therefore setting one of these values to <code>null</code>, could cause null pointer dereferences at runtime.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n__attribute__((returns_nonnull))\nint* nonnull(__attribute__((nonnull)) int* parameter) {\n  parameter = 0; // Noncompliant - \"parameter\" is marked \"nonnull\" but is set to null.\n  nonnull(0); // Noncompliant - Parameter \"parameter\" to this call is marked \"nonnull\" but null is passed.\n  return 0; // Noncompliant - This function's return value is marked \"nonnull\" but null is returned.\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/476.html\">MITRE CWE-476</a> - NULL Pointer Dereference </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ZwDOAQ\">CERT, EXP01-J.</a> - Do not use a null in a case where an object is required\n  </li>\n</ul>","debt":"15min"},{"summary":"Switch labels should not be nested inside non-switch blocks","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>A switch-label can be placed anywhere within the statements that form the body of a switch statement, potentially leading to unstructured code. To\nprevent this from happening, the scope of a case-label or default-label shall be the statement forming the body of a switch statement. All\ncase-clauses and the default-clause shall be at the same scope.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (x) {\n  case 1: // Compliant\n    if (foo) {\n      case 2: // Noncompliant\n        break;\n      default: // Noncompliant\n        break;\n    }\n    break;\n  default: // Compliant\n    break;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.1 - A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.\n  </li>\n  <li> MISRA C++:2008, 6-4-4 - A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.\n  </li>\n  <li> MISRA C:2012, 16.2 - A switch label shall only be used when the most closely-enclsoing compound statement is the body of a switch statement\n  </li>\n</ul>","debt":"20min"},{"summary":"Files should contain an empty newline at the end","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Some tools work better when files end with an empty line.</p>\n<p>This rule simply generates an issue if it is missing.</p>\n<p>For example, a Git diff looks like this if the empty line is missing at the end of the file:</p>\n<pre>\n+class Test {\n+}\n\\ No newline at end of file\n</pre>","debt":"1min"},{"summary":"\"enum\" members other than the first one should not be explicitly initialized unless all members are explicitly initialized","type":"Code Smell","defaultSeverity":"Major","description":"<p>If an enumerator list is given with no explicit initialization of members, then C/C++ allocates a sequence of integers starting at zero for the\nfirst element and increasing by one for each subsequent element.</p>\n<p>An explicit initialization of the first element, as permitted by this rule, forces the allocation of integers to start at the given value. When\nadopting this approach it is essential to ensure that the initialization value used is small enough that no subsequent value in the list will exceed\nthe <code>int</code> storage used by enumeration constants.</p>\n<p>Explicit initialization of all items in the list, which is also permissible, prevents the mixing of automatic and manual allocation, which is error\nprone.</p>\n<p>However, it is then the responsibility of the developer to ensure that all values are in the required range, and that values are not\nunintentionally duplicated.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nenum color { red = 3, blue, green, yellow = 5 }; // Noncompliant; both green and yellow = 5\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nenum color { red = 3, blue = 4, green = 5, yellow = 5 }; // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 9.3 - In an enumerator list, the \"=\" construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. </li>\n  <li> MISRA C++:2008, 8-5-3 - In an enumerator list, the = construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. </li>\n</ul>","debt":"20min"},{"summary":"\"for\" loop counters should not have essentially floating type","type":"Bug","defaultSeverity":"Minor","description":"<p>When using a floating-point <code>for</code> loop counter, an accumulation of rounding errors may result in a mismatch between the expected and\nactual number of iterations.</p>\n<p>Even if floating-point loop counters appears to behave correctly on one implementation, it may give a different number of iterations on another\nimplementation.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (float counter = 0.0f; counter &lt; 1.0f; counter += 0.001f) {\n  ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfor (int counter = 0; counter &lt; 1000; ++counter) {\n  ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.4 - The controlling expression of a for statement shall not contain any objects of floating type. </li>\n  <li> MISRA C++:2008, 6-5-1 - A <em>for</em> loop shall contain a single <em>loop-counter</em> which shall not have floating type. </li>\n  <li> MISRA C:2012, 14.1 - A <em>loop counter</em> shall not have essentially <em>floating type</em>. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/uYIyAQ\">CERT, NUM09-J.</a> - Do not use floating-point variables as loop counters </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/AoG_/\">CERT, FLP30-C.</a> - Do not use floating-point variables as loop counters </li>\n</ul>","debt":"5min"},{"summary":"Field names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that field\nnames match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>^[a-z][a-zA-Z0-9]*$</code>:</p>\n<pre>\nclass MyClass {\n  int my_field;\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass {\n  int myField;\n};\n</pre>","debt":"2min"},{"summary":"Local variable and function parameter names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared naming conventions allow teams to collaborate effectively. This rule raises an issue when a local variable or function parameter name does\nnot match the provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>^[a-z][a-zA-Z0-9]*$</code>:</p>\n<pre>\nvoid doSomething(int my_param) {\n  int LOCAL;\n  ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doSomething(int myParam) {\n  int local;\n  ...\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Loop counters and <code>const</code> variables are ignored by this rule.</p>","debt":"2min"},{"summary":"Code annotated as deprecated should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Code annotated as deprecated should not be used since it will be removed sooner or later.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// C++14 attribute\n[[deprecated]]\nvoid fun();\n\n// GNU attribute\n__attribute__((deprecated))\nvoid fun();\n\n// Microsoft attribute\n__declspec(deprecated)\nvoid fun();\n\nvoid example() {\n  fun(); // Noncompliant\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/477.html\">MITRE, CWE-477</a> - Use of Obsolete Functions </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KgAVAg\">CERT, MET02-J.</a> - Do not use deprecated or obsolete classes or methods </li>\n</ul>","debt":"15min"},{"summary":"Jump statements should not be used unconditionally","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having an unconditional <code>break</code>, <code>return</code>, <code>(@)throw</code> or <code>goto</code> in a loop renders it useless; the loop\nwill only execute once and the loop structure itself is simply wasted keystrokes.</p>\n<p>Having an unconditional <code>continue</code> in a loop can render the loop meaningless, or is itself wasted keystrokes, depending on where in the\nloop it occurs.</p>\n<p>Having an unconditional <code>return</code> anywhere other than at the end of a function or method simply renders all the rest of the code in the\nmethod useless.</p>\n<p>For these reasons, unconditional jump statements should never be used except for the final <code>return</code> in a function or method.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint i;\nfor (i = 0; i &lt; 10; ++i)\n{\n    printf(\"i is %d\", i);\n    break;  // loop only executes once\n}\n\nfor (i = 0; i &lt; 10; ++i)\n{\n    continue;\n    printf(\"i is %d\", i);  // this is never executed\n}\n\nfor (i = 0; i &lt; 10; ++i)\n{\n    printf(\"i is %d\", i);\n    continue;  // this is meaningless; the loop would continue anyway\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint i;\nfor (i = 0; i &lt; 10; ++i)\n{\n    printf(\"i is %d\", i);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.1 - There shall be no unreachable code. </li>\n  <li> MISRA C++:2008, 0-1-1 - A <em>project</em> shall not contain <em>unreachable code</em>. </li>\n  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code. </li>\n  <li> MISRA C:2012, 2.2 - There shall be no dead code </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"5min"},{"summary":"Two branches in a conditional structure should not have exactly the same implementation","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having two <code>cases</code> in a <code>switch</code> statement or two branches in an <code>if</code> chain with the same implementation is at\nbest duplicate code, and at worst a coding error. If the same logic is truly needed for both instances, then in an <code>if</code> chain they should\nbe combined, or for a <code>switch</code>, one should fall through to the other. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (i) {\n  case 1:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  case 3:  // Noncompliant; duplicates case 1's implementation\n    doFirstThing();\n    doSomething();\n    break;\n  default:\n    doTheRest();\n}\n\nif (a &gt;= 0 &amp;&amp; a &lt; 10) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20) {\n  doTheOtherThing();\n}\nelse if (a &gt;= 20 &amp;&amp; a &lt; 50) {\n  doFirstThing();\n  doTheThing();  // Noncompliant; duplicates first condition\n}\nelse {\n  doTheRest();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch (i) {\n  case 1:\n  case 3:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  default:\n    doTheRest();\n}\n\nif ((a &gt;= 0 &amp;&amp; a &lt; 10) || (a &gt;= 20 &amp;&amp; a &lt; 50)) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20) {\n  doTheOtherThing();\n}\nelse {\n  doTheRest();\n}\n</pre>\n<p>or </p>\n<pre>\nswitch (i) {\n  case 1:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  case 3:\n    doFirstThing();\n    doThirdThing();\n    break;\n  default:\n    doTheRest();\n}\n\nif (a &gt;= 0 &amp;&amp; a &lt; 10) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20) {\n  doTheOtherThing();\n}\nelse if (a &gt;= 20 &amp;&amp; a &lt; 50) {\n  doFirstThing();\n  doTheThirdThing();\n}\nelse {\n  doTheRest();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Blocks in an <code>if</code> chain that contain a single line of code are ignored, as are blocks in a <code>switch</code> statement that contain a\nsingle line of code with or without a following <code>break</code>.</p>","debt":"10min"},{"summary":"\"scanf()\" and \"fscanf()\" format strings should specify a field width for the \"%s\" string placeholder","type":"Vulnerability","defaultSeverity":"Critical","description":"<p>The <code>%s</code> placeholder is used to read a word into a string.</p>\n<p>By default, there is no restriction on the length of that word, and the developer is required to pass a sufficiently large buffer for storing\nit.</p>\n<p>No matter how large the buffer is, there will always be a longer word.</p>\n<p>Therefore, programs relying on <code>%s</code> are vulnerable to buffer overflows.</p>\n<p>A field width specifier can be used together with the <code>%s</code> placeholder to limit the number of bytes which will by written to the\nbuffer.</p>\n<p>Note that an additional byte is required to store the null terminator.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nchar buffer[10];\nscanf(\"%s\", buffer);      // Noncompliant - will overflow when a word longer than 9 characters is entered\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nchar buffer[10];\nscanf(\"%9s\", buffer);     // Compliant - will not overflow\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/120\">MITRE, CWE-120</a> - Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n  </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/676\">MITRE, CWE-676</a> - Use of Potentially Dangerous Function </li>\n  <li> <a href=\"http://www.sans.org/top25-software-errors/\">SANS Top 25</a> - Risky Resource Management </li>\n</ul>","debt":"10min"},{"summary":"Deprecated K&R syntax should not be used for function definition","type":"Code Smell","defaultSeverity":"Major","description":"<p>In 1978, Brian Kernighan and Dennis Ritchie published the first edition of The C Programming Language. This book, known to C programmers as\n\"K&amp;R\", served for many years as an informal specification of the language. The version of C that it describes is commonly referred to as K&amp;R\nC. </p>\n<p>The K&amp;R function definition syntax introduced in the book was later deprecated in the ANSI C and ISO C standards. Even though the K&amp;R\nsyntax is still supported in the ISO C11 standard, it's not in ISO C++ standard versions and is not considered readable by most C/C++ developers\ntoday. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint foo(a, b)   // Noncompliant K&amp;R C syntax\n  int a;\n  char* b;\n{\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint foo(int a, char* b) { // Compliant\n}\n</pre>","debt":"5min"},{"summary":"Nested code blocks should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Nested code blocks can be used to create a new scope and restrict the visibility of the variables defined inside it. Using this feature in a method\ntypically indicates that the method has too many responsibilities, and should be refactored into smaller methods.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void evaluate(int operator) {\n  switch (operator) {\n    /* ... */\n    case ADD: {                                // Noncompliant - nested code block '{' ... '}'\n        int a = stack.pop();\n        int b = stack.pop();\n        int result = a + b;\n        stack.push(result);\n        break;\n      }\n    /* ... */\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic void evaluate(int operator) {\n  switch (operator) {\n    /* ... */\n    case ADD:                                  // Compliant\n      evaluateAdd();\n      break;\n    /* ... */\n  }\n}\n\nprivate void evaluateAdd() {\n  int a = stack.pop();\n  int b = stack.pop();\n  int result = a + b;\n  stack.push(result);\n}\n</pre>","debt":"10min"},{"summary":"\"case\" ranges should cover multiple values","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>The GNU compiler extension that allows <code>case</code>s to be specified with ranges should only be used when a range is actually needed. Use it\nwith the same number on both ends of the range, and you've either made a mistake because an actual range was intended, or you've used the syntax\ninappropriately in a way that is highly likely to confuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 3: // Noncompliant\n    //...\n    break;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3:\n    //...\n    break;\n}\n</pre>\n<p>or</p>\n<pre>\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 5:\n    //...\n    break;\n}\n</pre>","debt":"10min"},{"summary":"Init-declarator-lists and member-declarator-lists should consist of single init-declarators and member-declarators respectively","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Where multiple declarators appear in the same declaration the type of an identifier may not meet developer expectations.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint i1; int j1; // Compliant, but not preferred\nint i2, *j2; // Noncompliant\nint *i3,\n&amp;j3 = i2; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint i1;\nint j1;\nint i2;\nint *j2;\nint *i3;\nint &amp;j3 = i2;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator\n  respectively </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/7wHEAw\">CERT, DCL52-J.</a> - Do not declare more than one variable per declaration\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/VgU\">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/fAAhAQ\">CERT, DCL04-CPP.</a> - Do not declare more than one variable per declaration\n  </li>\n</ul>","debt":"5min"},{"summary":"\"union\" names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all <code>union</code> names match a provided\nregular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>Using the default regular expression <code>[A-Z][a-zA-Z0-9]*+</code>:</p>\n<pre>\nunion my_union {\n    int one;\n    int two;\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nunion MyUnion {\n    int one;\n    int two;\n};\n</pre>","debt":"10min"},{"summary":"\"case\" ranges should not be empty","type":"Bug","defaultSeverity":"Major","description":"<p>The GNU compiler extension that allows <code>case</code>s to be specified with ranges will only recognize ranges specified from a smaller value to\na larger value. Flip the order and the range will evaluate as empty.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 5 ... 3: // Noncompliant\n    //...\n    break;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 5\n    //...\n    break;\n</pre>","debt":"2min"},{"summary":"Redundant pointer operator sequences should be removed","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>By contract, chaining the 'Address of' operator <code>&amp;</code> with the 'Indirection' operator <code>*</code> results in a return to the\ninitial value. Thus, such combinations are confusing at best, and bugs at worst.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint *ptr = ...;\nint *result1 = &amp;(*ptr); //Noncompliant\nint *result2 = &amp;*ptr; //Noncompliant\n\nint value = 4;\nint result3 = *(&amp;value); //Noncompliant\nint result4 = *&amp;value; //Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint *ptr = ...;\nint *result1 = ptr;\nint *result2 = ptr;\n\nint value = 4;\nint result3 = value;\nint result4 = value;\n</pre>\n<h2>Exceptions</h2>\n<p>No issue is raised when the <code>*</code> or <code>&amp;</code> operators are overloaded or when both operators are not located in the same piece\nof code (one being generated by a macro expansion and the other one located in the main source code for instance).</p>","debt":"5min"},{"summary":"Identical expressions should not be used on both sides of a binary operator","type":"Bug","defaultSeverity":"Major","description":"<p>Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste\nerror and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical\noperators, having the same value on both sides of an operator yields predictable results, and should be simplified.</p>\n<p>This rule ignores <code>*</code>, <code>+</code>, and <code>=</code>. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ( a == a ) { // always true\n  do_z();\n}\nif ( a != a ) { // always false\n  do_y();\n}\nif ( a == b &amp;&amp; a == b ) { // if the first one is true, the second one is too\n  do_x();\n}\nif (a == b || a == b ) { // if the first one is true, the second one is too\n  do_w();\n}\n\nif (5 / 5) { // always 1\n  do_v();\n}\nif (5 - 5) { // always 0\n  do_u();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>The following are ignored:</p>\n<ul>\n  <li> The expression <code>1 &lt;&lt; 1</code> </li>\n  <li> When an increment or decrement operator is used, ex: <code>*p++ == *p++</code> </li>\n  <li> Bitwise operators <code>|, &amp;, ^</code> </li>\n</ul>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n  <li> <a href='/coding_rules#rule_key=c%3AS1656'>S1656</a> - Implements a check on <code>=</code>. </li>\n</ul>","debt":"2min"},{"summary":"\"struct\" names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all <code>struct</code> names match a provided\nregular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>Using the default regular expression <code>[A-Z][a-zA-Z0-9]*+</code>:</p>\n<pre>\nstruct myStruct {\n  int one;\n  int two;\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct MyStruct {\n  int one;\n  int two;\n};\n</pre>","debt":"10min"},{"summary":"Methods should not contain unreachable code","type":"Bug","defaultSeverity":"Major","description":"<p>Jump statements (<code>return</code>, <code>break</code>, <code>continue</code>, and <code>goto</code>) and <code>throw</code> expressions move\ncontrol flow out of the current code block. Typically, any statements in a block that come after a jump or <code>throw</code> are simply wasted\nkeystrokes lying in wait to confuse the unwary. </p>\n<p>Rarely, as illustrated below, code after a jump or <code>throw</code> is reachable. However, such code is difficult to understand, and should be\nrefactored. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint fun(int a) {\n  int i = 10;\n  return i + a;       // Noncompliant\n  i++;             // this is never executed\n}\n\nvoid foo(int a) {\n  if (a == 5) {\n    goto error;\n  } else {\n    // do the job\n  }\n  return;\n\n  error:\n    printf(\"don't use 5\"); // this is reachable but unreadable\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint fun(int a) {\n  int i = 10;\n  return i + a;\n}\n\nvoid foo(int a) {\n  if (a == 5) {\n    handleError();\n  } else {\n    // do the job\n  }\n  return;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.1 - There shall be no unreachable code </li>\n  <li> MISRA C++:2008, 0-1-1 - A project shall not contain unreachable code </li>\n  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code </li>\n  <li> MISRA C:2012, 2.1 - A project shall not contain unreachable code </li>\n  <li> MISRA C:2012, 2.2 - There shall be no dead code </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/561.html\">MITRE, CWE-561</a> - Dead Code </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/uQCSBg\">CERT, MSC56-J.</a> - Detect and remove superfluous code and values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/OYIyAQ\">CERT, MSC07-CPP.</a> - Detect and remove dead code </li>\n</ul>","debt":"5min"},{"summary":"Preprocessor operators \"#\" and \"##\" should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>The evaluation order of both the <code>#</code> and <code>##</code> preprocessor operators is unspecified. Compilers have been known to implement\nthese operators inconsistently, therefore, to avoid these problems, do not use them.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#define A(Y)   #Y    /* Noncompliant */\n#define A(X,Y) X##Y  /* Noncompliant */\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.13 - The # and ## preprocessor operators should not be used. </li>\n  <li> MISRA C++:2008, 16-3-2 - The # and ## operators should not be used. </li>\n  <li> MISRA C:2012, 20.10 - The # and ## preprocessor operators should not be used </li>\n</ul>","debt":"30min"},{"summary":"\"#pragma warning (default: ...)\" should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Using \"#pragma warning (default: ...)\" resets the warning in question to its default settings, which may not be what the compiler was initially\ninvoked with. Typically, this usage is seen after a warning is turned off, in preparation for code that is known to cause warnings. Instead, the\nwarning's current state should be saved, and then restored after the code in question.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#pragma warning (disable: TheWarning)\n#include problem_code.h\n#pragma warning (default: TheWarning)\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#pragma warning (push)\n#include problem_code.h\n#pragma warning (pop)\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KwI\">CERT, MSC00-C.</a> - Compile cleanly at high warning levels </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/I4IyAQ\">CERT, MSC00-CPP.</a> - Compile cleanly at high warning levels </li>\n</ul>","debt":"5min"},{"summary":"Pre-defined macros should not be defined, redefined or undefined","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The standard, predefined macros, such as <code>__FILE__</code> and <code>__LINE__</code>, are primarily intended for use by the implementation, and\nchanging them could result in undefined behavior.</p>\n<p>This rule checks that the following predefined macros are not defined, undefined, or redefined: <code>assert</code>, <code>errno</code>,\n<code>__FILE__</code>, <code>__LINE__</code>, <code>__TIME__</code>, <code>__DATE__</code>, <code>__TIMESTAMP__</code>, <code>__COUNTER__</code>,\n<code>__INCLUDE_LEVEL__</code>, <code>__BASE_FILE__</code>, and <code>_Pragma</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#undef __LINE__\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined </li>\n  <li> MISRA C++:2008, 17-0-1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined </li>\n  <li> MISRA C:2012, 21.1 - #define and #undef shall not be used on a reserved identifier or reserved macro name </li>\n</ul>","debt":"10min"},{"summary":"Keywords introduced in later specifications should not be used as identifiers","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>While keywords introduced in later standards can legally be used as identifiers in code compiled to earlier standards, doing so will eventually\ncause problems. Such code will cause compile errors if (when) the compiler is upgraded, and fixing those errors could be difficult and painful. </p>\n<p>Additionally, such misuse of keywords has the potential to thoroughly confuse people who are unfamiliar with the code base, possibly leading them\nto introduce additional errors. </p>\n<p>For these reasons, the earlier this practice is stopped, the better.</p>\n<p>This rule flags instances of the following keywords used as identifiers:</p>\n<p><strong>C99</strong></p>\n<p><code>inline</code>, <code>restrict</code>, <code>_Bool</code>, <code>_Complex</code>, <code>_Noreturn</code>, <code>_Static_assert</code>,\n<code>_Thread_local</code></p>\n<p><strong>C11</strong></p>\n<p><code>_Alignas</code>, <code>_Alignof</code>, <code>_Atomic</code>, <code>_Generic</code>, <code>_Imaginary</code></p>\n<p><strong>C++11</strong></p>\n<p><code>alignas</code>, <code>alignof</code>, <code>char16_t</code>, <code>char32_t</code>, <code>constexpr</code>, <code>decltype</code>,\n<code>noexcept</code>, <code>nullptr</code>, <code>static_assert</code>, <code>thread_local</code></p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint inline = 0;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint inline_count = 0;\n</pre>","debt":"5min"},{"summary":"Files should not be too complex","type":"Code Smell","defaultSeverity":"Major","description":"<p>Most of the time, a very complex file breaks the Single Responsibility Principle and should be re-factored into several different files.</p>\n<h2>Deprecated</h2>\n<p>This rule is deprecated, and will eventually be removed.</p>","debt":"30min"},{"summary":"Function names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared naming conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With default provided regular expression: <code>[a-z][a-zA-Z0-9]*</code>:</p>\n<pre>\nvoid DoSomething (void);\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doSomething (void);\n</pre>","debt":"5min"},{"summary":"The sign of an unsigned variable should not be tested","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Because the value in a variable of an unsigned type can never be less than zero, testing to see if it is negative is a useless operation which can\nonly confuse future readers of the code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nunsigned int i = 0; // the lowest value this var can have\n...\nif (i &gt;= 0) { // Noncompliant\n  do_x(i);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nunsigned int i = 0;\n...\ndo_x(i);\n</pre>","debt":"5min"},{"summary":"Pointers should not be cast to integral types","type":"Bug","defaultSeverity":"Critical","description":"<p>The size of integer required to hold a memory address is implementation-dependent. Therefore, casting a pointer (i.e. a memory address) to any\nintegral data type may result in data loss because the integral type is too small to hold the full address value.</p>\n<p>When treating a memory address as integer type is absolutely required, you should be sure to use a large enough type to hold all the data.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint *p;\nint addr = ( int ) &amp;p;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 11.3 - A cast should not be performed between a pointer type and an integral type. </li>\n  <li> MISRA C++:2008, 5-2-9 - A cast should not convert a pointer type to an integral type. </li>\n  <li> MISRA C:2012, 11.4 - A conversion should not be performed between a pointer to object and an integer type </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/XAAV\">CERT, INT36-C.</a> - Converting a pointer to integer or integer to pointer </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/toAyAQ\">CERT, INT11-CPP.</a> - Take care when converting from pointer to integer or\n  integer to pointer </li>\n</ul>","debt":"5min"},{"summary":"\"<stdio.h>\" should not be used in production code","type":"Bug","defaultSeverity":"Critical","description":"<p>This includes file and I/O functions <code>fgetpos</code>, <code>fopen</code>, <code>ftell</code>, <code>gets</code>, <code>perror</code>,\n<code>remove</code>, <code>rename</code> and <code>ungetc</code>.</p>\n<p>Streams and file I/O have a large number of unspecified, undefined and implementation-defined behaviors associated with them. It is assumed within\nMISRA C that they will not normally be needed in production code in embedded systems.</p>\n<p>If any of the features of <code>stdio.h</code> need to be used in production code, then the issues associated with the features need to be\nunderstood.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;stdio.h&gt; /* Noncompliant */\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.9 - The input/output library &lt;stdio.h&gt; shall not be used in production code. </li>\n  <li> MISRA C++:2008, 27-0-1 - The stream input/output library &lt;cstdio&gt; shall not be used. </li>\n  <li> MISRA C:2012, 21.6 - The Standard Library input/output functions shall not be used </li>\n</ul>","debt":"4h"},{"summary":"Tabulation characters should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Developers should not need to configure the tab width of their text editors in order to be able to read source code.</p>\n<p>So the use of the tabulation character must be banned.</p>","debt":"2min"},{"summary":"Insecure functions \"strcpy\", \"strcat\" and \"sprintf\" should not be used","type":"Vulnerability","defaultSeverity":"Critical","description":"<p>When using legacy C functions such as <code>strcpy</code>, it's up to the developer to make sure the size of the buffer to be written to is large\nenough to avoid buffer overruns. If this is not done properly, it can result in a buffer overflow, causing the program to crash at a minimum. At\nworst, a carefully crafted overflow can cause malicious code to be executed.</p>\n<p>In such cases, it's better to use an alternate, secure, function, such as <code>strlcpy()</code>, <code>strlcat()</code> and\n<code>snprintf()</code>, which allows you to define the maximum number of characters to be written to the buffer. However, since\n<code>strlcpy()</code> and <code>strlcat()</code> are part of the BSD library, they might not be available, in which case <code>strncpy()</code> and\n<code>strncat()</code> should be used instead, but be aware that they don't guarantee the string will be null-terminated.</p>\n<p>This rule logs an issue when encountering the following insecure functions: <code>strcpy()</code>, <code>strcat()</code> and\n<code>sprintf()</code></p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nsprintf(str, \"%s\", message);   // Noncompliant\nstrcpy(str, message); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nsnprintf(str, sizeof(str), \"%s\", message);\nstrlcpy(str, message, sizeof(str));\n\nstrncpy(str, message, sizeof(str) -1); // Leave room for null\nstr[sizeof(str) - 1] = '\\0'; // Make sure the string is null-terminated\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/120\">MITRE, CWE-120</a> - Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n  </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/676\">MITRE, CWE-676</a> - Use of Potentially Dangerous Function </li>\n  <li> <a href=\"http://www.sans.org/top25-software-errors/\">SANS Top 25</a> - Risky Resource Management </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/QwY\">CERT, STR07-C.</a> - Use the bounds-checking interfaces for string manipulation\n  </li>\n</ul>","debt":"20min"},{"summary":"The 'sizeof' and 'alignof' operators should not be used with operands of a 'void' type","type":"Bug","defaultSeverity":"Minor","description":"<p>Although some compilers will allow it, the use of <code>sizeof</code> and <code>alignof</code> with arguments that have a <code>void</code>\ntype is forbidden by both the C and C++ standards.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fun() {\n  void* p;\n  sizeof(*p);  // Noncompliant\n  sizeof(void);  // Noncompliant\n}\n</pre>","debt":"5min"},{"summary":"Track lack of copyright and license headers","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Each source file should start with a header stating file ownership and the license which must be used to distribute the application. </p>\n<p>This rule must be fed with the header text that is expected at the beginning of every file.</p>\n<h2>Compliant Solution</h2>\n<pre>\n/*\n * SonarQube, open source software quality management tool.\n * Copyright (C) 2008-2013 SonarSource\n * mailto:contact AT sonarsource DOT com\n *\n * SonarQube is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * SonarQube is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n</pre>","debt":"5min"},{"summary":"All uses of the #pragma directive should be documented","type":"Code Smell","defaultSeverity":"Major","description":"<p>The <code>#pragma</code> directive is implementation-defined, hence it is important both to demonstrate that all uses are correct, and to minimize,\nlocalize and encapsulate any use of pragmas within dedicated functions whenever possible.</p>\n<p>The meaning of each pragma shall be documented.</p>\n<p>There shall be sufficient supporting description to demonstrate that the behavior of the pragma and its implications for the application, have been\nfully understood.</p>\n<p>This rule flags all instances of <code>#pragma</code> directives, and leaves it to the user to determine whether they have been properly\ndocumented.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 3.4 - All uses of the #pragma directive shall be documented and explained </li>\n  <li> MISRA C++:2008, 16-6-1 - All uses of the #pragma directive shall be documented </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KwI\">CERT, MSC00-C</a> - Compile cleanly at high warning levels </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/I4IyAQ\">CERT, MSC00-CPP</a> - Compile cleanly at high warning levels </li>\n</ul>","debt":"10min"},{"summary":"Zero should not be a possible denominator","type":"Bug","defaultSeverity":"Critical","description":"<p>If the denominator to a division or modulo operation is zero it would result in a fatal error.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid test_divide() {\n  int z = 0;\n  if (unknown()) {\n    // ..\n    z = 3;\n  } else {\n    // ..\n  }\n  z = 1 / z; // Noncompliant, possible division by zero\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid test_divide() {\n  int z = 0;\n  if (unknown()) {\n    // ..\n    z = 3;\n  } else {\n    // ..\n    z = 1;\n  }\n  z = 1 / z;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://cwe.mitre.org/data/definitions/369.html\">MITRE, CWE-369</a> - Divide by zero </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KAGyAw\">CERT, NUM02-J.</a> - Ensure that division and remainder operations do not\n  result in divide-by-zero errors </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/cAI\">CERT, INT33-C.</a> - Ensure that division and remainder operations do not result\n  in divide-by-zero errors </li>\n</ul>","debt":"5min"},{"summary":"Memory access should be explicitly bounded to prevent buffer overflows","type":"Bug","defaultSeverity":"Blocker","description":"<p>Array overruns and buffer overflows happen when memory access accidentally goes beyond the boundary of the allocated array or buffer. These\noverreaching accesses cause some of the most damaging, and hard to track defects.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint array[10];\narray[10] = 0; // Noncompliant: index should be between 0 &amp; 9\n\nchar *buffer1 = (char *) malloc(100);\nchar *buffer2 = (char *) malloc(50);\nmemcpy(buffer2, buffer1, 100); // Noncompliant: buffer2 will overflow.\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint array[10];\narray[9] = 0;\n\nchar *buffer1 = (char *) malloc(100);\nchar *buffer2 = (char *) malloc(50);\nmemcpy(buffer2, buffer1, 50);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://cwe.mitre.org/data/definitions/119.html\">MITRE, CWE-119</a> - Improper Restriction of Operations within the Bounds of a Memory\n  Buffer </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/P4EyAQ\">CERT, STR50-CPP.</a> - Guarantee that storage for strings has sufficient space\n  for character data and the null terminator </li>\n</ul>","debt":"5min"},{"summary":"\"switch\" statements should not contain non-case labels","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Even if it is legal, mixing case and non-case labels in the body of a switch statement is very confusing and can even be the result of a typing\nerror.</p>\n<h2>Noncompliant Code Example</h2>\n<p>Case 1, the code is syntactically correct but the behavior is not the expected one</p>\n<pre>\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  WEDNESDAY:   // instead of \"case WEDNESDAY\"\n    doSomething();\n    break;\n  ...\n}\n</pre>\n<p>Case 2, the code is correct and behaves as expected but is hardly readable </p>\n<pre>\nswitch (day) {\n  case MONDAY:\n    break;\n  case TUESDAY:\n    foo:for(int i = 0 ; i &lt; X ; i++) {\n         /* ... */\n        break foo;  // this break statement doesn't relate to the nesting case TUESDAY\n         /* ... */\n    }\n    break;\n    /* ... */\n}\n</pre>\n<h2>Compliant Solution</h2>\n<p>Case 1</p>\n<pre>\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  case WEDNESDAY:\n    doSomething();\n    break;\n  ...\n}\n</pre>\n<p>Case 2</p>\n<pre>\nswitch (day) {\n  case MONDAY:\n    break;\n  case TUESDAY:\n    compute(args); // put the content of the labelled \"for\" statement in a dedicated method\n    break;\n\n    /* ... */\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.0 - The MISRA C <em>switch</em> syntax shall be used. </li>\n  <li> MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. </li>\n  <li> MISRA C:2012, 16.1 - All switch statements shall be well-formed </li>\n</ul>","debt":"10min"},{"summary":"Methods returns should not be invariant","type":"Code Smell","defaultSeverity":"Major","description":"<p>When a method is designed to return an invariant value, it may be poor design, but it shouldn't adversely affect the outcome of your program.\nHowever, when it happens on all paths through the logic, it is surely a bug.</p>\n<p>This rule raises an issue when a method contains several <code>return</code> statements that all return the same value.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint foo(int a) {\n  int b = 12;\n  if (a == 1) {\n    return b;\n  }\n  return b;  // Noncompliant\n}\n</pre>"},{"summary":"Increment should not be used to set boolean variables to 'true'","type":"Code Smell","defaultSeverity":"Major","description":"<p>It is possible to use the increment operator <code>++</code>, to set the value of a <code>bool</code>(C++) or <code>_Bool</code>(C) variable to\n<code>true</code>. But this feature has been deprecated in C++ since the 1998 version of the standard, and even where allowed, is simply confusing.\n</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nbool alive;\n...\nalive++;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nbool alive;\n...\nalive = true;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> ISO/IEC 14882:1998, 5.3.2 </li>\n</ul>","debt":"1min"},{"summary":"File names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate effectively. For that reason, file names should conform to a defined standard. This rule\nraises an issue when the names of analyzed files don't match the provided regular expression.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/P4IyAQ\">CERT, MSC09-CPP.</a> - Character encoding: Use subset of ASCII for safety </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/lQAl\">CERT, MSC09-C.</a> - Character encoding: Use subset of ASCII for safety </li>\n</ul>","debt":"10min"},{"summary":"Assembly language should be encapsulated and isolated","type":"Code Smell","defaultSeverity":"Major","description":"<p>Ensuring that assembly language code is encapsulated and isolated aids portability. Where assembly language instructions are needed, they shall be\nencapsulated and isolated in either assembler functions or C++ functions.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fn ( void )\n{\n  DoSomething ( );\n  asm ( \"NOP\" ); // Noncompliant, asm mixed with C/C++ statements\n  DoSomething ( );\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid Delay ( void )\n{\n  asm ( \"NOP\" ); // Compliant, asm not mixed with C/C++ statements\n}\n\nvoid fn ( void )\n{\n  DoSomething ( );\n  Delay ( ); // Compliant, Assembler is encapsulated\n  DoSomething ( );\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 2.1 - Assembly language shall be encapsulated and isolated. </li>\n  <li> MISRA C++:2008, 7-4-3 - Assembly language shall be encapsulated and isolated. </li>\n</ul>","debt":"20min"},{"summary":"Obsolete POSIX functions should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>To ensure future code portability, obsolete POSIX functions should be removed. Those functions, with their replacements are listed below:</p>\n<table>\n  <tbody>\n    <tr>\n      <th>Obsolete</th>\n      <th>Use Instead</th>\n    </tr>\n    <tr>\n      <td>asctime</td>\n      <td>strftime</td>\n    </tr>\n    <tr>\n      <td>asctime_r</td>\n      <td>strftime</td>\n    </tr>\n    <tr>\n      <td>bcmp</td>\n      <td>memcmp</td>\n    </tr>\n    <tr>\n      <td>bcopy</td>\n      <td>memmove memcpy</td>\n    </tr>\n    <tr>\n      <td>bsd_signal</td>\n      <td>sigaction</td>\n    </tr>\n    <tr>\n      <td>bzero</td>\n      <td>memset</td>\n    </tr>\n    <tr>\n      <td>ctime</td>\n      <td>strftime</td>\n    </tr>\n    <tr>\n      <td>ecvt</td>\n      <td>sprintf</td>\n    </tr>\n    <tr>\n      <td>fcvt</td>\n      <td>sprintf</td>\n    </tr>\n    <tr>\n      <td>ftime</td>\n      <td>no replacement function</td>\n    </tr>\n    <tr>\n      <td>gcvt</td>\n      <td>sprintf</td>\n    </tr>\n    <tr>\n      <td>getcontext</td>\n      <td>Rewrite to use POSIX threads.</td>\n    </tr>\n    <tr>\n      <td>gethostbyaddr</td>\n      <td>getnameinfo</td>\n    </tr>\n    <tr>\n      <td>gethostbyname</td>\n      <td>getaddrinfo</td>\n    </tr>\n    <tr>\n      <td>getwd</td>\n      <td>getcwd</td>\n    </tr>\n    <tr>\n      <td>index</td>\n      <td>strchr</td>\n    </tr>\n    <tr>\n      <td>makecontext</td>\n      <td>Rewrite to use POSIX threads.</td>\n    </tr>\n    <tr>\n      <td>pthread_attr_getstackaddr</td>\n      <td>pthread_attr_getstack</td>\n    </tr>\n    <tr>\n      <td>pthread_attr_setstackaddr</td>\n      <td>pthread_attr_setstack</td>\n    </tr>\n    <tr>\n      <td>rand_r</td>\n      <td>rand</td>\n    </tr>\n    <tr>\n      <td>rindex</td>\n      <td>strrchr</td>\n    </tr>\n    <tr>\n      <td>scalb</td>\n      <td>scalbln', 'scalblnf' or 'scalblnl' instead of this function</td>\n    </tr>\n    <tr>\n      <td>swapcontext</td>\n      <td>Rewrite to use POSIX threads.</td>\n    </tr>\n    <tr>\n      <td>tmpnam</td>\n      <td>'tmpfile', 'mkstemp', or 'mkdtemp' instead for this function</td>\n    </tr>\n    <tr>\n      <td>tmpnam_r</td>\n      <td>tmpfile', 'mkstemp', or 'mkdtemp' instead for this function</td>\n    </tr>\n    <tr>\n      <td>ualarm</td>\n      <td>'timer_create', 'timer_delete', 'timer_getoverrun', 'timer_gettime', or 'timer_settime' instead of this function</td>\n    </tr>\n    <tr>\n      <td>usleep</td>\n      <td>'nanosleep' or 'setitimer' function</td>\n    </tr>\n    <tr>\n      <td>utime</td>\n      <td>utimensat</td>\n    </tr>\n    <tr>\n      <td>vfork</td>\n      <td>fork</td>\n    </tr>\n    <tr>\n      <td>wcswcs</td>\n      <td>wcsstr</td>\n    </tr>\n  </tbody>\n</table>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/EgAa\">CERT, POS33-C.</a> - Do not use vfork() </li>\n</ul>","debt":"30min"},{"summary":"Source code should only use /* ... */ style comments","type":"Code Smell","defaultSeverity":"Minor","description":"<p>This excludes the use of <code>//</code> C99 style comments and C++ style comments, since these are not permitted in C90. Many compilers support\nthe <code>//</code> style of comments as an extension to C90. The use of <code>//</code> in preprocessor directives (e.g. <code>#define</code>) can\nvary. Also the mixing of <code>/* ... */</code> and <code>//</code> is not consistent. This is more than a style issue, since different (pre C99)\ncompilers may behave differently.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint main(int argc, char* argv[])\n{\n  // Do nothing - Noncompliant\n  return 0;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint main(int argc, char* argv[])\n{\n  /* Do nothing - Compliant */\n  return 0;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 2.2 - Source code shall only use /* ... */ style comments. </li>\n</ul>","debt":"5min"},{"summary":"\"/*\" and \"//\" should not be used within comments","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Defining a nested single-line comment within a multi-line comment invites errors. It may lead a developer to wrongly think that the lines located\nafter the single-line comment are not part of the comment.</p>\n<p>If a comment starting sequence, <code>/*</code> or <code>//</code>, occurs within a <code>/*</code> comment, is it quite likely to be caused by a\nmissing <code>*/</code> comment ending sequence.</p>\n<p>If a comment starting sequence occurs within a <code>//</code> comment, it is probably because a region of code has been commented-out using\n<code>//</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n/* some comment, end comment marker accidentally omitted\n// Make sure this function is called in a thread safe context\nPerform_Critical_Safety_Function(X);\n...\n/* this comment is non-compliant */\n</pre>\n<h2>Exceptions</h2>\n<p>The sequence // is permitted within a // comment.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 2.3 - The character sequence /* shall not be used within a comment. </li>\n  <li> MISRA C++:2008, 2-7-1 - The character sequence /* shall not be used within a C-style comment. </li>\n  <li> MISRA C:2012, 3.1 - The character sequences /* and // shall not be used within a comment </li>\n</ul>","debt":"2min"},{"summary":"Methods should not return constants","type":"Code Smell","defaultSeverity":"Minor","description":"<p>There's no point in forcing the overhead of a method call for a method that always returns the same constant value. Even worse, the fact that a\nmethod call must be made will likely mislead developers who call the method thinking that something more is done. Declare a constant instead. </p>\n<p>This rule raises an issue if on methods that contain only one statement: the <code>return</code> of a constant value. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint getBestNumber() {\n  return 12;  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstatic int bestNumber = 12;\n</pre>\n<h2>Exceptions</h2>\n<p><code>override</code>, <code>final</code>, <code>virtual</code> and overriding functions are ignored.</p>","debt":"5min"},{"summary":"Memory locations should not be released more than once","type":"Bug","defaultSeverity":"Blocker","description":"<p>Using <code>free(...)</code> or <code>delete</code> releases the reservation on a memory location, making it immediately available for another\npurpose. So releasing the same memory location twice can lead to corrupting the program's memory. </p>\n<p>A best practice to avoid this bug calls for setting just-freed pointers to <code>NULL</code>, and always null-testing before a <code>free</code> or\n<code>delete</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid doSomething(int size) {\n  char *cp = (char *)malloc(sizeof(char)*size);\n\n  // ...\n  if(condition) {\n    free(cp);\n  }\n\n  free(cp);  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doSomething(int size) {\n  char *cp = (char *)malloc(sizeof(char)*size);\n\n  // ...\n  if(condition) {\n    if (cp != NULL) {\n      free(cp);\n      cp = NULL;\n    }\n  }\n\n  if (cp) {  // This is a common, short-hand null test\n    free(cp);\n    cp = NULL;\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://cwe.mitre.org/data/definitions/415.html\">MITRE, CWE-415</a> - Double Free </li>\n  <li> <a href=\"https://www.owasp.org/index.php/Double_Free\">OWASP, Double Free</a> </li>\n</ul>","debt":"5min"},{"summary":"Statements should be on separate lines","type":"Code Smell","defaultSeverity":"Major","description":"<p>For better readability, do not put more than one statement on a single line.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo(); bar(); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfoo();\nbar();\n</pre>\n<h2>Exceptions</h2>\n<p>Control flow statements with a single nested statement are ignored.</p>\n<pre>\nif (condition) doSomething();       // Compliant\nwhile (condition) doSomething();    // Compliant\n</pre>\n<p><code>case</code> or <code>default</code> statements containing a single statement and followed by <code>break</code> are ignored.</p>\n<pre>\nswitch (foo) {\n  case  0: doSomething(); break;    // Compliant\n  default: doSomething(); break;    // Compliant\n}\n</pre>\n<p>Statements enclosed in curly braces on the same line are ignored.</p>\n<pre>\nauto lambda = [](int x) { doSomething(x); return x; }; // Compliant\n</pre>","debt":"1min"},{"summary":"Types and variables should be declared in separate statements","type":"Code Smell","defaultSeverity":"Minor","description":"<p>It is possible in the same statement, to declare a user-defined type (<code>class</code>, <code>struct</code>, <code>union</code> or\n<code>enum</code>) followed by variable declarations of this type. But mixing more than one concern in a single statement is confusing for\nmaintainers.</p>\n<p>This rule raises an issue when a variable is declared at the end of a user-defined type declaration statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct Container { int size; } container; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct Container { int size; };\nContainer container;\n</pre>","debt":"2min"},{"summary":"Function parameters should not be reassigned","type":"Code Smell","defaultSeverity":"Minor","description":"<p>While it is technically correct to assign to parameters from within function bodies, it is better to use temporary variables to store intermediate\nresults.</p>\n<p>Allowing parameters to be assigned to also reduces the code readability as developers will not be able to know whether the original parameter or\nsome temporary variable is being accessed without going through the whole function.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint glob = 0;\nvoid function (int a) {\n  a = glob; // Noncompliant\n  ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint glob = 0;\nvoid function (int a) {\n  int b = glob;\n  ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 17.8 - A function parameter should not be modified </li>\n</ul>","debt":"5min"},{"summary":"break statements should not be used except for switch cases","type":"Code Smell","defaultSeverity":"Minor","description":"<p><code>break;</code> is an unstructured control flow statement which makes code harder to read.</p>\n<p>Ideally, every loop should have a single termination condition.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (element = list.first; element != null; element = element-&gt;next) { // First termination condition\n  if (!matches(element-&gt;value)) {                                      // Second termination condition\n    break; // Noncompliant\n  }\n\n  /* ... */\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// Compliant\nfor (element = list.first; element != null &amp;&amp; matches(element-&gt;value); element = element-&gt;next) {\n  /* ... */\n}\n</pre>","debt":"10min"},{"summary":"\"#include\" directives should be followed by either <filename> or \"filename\" sequences","type":"Bug","defaultSeverity":"Major","description":"<p>These are the only forms for the <code>#include</code> directive permitted by the standard. The behavior is undefined when other forms are\nused.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include filename.h        // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include \"filename.h\"        // Compliant\n#include &lt;filename.h&gt;\n\n#define HEADER \"filename.h\"\n#include HEADER\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.3 - The #include directive shall be followed by either a &lt;filename&gt; or \"filename\" sequence. </li>\n  <li> MISRA C++:2008, 16-2-6 - The #include directive shall be followed by either a &lt;filename&gt; or \"filename\" sequence. </li>\n  <li> MISRA C:2012, 20.3 - The #include directive shall be followed by either a &lt;filename&gt; or \"filename\" sequence </li>\n</ul>","debt":"10min"},{"summary":"Unions should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The use of unions to access an object in different ways may result in the data being misinterpreted. Therefore, this rule prohibits the use of\nunions for any purpose.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nunion U1 { // Noncompliant\n    float j;\n    int i;\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 18.4 - Unions shall not be used. </li>\n  <li> MISRA C++:2008, 9-5-1 - Unions shall not be used. </li>\n  <li> MISRA C:2012, 19.2 - The union keyword should not be used </li>\n</ul>","debt":"15min"},{"summary":"Files should not have too many lines of code","type":"Code Smell","defaultSeverity":"Major","description":"<p>A source file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to\nmaintain. Above a specific threshold, it is strongly advised to refactor it into smaller pieces of code which focus on well defined tasks. Those\nsmaller files will not only be easier to understand but also probably easier to test.</p>","debt":"1h"},{"summary":"Conditionals should start on new lines","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Code is clearest when each statement has its own line. Nonetheless, it is a common pattern to combine on the same line an <code>if</code> and its\nresulting <em>then</em> statement. However, when an <code>if</code> is placed on the same line as the closing <code>} </code> from a preceding\n<code>else</code> or <code>else if</code>, it is either an error - <code>else</code> is missing - or the invitation to a future error as maintainers\nfail to understand that the two statements are unconnected.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition1) {\n  // ...\n} if (condition2) {  // Noncompliant\n  //...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition1) {\n  // ...\n} else if (condition2) {\n  //...\n}\n</pre>\n<p>Or</p>\n<pre>\nif (condition1) {\n  // ...\n}\n\nif (condition2) {\n  //...\n}\n</pre>","debt":"10min"},{"summary":"\"#include_next\" should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p><code>#include_next</code> is a gcc-specific language extension that alters the search path for the specified header file by starting the search\nfrom the header file directory <em>after</em> the one in which the directive was encountered. It also ignores the distinction between\n<code>\"file\"</code> and <code>&lt;file&gt;</code>. It is typically used when you have two (probably related) header files with the same name, although\nthere is nothing in the extension to enforce or limit the use to same-name files.</p>\n<p>Use of this extension can be tricky to get right, and is almost never justified. Instead, you should use an absolute path in the\n<code>#include</code> statement or rename one of the files.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include_next \"foo.h\" // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include \"/usr/local/include/foo.h\"\n</pre>","debt":"10min"},{"summary":"Conditionally executed code should be denoted by either indentation or curly braces","type":"Code Smell","defaultSeverity":"Critical","description":"<p>In the absence of enclosing curly braces, the line immediately after a conditional is the one that is conditionally executed. By both convention\nand good practice, such lines are indented. In the absence of both curly braces and indentation the intent of the original programmer is entirely\nunclear and perhaps not actually what is executed. Additionally, such code is highly likely to be confusing to maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition)  // Noncompliant\ndoTheThing();\ndoTheOtherThing();\nsomethingElseEntirely();\n\nfoo();\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition) {\n  doTheThing();\n  doTheOtherThing();\n  somethingElseEntirely();\n}\n\nfoo();\n</pre>\n<p>Or</p>\n<pre>\nif (condition)\n  doTheThing();\ndoTheOtherThing();\nsomethingElseEntirely();\n\nfoo();\n</pre>","debt":"10min"},{"summary":"\"continue\" should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p><code>continue</code> is an unstructured control flow statement. It makes code less testable, less readable and less maintainable. Structured\ncontrol flow statements such as <code>if</code> should be used instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint i;\nfor (i = 0; i &lt; 10; i++) {\n  if (i == 5) {\n    continue;  /* Noncompliant */\n  }\n  printf(\"i = %d\\n\", i);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint i;\nfor (i = 0; i &lt; 10; i++) {\n  if (i != 5) {\n    printf(\"i = %d\\n\", i);\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.5 - The continue statement shall not be used. </li>\n</ul>","debt":"1h"},{"summary":"Non-standard characters should not occur in header file names in \"#include\" directives","type":"Bug","defaultSeverity":"Major","description":"<p>If the <code>'</code>, <code>\\</code>, <code>\"</code> or <code>/*</code> characters are used between <code>&lt;</code> and <code>&gt;</code>\ndelimiters or the <code>'</code>, <code>\\</code> or <code>/*</code> characters are used between the <code>\"</code> delimiters in a header name\npreprocessing token, then the behavior is undefined.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;\"foo\"&gt;     // Noncompliant\n#include \"dir\\foo.h\" // Noncompliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.2 - Non-standard characters should not occur in header file names in #include directives. </li>\n  <li> MISRA C++:2008, 16-2-4 - The ', \", /* or // characters shall not occur in a header file name. </li>\n  <li> MISRA C++:2008, 16-2-5 - The \\ character should not occur in a header file name. </li>\n  <li> MISRA C:2012, 20.2 - The ', \" or \\ characters and the /* or // character sequences shall not occur in a header file name </li>\n</ul>","debt":"10min"},{"summary":"Unary prefix operators should not be repeated","type":"Bug","defaultSeverity":"Major","description":"<p>The needless repetition of an operator is usually a typo. After all, why write <code>!!!i</code> when <code>!i</code> will do?</p>\n<p>On the other hand, the repetition of increment and decrement operators may have been done on purpose, but doing so obfuscates the meaning, and\nshould be simplified.</p>\n<p>This rule raises an issue for sequences of: <code>!</code>, <code>~</code>, <code>-</code>, and <code>+</code>, and in C++ for repetitions of the\nincrement and decrement operators.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint i = 1;\n\nint j = - - -i;  // Noncompliant; just use -i\nint k = ~~i;     // Noncompliant; same as i\nint m = + +i;    // Noncompliant; operators are useless here\n\nbool b = false;\nbool c = !!!b;   // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint i =  1;\n\nint j = -i;\nint k =  i;\nint m =  i;\n\nbool b = false;\nbool c = !b;\n</pre>\n<h2>Exceptions</h2>\n<p>Boolean normalization <code>!!</code> is ignored.</p>","debt":"5min"},{"summary":"A function should have a single point of exit at the end of the function","type":"Code Smell","defaultSeverity":"Minor","description":"<p>This is required by IEC 61508, under good programming style.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint function1()\n{\n  return 3;\n}\n\nvoid function2()\n{\n  function1();\n}\n\nint function3(char* ptr) /* Noncompliant; two explicit returns */\n{\n  if (ptr == NULL) return -1;\n\n  return 7;\n}\n\nvoid function4(char *ptr) /* Noncompliant; two returns, one explicit and one implicit */\n{\n  if (1) return;\n\n  printf(\"hello world!\\n\");\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.7 - A function shall have a single point of exit at the end of the function. </li>\n  <li> MISRA C++:2008, 6-6-5 - A function shall have a single point of exit at the end of the function </li>\n  <li> MISRA C:2012, 15.5 - A function should have a single point of exit at the end </li>\n</ul>","debt":"20min"},{"summary":"\"switch\" statements should end with \"default\" clauses","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The requirement for a final <code>default</code> clause is defensive programming. The clause should either take appropriate action, or contain a\nsuitable comment as to why no action is taken. When the <code>switch</code> covers all current values of an <code>enum</code> - and especially when it\ndoesn't - a <code>default</code> case should still be used because there is no guarantee that the <code>enum</code> won't be extended.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (param) { // Noncompliant - default clause is missing\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n  default:\n    doDefault();\n    break;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.0 - The MISRA C <em>switch</em> syntax shall be used. </li>\n  <li> MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause </li>\n  <li> MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. </li>\n  <li> MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause </li>\n  <li> MISRA C:2012, 16.1 - All switch statements shall be well-formed </li>\n  <li> MISRA C:2012, 16.4 - Every <em>switch</em> statement shall have a <em>default</em> label </li>\n  <li> MISRA C:2012, 16.5 - A <em>default</em> label shall appear as either the first or the last <em>switch label</em> of a <em>switch</em> statement\n  </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/478.html\">MITRE, CWE-478</a> - Missing Default Case in Switch Statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/YgE\">CERT, MSC01-C.</a> - Strive for logical completeness </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/JoIyAQ\">CERT, MSC01-CPP.</a> - Strive for logical completeness </li>\n</ul>\n<h3>See also</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=c%3AS3562'>S3562</a> </li>\n</ul>","debt":"5min"},{"summary":"\"if ... else if\" constructs should end with \"else\" clauses","type":"Code Smell","defaultSeverity":"Critical","description":"<p>This rule applies whenever an <code>if</code> statement is followed by one or more <code>else if</code> statements; the final <code>else if</code>\nshould be followed by an <code>else</code> statement.</p>\n<p>The requirement for a final <code>else</code> statement is defensive programming.</p>\n<p>The <code>else</code> statement should either take appropriate action or contain a suitable comment as to why no action is taken. This is\nconsistent with the requirement to have a final <code>default</code> clause in a <code>switch</code> statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (x == 0) {\n  doSomething();\n} else if (x == 1) {\n  doSomethingElse();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (x == 0) {\n  doSomething();\n} else if (x == 1) {\n  doSomethingElse();\n} else {\n  error();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.10 - All if...else if constructs shall be terminated with an else clause. </li>\n  <li> MISRA C++:2008, 6-4-2 - All if...else if constructs shall be terminated with an else clause. </li>\n  <li> MISRA C:2012, 15.7 - All if...else if constructs shall be terminated with an else statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/YgE\">CERT, MSC01-C.</a> - Strive for logical completeness </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/JoIyAQ\">CERT, MSC01-CPP.</a> - Strive for logical completeness </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/PQHRAw\">CERT, MSC57-J.</a> - Strive for logical completeness </li>\n</ul>","debt":"5min"},{"summary":"#include directives in a file should only be preceded by other preprocessor directives or comments","type":"Code Smell","defaultSeverity":"Major","description":"<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.\nThe only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;h1.h&gt; /* Compliant */\nint32_t i;\n#include &lt;f2.h&gt; /* Noncompliant */\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include &lt;h1.h&gt;\n#include &lt;f2.h&gt;\n\nint32_t i;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>\n  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>\n  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>\n</ul>","debt":"10min"},{"summary":"Switch cases should end with an unconditional \"break\" statement","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>When the execution is not explicitly terminated at the end of a switch case, it continues to execute the statements of the following case. While\nthis is sometimes intentional, it often is a mistake which leads to unexpected behavior. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:  // Both 'doSomething()' and 'doSomethingElse()' will be executed. Is it on purpose ?\n    doSomething();\n  default:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule is relaxed in the following cases:</p>\n<pre>\nswitch (myVariable) {\n  case 0:                                // Empty case used to specify the same behavior for a group of cases.\n  case 1:\n    doSomething();\n    break;\n  case 2:                                // Use of return statement\n    return;\n  case 3:                                // Use of throw statement\n    throw 1;\n  case 4:                                // Use of continue statement\n    continue;\n  default:                               // For the last case, use of break statement is optional\n    doSomethingElse();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.0 - The MISRA C <em>switch</em> syntax shall be used. </li>\n  <li> MISRA C:2004, 15.2 - An unconditional break statement shall terminate every non-empty switch clause </li>\n  <li> MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. </li>\n  <li> MISRA C++:2008, 6-4-5 - An unconditional throw or break statement shall terminate every non-empty switch-clause </li>\n  <li> MISRA C:2012, 16.1 - All switch statements shall be well-formed </li>\n  <li> MISRA C:2012, 16.3 - An unconditional break statement shall terminate every switch-clause </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/484.html\">MITRE, CWE-484</a> - Omitted Break Statement in Switch </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/YIFLAQ\">CERT, MSC17-C.</a> - Finish every set of statements associated with a case\n  label with a break statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ZoFLAQ\">CERT, MSC18-CPP.</a> - Finish every set of statements associated with a case\n  label with a break statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ewHAAQ\">CERT, MSC52-J.</a> - Finish every set of statements associated with a case\n  label with a break statement </li>\n</ul>","debt":"10min"},{"summary":"Tests of non-Boolean values against zero should be explicit","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Where a data value is to be tested against zero then the test should be made explicit. The exception to this rule is when data represents a Boolean\nvalue, even though in C this will in practice be an integer.</p>\n<p>This rule is in the interests of clarity, and makes clear the distinction between integers and logical values.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ( x ) // Noncompliant, unless x is effectively Boolean data\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif ( x == 0) // Compliant solution\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.2 - Tests of a value against zero should be made explicit, unless the operand is effectively Boolean. </li>\n</ul>","debt":"5min"},{"summary":"Array values should not be replaced unconditionally","type":"Bug","defaultSeverity":"Major","description":"<p>It is highly suspicious when a value is saved for a key or index and then unconditionally overwritten. Such replacements are likely in error.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntowns[i] = \"London\";\ntowns[i] = \"Chicago\";  // Noncompliant\n</pre>","debt":"5min"},{"summary":"The three expressions of a \"for\" statement should only be concerned with loop control","type":"Bug","defaultSeverity":"Major","description":"<p>The <code>for</code> statement provides a general-purpose looping facility. Using a restricted form of loop makes code easier to review and to\nanalyse.</p>\n<p>The three clauses of a for statement are the:</p>\n<ul>\n  <li> First clause which should\n    <ul>\n      <li> be empty, or </li>\n      <li> assign a value to the loop counter, or </li>\n      <li> define and initialize the loop counter (C99). </li>\n    </ul> </li>\n  <li> Second clause which should\n    <ul>\n      <li> be an expression that has no persistent side effects, and </li>\n      <li> not use objects that are modified in the for loop body. </li>\n    </ul> </li>\n  <li> Third clause which should\n    <ul>\n      <li> be an expression whose only persistent side effect is to modify the value of the loop counter, and </li>\n      <li> not use objects that are modified in the for loop body. </li>\n    </ul> </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor( int i = 0 ; i++ &lt; 10 ; i += 1 ) { // Noncompliant, loop counter is updated in the condition\n}\n\nfor( int i = 0 ; ; ) { // Noncompliant, initialized variable i is not used in the condition\n}\n\nfor( int i = 0 , j = 0 ; i &lt; 10 ; i += j) { // Noncompliant, j is modified in the body\n  j = i + 1;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.5 - The three expressions of a for statement shall be concerned only with loop control. </li>\n  <li> MISRA C++:2008, 6-5-5 - A <em>loop-control-variable</em> other than the <em>loop-counter</em> shall not be modified within <em>condition</em>\n  or <em>expression</em>. </li>\n  <li> MISRA C:2012, 14.2 - A for loop shall be well-formed </li>\n</ul>","debt":"10min"},{"summary":"Include directives should not rely on non-portable search strategy","type":"Code Smell","defaultSeverity":"Major","description":"<p>Microsoft's MSVC has a search strategy which differs from other compilers when resolving quoted include directives <code>#include \"file.h\"</code>.\nRelying on such a strategy is not portable and may lead to compilation failure when trying to build with a different compiler.</p>\n<p>This rule raises an issue whenever the file specified in a <code>#include</code> directive can only be found using the MSVC search strategy.</p>\n<h2>See</h2>\n<p><a href=\"https://docs.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp\">MSVC documentation</a></p>","debt":"5min"},{"summary":"\"goto\" should jump to labels declared later in the same function","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Unconstrained use of <code>goto</code> can lead to programs that are extremely difficult to comprehend and analyse. For C++, it can also lead to\nthe program exhibiting unspecified behavior.</p>\n<p>However, in many cases a total ban on <code>goto</code> requires the introduction of flags to ensure correct control flow, and it is possible that\nthese flags may themselves be less transparent than the <code>goto</code> they replace.</p>\n<p>Therefore, the restricted use of <code>goto</code> is allowed where that use will not lead to semantics contrary to developer expectations. \"Back\"\njumps are prohibited, since they can be used to create iterations without using the well-defined iteration statements supplied by the core\nlanguage.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint f() {\n  int j = 0;\nL1:\n  ++j;\n  if (10 == j) {\n    goto L2;         // forward jump ignored\n  }\n  // ...\n  goto L1;           // Noncompliant\nL2:\n  return ++j;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint f() {\n  for (int j = 0; j &lt; 11; j++) {\n    // ...\n  }\n  return ++j;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 6-6-2 - The goto statement shall jump to a label declared later in the same function body </li>\n  <li> MISRA C:2012, 15.2 - The goto statement shall jump to a label declared later in the same function </li>\n</ul>","debt":"1h"},{"summary":"Increment (++) and decrement (--) operators should not be used in a method call or mixed with other operators in an expression","type":"Code Smell","defaultSeverity":"Major","description":"<p>The use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:</p>\n<ul>\n  <li> It can significantly impair the readability of the code. </li>\n  <li> It introduces additional side effects into a statement, with the potential for undefined behavior. </li>\n  <li> It is safer to use these operators in isolation from any other arithmetic operators. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nu8a = ++u8b + u8c--;\nfoo = bar++ / 4;\n</pre>\n<h2>Compliant Solution</h2>\n<p>The following sequence is clearer and therefore safer:</p>\n<pre>\n++u8b;\nu8a = u8b + u8c;\nu8c--;\nfoo = bar / 4;\nbar++;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.1 - Limited dependence should be placed on the C operator precedence rules in expressions. </li>\n  <li> MISRA C:2004, 12.13 - The increment (++) and decrement (--) operators should not be mixed with other operators in an expression. </li>\n  <li> MISRA C++:2008, 5-2-10 - The increment (++) and decrement (--) operator should not be mixed with other operators in an expression. </li>\n  <li> MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit </li>\n  <li> MISRA C:2012, 13.3 - A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects\n  other than that cause by the increment or decrement operator </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ZwE\">CERT, EXP30-C.</a> - Do not depend on the order of evaluation for side effects\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/fYAyAQ\">CERT, EXP50-CPP.</a> - Do not depend on the order of evaluation for side\n  effects </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/yQC7AQ\">CERT, EXP05-J.</a> - Do not follow a write by a subsequent write or read of the\n  same object within an expression </li>\n</ul>","debt":"5min"},{"summary":"Jump statements should not be redundant","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Jump statements, such as <code>return</code>, <code>break</code>, <code>goto</code>, and <code>continue</code> let you change the default flow of\nprogram execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid Foo()\n{\n  goto A; // Noncompliant\n  A:\n  while (condition1)\n  {\n    if (condition2)\n    {\n      continue; // Noncompliant\n    }\n    else\n    {\n      DoTheThing();\n    }\n  }\n  return; // Noncompliant; this is a void method\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid Foo()\n{\n  while (condition1)\n  {\n    if (!condition2)\n    {\n      DoTheThing();\n    }\n  }\n}\n</pre>","debt":"1min"},{"summary":"Macros should not be redefined","type":"Code Smell","defaultSeverity":"Minor","description":"<p>A macro definition should not be redefined without marking that intent specifically by un-defining it first.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#define A 1\n#define A 2\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#define A 1\n#undef A\n#define A 2\n</pre>\n<h2>Exceptions</h2>\n<p>If the redefinition has the same value as the original one. This is consistent with most C compilers warnings.</p>\n<pre>\n#define A 1\n#define A 1\n</pre>","debt":"5min"},{"summary":"Track instances of the \"#error\" preprocessor directive being reached","type":"Code Smell","defaultSeverity":"Info","description":"<p>This rule creates a issue whenever an <code>#error</code> preprocessor directive is reached during the project's analysis. In most cases, this\nindicates that the preprocessor was badly configured. Some predefined macros or library include paths might be required to fix the configuration.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#error This is an error\n</pre>"},{"summary":"Unused type declarations should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>If a type is declared but not used, then it is unclear to a reviewer if the type is redundant or it has been left unused by mistake.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid unusedtype()\n{\n  typedef int local_Type; // Noncompliant, unused\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 0-1-5 - A project shall not contain unused type declarations. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/OYIyAQ\">CERT, MSC07-CPP.</a> - Detect and remove dead code </li>\n</ul>","debt":"10min"},{"summary":"Resources should be closed","type":"Bug","defaultSeverity":"Blocker","description":"<p>A call to the <code>fopen()</code> function must be matched with a call to <code>fclose()</code>. Otherwise, you run the risk of using up all the\nOS's file handles, which could lock up not just your program but potentially everything on the box.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint fun() {\n  FILE *f = fopen(\"file\", \"r\");\n  if (f == NULL) {\n    return -1;\n  }\n  // ...\n  return 0; // Noncompliant, file f has not been closed\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint fun() {\n  FILE *f = fopen(\"file\", \"r\");\n  if (f == NULL) {\n    return -1;\n  }\n  // ...\n  fclose(f);\n  return 0;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/459.html\">MITRE, CWE-459</a> - Incomplete Cleanup </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/9gFqAQ\">CERT, FIO04-J.</a> - Release resources when they are no longer needed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/GAGQBw\">CERT, FIO42-C.</a> - Close files when they are no longer needed </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\">Try With Resources</a> </li>\n</ul>","debt":"5min"},{"summary":"Failed unit tests should be fixed","type":"Bug","defaultSeverity":"Major","description":"Test failures or errors generally indicate that regressions have been introduced. Those tests should be handled as soon as possible to reduce the cost to fix the corresponding regressions."},{"summary":"Skipped unit tests should be either removed or fixed","type":"Code Smell","defaultSeverity":"Major","description":"Skipped unit tests are considered as dead code. Either they should be activated again (and updated) or they should be removed."},{"summary":"Source files should not have any duplicated blocks","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as there is at least one block of duplicated code on this file","debt":"10min"},{"summary":"Source files should have a sufficient density of comment lines","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the density of comment lines on this file is less than the required threshold. The number of comment lines to be written in order to reach the required threshold is provided by each issue message."},{"summary":"Lines should have sufficient coverage by tests","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the line coverage on this file is less than the required threshold. It gives the number of lines to be covered in order to reach the required threshold."},{"summary":"Branches should have sufficient coverage by tests","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the branch coverage on this file is less than the required threshold.It gives the number of branches to be covered in order to reach the required threshold."}]}