{"types":{"Vulnerability":2,"Code Smell":252,"Bug":72,"Other":0},"rules":[{"summary":"Failed unit tests should be fixed","type":"Bug","defaultSeverity":"Major","description":"Test failures or errors generally indicate that regressions have been introduced. Those tests should be handled as soon as possible to reduce the cost to fix the corresponding regressions."},{"summary":"Skipped unit tests should be either removed or fixed","type":"Code Smell","defaultSeverity":"Major","description":"Skipped unit tests are considered as dead code. Either they should be activated again (and updated) or they should be removed."},{"summary":"Source files should not have any duplicated blocks","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as there is at least one block of duplicated code on this file","debt":"10min"},{"summary":"Source files should have a sufficient density of comment lines","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the density of comment lines on this file is less than the required threshold. The number of comment lines to be written in order to reach the required threshold is provided by each issue message."},{"summary":"Lines should have sufficient coverage by tests","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the line coverage on this file is less than the required threshold. It gives the number of lines to be covered in order to reach the required threshold."},{"summary":"Branches should have sufficient coverage by tests","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the branch coverage on this file is less than the required threshold.It gives the number of branches to be covered in order to reach the required threshold."},{"summary":"Overriding virtual functions should be declared with \"virtual\"","type":"Code Smell","defaultSeverity":"Major","description":"<p>Declaring overriding virtual functions with the virtual keyword removes the need to check the base class to determine whether a function is\nvirtual.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Base\n{\n  virtual void f();\n};\nclass Derived : public Base\n{\n  void f(); // Noncompliant, implicitly declared \"virtual\"\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Base\n{\n  virtual void f();\n};\nclass Derived : public Base\n{\n  virtual void f(); // Compliant, explicitly declared \"virtual\"\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 10-3-2 - Each overriding virtual function shall be declared with the virtual keyword. </li>\n</ul>\n<h3>See also</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=cpp%3AS3471'>S3471</a> </li>\n</ul>","debt":"5min"},{"summary":"Boolean expressions should not be gratuitous","type":"Code Smell","defaultSeverity":"Major","description":"<p>If a boolean expression doesn't change the evaluation of the condition, then it is entirely unnecessary, and can be removed. If it is gratuitous\nbecause it does not match the programmer's intent, then it's a bug and the expression should be fixed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\na = true;\nif (a) { // Noncompliant\n  doSomething();\n}\n\nif (b &amp;&amp; a) { // Noncompliant; \"a\" is always \"true\"\n  doSomething();\n}\n\nif (c || !a) { // Noncompliant; \"!a\" is always \"false\"\n  doSomething();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\na = true;\nif (foo(a)) {\n  doSomething();\n}\n\nif (b) {\n  doSomething();\n}\n\nif (c) {\n  doSomething();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. </li>\n  <li> MISRA C:2012, 14.3 - Controlling expressions shall not be invariant </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/489\">MITRE, CWE-489</a> - Leftover Debug Code </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/571\">MITRE, CWE-571</a> - Expression is Always True </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"10min"},{"summary":"Track uses of \"TODO\" tags","type":"Code Smell","defaultSeverity":"Info","description":"<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid foo() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"},{"summary":"Accessible base classes should not be both \"virtual\" and non-virtual in the same hierarchy","type":"Bug","defaultSeverity":"Minor","description":"<p>If a base class is both <code>virtual</code> and non-virtual in a multiple inheritance hierarchy then there will be at least two copies of the base\nclass sub-object in the derived object. This may not be consistent with developer expectations.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass A {};\nclass B1: public virtual A {};\nclass B2: public virtual A {};\nclass B3: public A {};\nclass C: public B1, B2, B3 {}; // Noncompliant, A is both virtual (through B1 and B2) and non-virtual (through B3)\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass A {};\nclass B1: public virtual A {};\nclass B2: public virtual A {};\nclass B3: public virtual A {};\nclass C: public B1, B2, B3 {}; // Compliant, A is always virtual\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 10-1-3 - An accessible base class shall not be both virtual and non-virtual in the same hierarchy. </li>\n</ul>","debt":"10min"},{"summary":"Track uses of \"FIXME\" tags","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>FIXME</code> tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint divide(int numerator, int denominator) {\n  return numerator / denominator;              // FIXME denominator value might be  0\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"},{"summary":"Deprecated code should be removed","type":"Code Smell","defaultSeverity":"Info","description":"<p>This rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// C++14 attribute\n[[deprecated]] // Noncompliant\nvoid fun();\n\n// GNU attribute\n__attribute__((deprecated)) // Noncompliant\nvoid fun();\n\n// Microsoft attribute\n__declspec(deprecated) // Noncompliant\nvoid fun();\n</pre>","debt":"10min"},{"summary":"\"abort\", \"exit\", \"getenv\" and \"system\" from <stdlib.h> should not be used","type":"Bug","defaultSeverity":"Critical","description":"<p><code>&lt;stdlib.h&gt;</code>'s <code>abort</code>, <code>exit</code>, <code>getenv</code>, and <code>system</code> have undefined, and\nimplementation-defined behaviors, and should therefore be used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;stdlib.h&gt;\n\nvoid f( ) {\n  exit(0); // Noncompliant\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.11 - The library functions abort, exit, getenv and system from library &lt;stdlib.h&gt; shall not be used. </li>\n  <li> MISRA C++:2008, 18-0-3 - The library functions abort, exit, getenv and system from library &lt;cstdlib&gt; shall not be used. </li>\n  <li> MISRA C:2012, 21.8 - The library functions abort, exit, getenv and system of &lt;stdlib.h&gt; shall not be used </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/1IAg\">CERT, ENV33-C.</a> - Do not call system() </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/5oEyAQ\">CERT, ENV02-CPP.</a> - Do not call system() if you do not need a command\n  processor </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/2gDOAQ\">CERT, ERR50-CPP.</a> - Do not abruptly terminate the program </li>\n</ul>","debt":"10min"},{"summary":"Enumeration names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared naming conventions allow teams to collaborate efficiently. This rule checks that all <code>enum</code> names match a provided regular\nexpression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With default provided regular expression <code>[A-Z][a-zA-Z0-9]++</code>:</p>\n<pre>\nenum someEnumeration { // Noncompliant\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nenum SomeEnumeration {\n};\n</pre>","debt":"5min"},{"summary":"\"<signal.h>\" should not be used","type":"Bug","defaultSeverity":"Critical","description":"<p>Signal handling contains implementation-defined and undefined behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;signal.h&gt; /* Noncompliant */\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.8 - The signal handling facilities of &lt;signal.h&gt; shall not be used. </li>\n  <li> MISRA C:2012, 21.5 - The standard header file &lt;signal.h&gt; shall not be used </li>\n</ul>","debt":"4h"},{"summary":"Destructors should not be called explicitly","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Destructors are invoked automatically when control leaves the scope in which the object was created. Add an <em>explicit</em> destructor call to\nthat, and you end up with undefined behavior because the automatic destructor invocation will be invoked on an object that no longer exists. However\nsometimes it is acceptable to have destructor calls for some specific use-cases, i.e. when it is desired to destroy the object but without releasing\nthe memory.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nMyClass mc;\n//...\nmc.~MyClass();  // Noncompliant\n</pre>","debt":"2min"},{"summary":"Classes should not be derived from virtual bases","type":"Bug","defaultSeverity":"Minor","description":"<p>The use of virtual base classes can introduce a number of undefined and potentially confusing behaviours. The use of virtual bases is not\nrecommended.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass B {};\nclass D: public virtual B {}; // Noncompliant, B is a virtual base\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 10-1-1 - Classes should not be derived from virtual bases. </li>\n</ul>","debt":"10min"},{"summary":"Enumeration values should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all enumeration values match a provided regular\nexpression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With default provided regular expression:</p>\n<pre>\nenum SomeEnumeration {\n    some  // Non-Compliant\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nenum SomeEnumeration {\n    SOME\n};\n</pre>","debt":"5min"},{"summary":"C-style and functional notation casts should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>C++ allows the traditional C-style casts [E.G. <code>(int) f</code>] and functional notation casts [E.G. <code>int(f)</code>], but adds its own\nforms:</p>\n<ul>\n  <li> <code>static_cast&lt;type&gt;(expression)</code> </li>\n  <li> <code>const_cast&lt;type&gt;(expression)</code> </li>\n  <li> <code>dynamic_cast&lt;type&gt;(expression)</code> </li>\n  <li> <code>reinterpret_cast&lt;type&gt;(expression)</code> </li>\n</ul>\n<p>C-style casts and functional notation casts are largely functionally equivalent. However, when they do not invoke a converting constructor, C-style\ncasts are capable of performing dangerous conversions between unrelated types and of changing a variable's <code>const</code>-ness. Attempt to do\nthese things with an explicit C++-style cast, and the compiler will catch the error. Use a C-style or functional notation cast, and it cannot.</p>\n<p>Additionally, C++-style casts are preferred because they are visually striking. The visual subtlety of a C-style or functional cast may mask that a\ncast has taken place, but a C++-style cast draws attention to itself, and makes the the programmer's intention explicit.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;iostream&gt;\n\nclass Base { };\n\nclass Derived: public Base\n{\npublic:\n  int a;\n};\n\nvoid DoSomethingElse(Derived *ptr)\n{\n  ptr-&gt;a = 42;\n}\n\nvoid DoSomething(const Base *ptr)\n{\n  Derived* derived = (Derived*)ptr; // Noncompliant; inadvertently removes constness\n  DoSomethingElse(derived);\n}\n\nint main(int argc, char* argv[])\n{\n  Derived *ptr = new Derived();\n  ptr-&gt;a = 1337;\n\n  DoSomething(ptr);\n\n  std::cout &lt;&lt; ptr-&gt;a &lt;&lt; std::endl; /* 1337 was expected, but 42 is printed */\n\n  return 0;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n/* ... */\n\nvoid DoSomething(const Base *ptr)\n{\n  /* error: static_cast from type 'const Base*' to type 'Derived*' casts away qualifiers */\n  Derived* derived = static_cast&lt;Derived*&gt;(ptr); // Compliant. Compile fails with above error\n  DoSomethingElse(derived);\n}\n\n/* ... */\n</pre>\n<h2>Exceptions</h2>\n<p>Void casts and explicit constructor calls are allowed.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 5-2-4 - C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not\n  be used. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/9wM\">CERT, EXP05-CPP.</a> - Do not use C-style casts </li>\n</ul>","debt":"15min"},{"summary":"Lines should not end with trailing whitespaces","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Trailing whitespaces are simply useless and should not stay in code. They may generate noise when comparing different versions of the same\nfile.</p>\n<p>If you encounter issues from this rule, this probably means that you are not using an automated code formatter - which you should if you have the\nopportunity to do so. </p>","debt":"1min"},{"summary":"Conditionally executed blocks should be reachable","type":"Bug","defaultSeverity":"Major","description":"<p>Conditional expressions which are always <code>true</code> or <code>false</code> can lead to dead code. Such code is always buggy and should never\nbe used in production.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\na = false;\nif (a) { // Noncompliant\n  doSomething(); // never executed\n}\n\nif (!a || b) { // Noncompliant; \"!a\" is always \"true\", \"b\" is never evaluated\n  doSomething();\n} else {\n  doSomethingElse(); // never executed\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule will not raise an issue when the condition is an integer constant or a <code>const</code> variable of integer type.</p>\n<p>In these cases it is obvious the code is as intended.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. </li>\n  <li> MISRA C:2012, 14.3 - Controlling expressions shall not be invariant </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/570.html\">MITRE, CWE-570</a> - Expression is Always False </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/571\">MITRE, CWE-571</a> - Expression is Always True </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"15min"},{"summary":"\"sizeof\" should not be used on expressions that contain side effects","type":"Bug","defaultSeverity":"Major","description":"<p>A possible programming error in C++ is to apply the <code>sizeof</code> operator to an expression and expect the expression to be evaluated.\nHowever, the expression is not evaluated because <code>sizeof</code> only acts on the <em>type</em> of the expression. To avoid this error,\n<code>sizeof</code> should not be used on expressions that would contain side effects if they were used elsewhere, since the side effects will not\noccur.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nj = sizeof( i = 1234 ); // Noncompliant - j is set to the sizeof the type of i which is an int. i is not set to 1234.\n\nj = sizeof ( b[i++] ); // Noncompliant - i won't be incremented.\n\nj = sizeof( isPtr(e) ); // Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ni = 1234;\nj = sizeof( i );\n\ni++;\nj = sizeof ( b[i] );\n\nj = sizeof( isPtr(e) );\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.3 - The sizeof operator shall not be used on expressions that contain side effects. </li>\n  <li> MISRA C++:2008, 5-3-4 - Evaluation of the operand to the sizeof operator shall not contain side effects. </li>\n  <li> MISRA C:2012, 13.6 - The operand of the sizeof operator shall not contain any expression which has potential side effects </li>\n</ul>","debt":"30min"},{"summary":"\"typedef\" should be used for function pointers","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Function pointer syntax can be hard on the eyes, particularly when one function is used as a parameter to another. Providing and using a\n<code>typedef</code> instead can make code easier to read, and should be preferred.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nextern void (*signal(int, void(*)(int)))(int);\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntypedef void (*SignalHandler)(int signum);\nextern SignalHandler signal(int signum, SignalHandler handler);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/fwAhAQ\">CERT, DCL05-CPP.</a> - Use typedefs to improve code readability </li>\n</ul>","debt":"15min"},{"summary":"Pure \"virtual\" functions should not override non-pure \"virtual\" functions","type":"Code Smell","defaultSeverity":"Critical","description":"<p>A <code>virtual</code> function has an implementation that <em>may</em> be replaced in a child class. A pure <code>virtual</code> has no\nimplementation, and <em>must</em> be implemented in child classes.</p>\n<p>Hiding a base class implementation with a \"pure implementation\" (<code>=0</code>) is sure to confuse extenders, who may not be aware of the base\nclass' implementation. Instead, they'll see there's no implementation in the class they're extending and assume that none exists. When that base class\nimplementation contains crucial functionality such as freeing resources, this could cause future users of the class to introduce bugs.</p>\n<p>This rule raises an issue if a pure virtual function overrides a virtual function that is not pure.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct A {\n  virtual void func1();\n  virtual void func2() = 0;\n};\n\nstruct B : A {\n  virtual void func1() = 0; // Noncompliant; override non-pure virtual\n  virtual void func2() = 0; // Compliant; but useless\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct A {\n  virtual void func1();\n  virtual void func2() = 0;\n};\n\nstruct B : A {\n  virtual void func1(); // Compliant; non-pure virtual\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 10-3-3 - A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual. </li>\n</ul>","debt":"20min"},{"summary":"Trigraphs should not be used","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Trigraphs are denoted by a sequence of 2 question marks followed by a specified third character (e.g. ??- represents a '~' (tilde) character and\n??) represents a ']'). They can cause accidental confusion with other uses of two question marks.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstatic const char str[] = \"(Date should be in the form ??-??-??)\"; // Noncompliant. Evaluates to \"(Date should be in the form ~~]\"\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstatic const char str[] = \"(Date should be in the form ?\" \"?-?\" \"?-?\" ?)\";  // adjacent string literals concatenated at compile time\nstatic const char str2[] = \"(Date should be in the form ?-?-?)\"; // problem avoided by eliminating 2nd '?' in each sequence\nstatic const char str3[] = \"(Date should be in the form ? ?-? ?-? ?)\"; // problem avoided by spacing '?'s out\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 4.2 - Trigraphs shall not be used </li>\n  <li> MISRA C++:2008, 2-3-1 - Trigraphs shall not be used </li>\n  <li> MISRA C:2012, 4.2 - Trigraphs shall not be used </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/nAE_\">CERT, PRE07-C.</a> - Avoid using repeated question marks </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KAAhAQ\">CERT, PRE07-CPP.</a> - Avoid using repeated question marks </li>\n</ul>","debt":"15min"},{"summary":"\"operator=\" should check for assignment to self","type":"Bug","defaultSeverity":"Minor","description":"<p><code>operator=</code> must ensure that the object is not being reassigned to itself before performing the operation. If this check is not\nperformed, a self-assignment could result in null pointer dereferences at worst, and wasted operations at best. Therefore <code>operator=</code> must\nalways check for assignment to self before proceeding with the assignment.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass MyClass\n{\n  private:\n  int someVal;\n  char* pData;\n\n  MyClass&amp; operator=(const MyClass&amp; rhs)\n  {\n    this-&gt;someVal = rhs.someVal;               // useless operation in self-assignment\n    delete [] pData;                          // data is lost in self-assignment\n    pData = new char[strlen(rhs.pData) +1];   // null pointer dereference in self-assignment\n    strcpy(pData, rhs.pData);\n\n    return (*this);\n  }\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass\n{\n  private:\n  int someVal;\n  char* pData;\n\n  MyClass&amp; operator=(const MyClass&amp; rhs)\n  {\n    if (this != &amp;rhs)\n    {\n      this-&gt;someVal = rhs.someVal;\n      delete [] pData;\n      pData = new char[strlen(rhs.pData) +1];\n      strcpy(pData, rhs.pData);\n    }\n    return (*this);\n  }\n};\n</pre>","debt":"2min"},{"summary":"\"setjmp\" and \"longjmp\" should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p><code>setjmp.h</code> functions allow the normal function mechanisms to be bypassed and should be used only with extreme caution, if at all. </p>\n<p>Calling <code>setjmp</code> saves the program environment into the buffer passed into the call. Later calling <code>longjmp</code> returns\nexecution to the point at which <code>setjmp</code> was called and restores the context that was saved into the buffer. But the values of non-volatile\nlocal variables after <code>longjmp</code> are indeterminate. Additionally invoking <code>longjmp</code> from a nested signal handler is undefined, as\nis <code>longjmp</code>ing back to a method that has already completed execution.</p>\n<p>This rule flags all instances of <code>setjmp</code>, <code>_setjmp</code>, <code>longjmp</code>, <code>_longjmp</code>, <code>sigsetjmp</code>,\n<code>siglongjmp</code> and <code>&lt;setjmp.h&gt;</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;setjmp.h&gt;  // Noncompliant\n\njmp_buf buf;\n\nint main(int argc, char* argv[]) {\n  int i = setjmp(buf);  // Noncompliant\n  if (i == 0) { // value of i was assigned after env was saved &amp; will be indeterminate after longjmp();\n    // normal execution\n  } else {\n    // recover\n  }\n}\n\n//...\n\nvoid fun() {\n  //...\n  longjmp(buf, 1);  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint main(int argc, char* argv[]) {\n  // normal execution\n}\n\n//...\n\nvoid fun() {\n  //...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.7 - The setjmp macro and the longjmp function shall not be used. </li>\n  <li> MISRA C++:2008, 17-0-5 - The setjmp macro and the longjmp function shall not be used. </li>\n  <li> MISRA C:2012, 21.4 - The standard header file &lt;setjmp.h&gt; shall not be used </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/rgCMAg\">CERT, MSC22-C.</a> - Use the setjmp(), longjmp() facility securely </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/Kgc\">CERT, ERR52-CPP.</a> - Do not use setjmp() or longjmp() </li>\n</ul>","debt":"1d"},{"summary":"Limited dependence should be placed on operator precedence rules in expressions","type":"Code Smell","defaultSeverity":"Major","description":"<p>The rules of operator precedence are complicated and can lead to errors. For this reason, parentheses should be used for clarification in complex\nstatements. However, this does not mean that parentheses should be gratuitously added around every operation.</p>\n<p>Parentheses are not needed:</p>\n<ul>\n  <li> with a unary operator </li>\n  <li> when all the operators in an expression are the same </li>\n  <li> when only a single operator is involved </li>\n  <li> around the right-hand side of an assignment operator unless the right-hand side itself contains an assignment </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nx = a + b;\nx = a * -1;\nx = a + b + c;\nx = f ( a + b, c );\n\nx = a == b ? a : a - b; // Noncompliant\nx = a + b - c + d; // Noncompliant\nx = a * 3 + c + d; // Noncompliant\n\nif (a = f(b,c) == true) { ... } // Noncompliant; == evaluated first\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nx = a + b;\nx = a * -1;\nx = a + b + c;\nx = f ( a + b, c );\n\nx = ( a == b ) ? a : ( a - b );\nx = ( a + b ) - ( c + d );\nx = ( a * 3 ) + c + d;\n\nif ( (a = f(b,c)) == true) { ... }\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.1 - Limited dependence should be placed on C's operator precedence rules in expressions </li>\n  <li> MISRA C:2004, 12.2 - The value of an expression shall be the same under any order of evaluation that the standard permits. </li>\n  <li> MISRA C:2004, 12.5 - The operands of a logical &amp;&amp; or || shall be primary-expressions. </li>\n  <li> MISRA C++:2008, 5-0-1 - The value of an expression shall be the same under any order of evaluation that the standard permits. </li>\n  <li> MISRA C++:2008, 5-0-2 - Limited dependence should be placed on C++ operator precedence rules in expressions </li>\n  <li> MISRA C++:2008, 5-2-1 - Each operand of a logical &amp;&amp; or || shall be a postfix-expression. </li>\n  <li> MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/_wI\">CERT, EXP00-C.</a> - Use parentheses for precedence of operation </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/VoAyAQ\">CERT, EXP00-CPP.</a> - Use parentheses for precedence of operation </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/9wHEAw\">CERT, EXP53-J.</a> - Use parentheses for precedence of operation </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/783.html\">MITRE, CWE-783</a> - Operator Precedence Logic Error </li>\n</ul>","debt":"2min"},{"summary":"\"errno\" should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p><code>errno</code> is a facility of C++ which should in theory be useful, but which in practice is poorly defined by ISO/IEC 14882:2003. A non-zero\nvalue may or may not indicate that a problem has occurred; therefore <code>errno</code> shall not be used.</p>\n<p>Even for those functions for which the behaviour of <code>errno</code> is well defined, it is preferable to check the values of inputs before\ncalling the function rather than relying on using <code>errno</code> to trap errors.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;cstdlib&gt;\n#include &lt;cerrno&gt;\n\nvoid f1 ( const char_t * str )\n{\n  errno = 0; // Noncompliant\n  int32_t i = atoi ( str );\n  if ( 0 != errno ) // Noncompliant\n  {\n    // handle error case???\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.5 - The error indicator errno shall not be used. </li>\n  <li> MISRA C++:2008, 19-3-1 - The error indicator errno shall not be used. </li>\n</ul>\n<h3>See Also</h3>\n<ul>\n  <li> ISO/IEC 14882:2003 </li>\n</ul>","debt":"10min"},{"summary":"Dynamic heap memory allocation should not be used","type":"Bug","defaultSeverity":"Critical","description":"<p>The use of dynamic memory can lead to out-of-storage run-time failures, which are undesirable.</p>\n<p>The built-in <code>new</code> and <code>delete</code> operators, other than the placement versions, use dynamic heap memory. The functions\n<code>calloc</code>, <code>malloc</code>, <code>realloc</code> and <code>free</code> also use dynamic heap memory.</p>\n<p>There is a range of unspecified, undefined and implementation-defined behaviour associated with dynamic memory allocation, as well as a number of\nother potential pitfalls. Dynamic heap memory allocation may lead to memory leaks, data inconsistency, memory exhaustion, non-deterministic behaviour,\netc.</p>\n<p>Note that some implementations may use dynamic heap memory allocation to implement other functions (for example, functions in the library\n<code>cstring</code>). If this is the case, then these functions shall also be avoided.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint *b;\nvoid initialize()\n{\n  b = (int *b) alloc ( 1024 * sizeof ( int ) ); // Noncompliant, could lead to an out-of-storage run-time failure.\n  if( b == 0 )\n  {\n    // handle case when dynamic allocation failed.\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint b[1024]; // Compliant solution.\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.4 - Dynamic heap memory allocation shall not be used. </li>\n  <li> MISRA C++:2008, 18-4-1 - Dynamic heap memory allocation shall not be used. </li>\n  <li> MISRA C:2012, 21.3 The memory allocation and deallocation functions of &lt;stdlib.h&gt; shall not be used </li>\n</ul>","debt":"1h"},{"summary":"\"goto\" statement should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>goto</code> is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such\nas <code>if</code>, <code>for</code>, <code>while</code>, <code>continue</code> or <code>break</code> should be used instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint i = 0;\nloop:\n  printf(\"i = %d\\n\", i);\n  i++;\n  if (i &lt; 10){\n    goto loop; // Noncompliant\n  }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfor (int i = 0; i &lt; 10; i++) {\n  printf(\"i = %d\\n\", i);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.4 - The goto statement shall not be used. </li>\n  <li> MISRA C:2012, 15.1 - The goto statement should not be used </li>\n</ul>","debt":"10min"},{"summary":"\"offsetof\" macro from <stddef.h> should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p><code>offsetof</code> can lead to undefined behavior when the argument types are incompatible or when bit fields are used. Therefore\n<code>offsetof</code> should be avoided.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;stddef.h&gt;\n\nstruct A\n{\n  int32_t i;\n};\n\nvoid f1 ( )\n{\n  offsetof ( A, i ); // Noncompliant\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.6 - The macro offsetof, in library &lt;stddef.h&gt;, shall not be used. </li>\n  <li> MISRA C++:2008, 18-2-1 - The macro offsetof, in library &lt;stddef.h&gt;, shall not be used. </li>\n</ul>","debt":"20min"},{"summary":"\"atof\", \"atoi\" and \"atol\" from <stdlib.h> should not be used","type":"Bug","defaultSeverity":"Critical","description":"<p><code>&lt;stdlib.h&gt;</code>'s <code>atof</code>, <code>atoi</code>, and <code>atol</code> functions, which convert strings to numbers, have\nundefined behavior when the strings cannot be converted, and should therefore be avoided.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint converter (const char * numstr) {\n  return atoi(numstr); // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint converter (const char * numstr) {\n  return strtol(numstr, NULL, 10);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.10 - The library functions atof, atoi and atol from library &lt;stdlib.h&gt; shall not be used. </li>\n  <li> MISRA C++:2008, 18-0-2 - The library functions atof, atoi and atol from library &lt;cstdlib&gt; shall not be used. </li>\n  <li> MISRA C:2012, 21.7 - The atof, atoi, atol and atoll functions of &lt;stdlib.h&gt; shall not be used </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/6AQ\">CERT, ERR34-C.</a> - Detect errors when converting a string to a number </li>\n</ul>","debt":"10min"},{"summary":"Loops should not have more than one \"break\" or \"goto\" statement","type":"Code Smell","defaultSeverity":"Major","description":"<p>Restricting the number of exits from a loop is done in the interests of good structured programming. One <code>break</code> or <code>goto</code>\nstatement is acceptable in a loop since this allows, for example, for dual-outcome loops or optimal coding.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold of 1:</p>\n<pre>\nfor (int i = 0; i &lt; 10; i++) {\n  if (...) {\n    break;      //  Compliant\n  }\n  else if (...) {\n    break;      //  Non-compliant - second jump from loop\n  }\n  else {\n    ...\n  }\n}\nwhile (...) {\n  if (...) {\n    break;      // Compliant\n  }\n  if (...) {\n    break;      // Non-compliant - second jump from loop\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfor (int i = 0; i &lt; 10; i++) {\n  if (...) {\n    break;      //  Compliant\n  }\n}\nwhile (...) {\n  if (...) {\n    break;    // Compliant\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.6 - For any iteration statement there shall be at most one break statement used for loop termination. </li>\n  <li> MISRA C++:2008, 6-6-4 - For any iteration statement there shall be no more than one break or goto statement used for loop termination. </li>\n  <li> MISRA C:2012, 15.4 - There should be no more than one break or goto statement used to terminate any iteration statement </li>\n</ul>","debt":"20min"},{"summary":"Boolean operators should have boolean operands","type":"Bug","defaultSeverity":"Major","description":"<p>The use of operands with types other than <code>bool</code> with these operators is unlikely to be meaningful (or intended). This rule allows the\ndetection of such uses, which often occur because the logical operators (<code>&amp;&amp;</code>, <code>||</code> and <code>!</code>) can be easily\nconfused with the bitwise operators (<code>&amp;</code>, <code>|</code> and <code>~</code>).</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ( 1 &amp;&amp; ( c &lt; d ) ) // Noncompliant\nif ( ( a &lt; b ) &amp;&amp; ( c + d ) ) // Noncompliant\nif ( u8_a &amp;&amp; ( c + d ) ) // Noncompliant\nif ( !0 ) // Noncompliant, always true\nif ( !ptr ) // Noncompliant\nif ( ( a &lt; b ) &amp;&amp; ( c &lt; d ) ) // Compliant\nif ( !false ) // Compliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif ( 1 != 0 &amp;&amp; ( c &lt; d ) ) // Compliant, but left operand is always true\nif ( ( a &lt; b ) &amp;&amp; ( c + d ) != 0 ) // Compliant\nif ( u8_a != 0 &amp;&amp; ( c + d ) != 0) // Compliant\nif ( 0 == 0 ) // Compliant, always true\nif ( ptr != NULL ) // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.6 - The operands of logical operators (&amp;&amp;, || and !) should be effectively Boolean. Expressions that are effectively\n  Boolean should not be used as operands to operators other than (&amp;&amp;, || and !). </li>\n  <li> MISRA C++:2008, 5-3-1 - Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KQHEAw\">CERT, EXP54-J.</a> - Understand the differences between bitwise and logical\n  operators </li>\n</ul>","debt":"10min"},{"summary":"Declaration specifiers should not be redundant","type":"Bug","defaultSeverity":"Major","description":"<p>Redundant declaration specifiers should be removed or corrected. Typically, they represent bugs. A specifier modifies the type or pointer to its\nleft. Only when it is at the far left does it apply to the right.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst int const * v1a; // Noncompliant; both const specifiers apply to int\nconst int const * v1b; // Noncompliant\nstatic static int v2;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst int *       v1a;  // pointer to a const int. same meaning as before but less confusing\nint const * const v1b;  // const pointer to a const int\nstatic int         v2;\n</pre>","debt":"5min"},{"summary":"Parameters should be passed in the correct order","type":"Code Smell","defaultSeverity":"Major","description":"<p>When the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when\nthe names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead\nto unexpected results.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint divide(int divisor, int dividend) {\n  return divisor / dividend;\n}\n\nvoid doTheThing() {\n  int divisor = 15;\n  int dividend = 5;\n\n  int result = divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected\n  //...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint divide(int divisor, int dividend) {\n  return divisor / dividend;\n}\n\npublic void doTheThing() {\n  int divisor = 15;\n  int dividend = 5;\n\n  int result = divide(divisor, dividend);\n  //...\n}\n</pre>","debt":"5min"},{"summary":"Atomic types should be used instead of \"volatile\" types","type":"Code Smell","defaultSeverity":"Major","description":"<p>Except for interactions with <code>extern volatile</code> variables provided by libraries, C/C++ programmers should consider <code>volatile</code>\nan esoteric feature that is best avoided. In most cases, it is used in an attempt to provide atomicity, memory ordering, or inter-thread\nsynchronization, but <code>volatile</code> does not provide those guarantees. It is only really needed for the kind of low-level code found in\nkernels, i.e. using memory-mapped I/O registers to manipulate hardware directly. </p>\n<p>According to the C standard:</p>\n<blockquote>\n  <p><code>volatile</code> is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might\n  be changed by means undetectable by an implementation.</p>\n</blockquote>\n<p>Only C11/C++11 \"atomic types\" are free from data races.</p>\n<p>This rule raises an issue when a <code>volatile</code> type is declared.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvolatile int counter; // Noncompliant\nUser * volatile vpUser; // Noncompliant; pointer is volatile\nUser volatile * pvUser;  // Compliant; User instance is volatile, not the pointer\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\natomic_int counter;\nstd::atomic&lt;User*&gt; vpUser;\nUser volatile * pvUser;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/lwBlAQ\">CERT, CON01-CPP.</a> - Do not use volatile as a synchronization primitive </li>\n</ul>","debt":"1h"},{"summary":"Unused \"private\" methods should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>private</code> methods that are never executed are dead code: unnecessary, inoperative code that should be removed. Cleaning out dead code\ndecreases the size of the maintained codebase, making it easier to understand the program and preventing bugs from being introduced.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Server {\npublic:\n  void start() { // Compliant, the member function \"start()\" is public\n    log(\"start\");\n  }\nprivate:\n  void clear() { // Noncompliant, the member function \"clear()\" is unused\n  }\n  void log(const char * msg) { // Compliant, the member function \"log()\" is used in \"start() { ... }\"\n    printf(msg);\n  }\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Server {\npublic:\n  void start() {\n    log(\"start\");\n  }\nprivate:\n  // clear() has been removed\n  void log(const char * msg) {\n    printf(msg);\n  }\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/OYIyAQ\">CERT, MSC07-CPP.</a> - Detect and remove dead code </li>\n</ul>","debt":"5min"},{"summary":"\"operator delete\" should be written along with \"operator new\"","type":"Bug","defaultSeverity":"Critical","description":"<p>Overriding <code>operator new</code> typically indicates that custom memory allocation is required for the class. When that's the case, it must be\nbalanced with custom memory deallocation in an <code>operator delete</code> method. Otherwise memory leaks will result, potentially leading to a\ndenial of service.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass AirPlane\n{\npublic:\n  void* operator new(size_t size);\n  void fly();\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass AirPlane\n{\npublic:\n  void* operator new(size_t size);\n  void operator delete(void* deadObject, size_t size);\n  void fly();\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/FYCpAQ\">CERT, DCL54-CPP.</a> - Overload allocation and deallocation functions as a pair\n  in the same scope </li>\n</ul>","debt":"15min"},{"summary":"String literals should not be immediately followed by macros","type":"Code Smell","defaultSeverity":"Major","description":"<p>C++ allows you to append a macro value onto the end of a string literal. Prior to C++11, it was possible to do this either with or without a space\nbetween the two. But with the introduction of user-defined literals in C++11, the preprocessing of string suffixes changed. To get the same string +\nmacro behavior under C++ 11, you must separate the string literal and the macro with a space. Without the space, you'll get a compile error.</p>\n<p>For the purpose of preparing for migration to C++11, this rule raises an issue when there's no space between a string literal and a macro.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#define _Hrs \" hours\"\nstatic const char* OPENING = \"7\"_Hrs; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#define _Hrs \" hours\"\nstatic const char* OPENING = \"7\" _Hrs; // there's one space after \"7\"\n</pre>","debt":"2min"},{"summary":"A \"while\" loop should be used instead of a \"for\" loop","type":"Code Smell","defaultSeverity":"Minor","description":"<p>When only the condition expression is defined in a <code>for</code> loop, and the initialization and increment expressions are missing, a\n<code>while</code> loop should be used instead to increase readability. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (;condition;) { /*...*/ }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nwhile (condition) { /*...*/ }\n</pre>","debt":"5min"},{"summary":"Functions should not contain too many return statements","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having too many return statements in a function increases the function's essential complexity because the flow of execution is broken each time a\nreturn statement is encountered. This makes it harder to read and understand the logic of the function.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold of 3:</p>\n<pre>\nint fun() {\n  if (condition1) {\n    return 1;\n  } else {\n    if (condition2) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  return 0;\n}\n</pre>","debt":"20min"},{"summary":"\"switch\" statements should cover all cases","type":"Code Smell","defaultSeverity":"Major","description":"<p>For completeness, a <code>switch</code> over the values of an <code>enum</code> must either address each value in the <code>enum</code> or contain\na <code>default</code> case. <code>switch</code> statements that are not over <code>enum</code> must end with a <code>default</code> case.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f, int i) {\n  switch (f) {  // Noncompliant; no case for KIWI\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    case 3: // Noncompliant; case value not in enum\n      // ...\n  }\n\n  switch (i) { // Noncompliant; no default\n    case 0:\n      // ...\n    case 1:\n      // ...\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    default:\n      // ...\n  }\n\n  switch (i) {\n    case 0:\n      // ...\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n</pre>\n<p>or</p>\n<pre>\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    case KIWI:\n      //...\n  }\n\n  switch (i) {\n    case 0:\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n</pre>\n<h2>See also</h2>\n<ul>\n  <li> <a href='/coding_rules#rule_key=cpp%3ASwitchWithoutDefault'>SwitchWithoutDefault</a> </li>\n</ul>","debt":"10min"},{"summary":"Try-catch blocks should not be nested","type":"Code Smell","defaultSeverity":"Major","description":"<p>Nesting <code>try</code>/<code>catch</code> or <code>@try</code>/<code>@catch</code> blocks severely impacts the readability of source code because\nit makes it too difficult to understand which block will catch which exception.</p>\n<p>This C++ example also applies to Objective-C.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntry {\n  try {                                     // Noncompliant\n    doSomething();\n  } catch (RuntimeException e) {\n    /* Ignore */\n  }\n\n  doSomethingElse();\n} catch (Exception e) {\n  /* ... */\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntry {\n  dedicatedMethod();                        // Compliant\n  doSomethingElse();\n} catch (Exception e) {\n  /* ... */\n}\n\n/* ... */\n\nprivate void dedicatedMethod() {\n  try {                                     // Compliant\n    doSomething();\n  } catch (RuntimeException e) {\n    /* Ignore */\n  }\n}\n</pre>","debt":"20min"},{"summary":"Exceptions should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>While exceptions are a common feature of modern languages, there are several reasons to avoid them:</p>\n<ul>\n  <li> They make the control flow of a program difficult to understand, because they introduce additional exit points. </li>\n  <li> The use of exceptions in new code can make that code difficult to integrate with existing, exception-free code. </li>\n  <li> They add to the size of each binary produced, thereby increasing both compile time and final executable size. </li>\n  <li> They incur a small performance penalty. </li>\n</ul>\n<p>This C++ code example also applies to Objective-C.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ndouble myfunction(char param) throw (int); // Noncompliant\ntry // Noncompliant\n{\n  do_something();\n  throw 1; // Noncompliant\n}\ncatch (...)\n{\n  // handle exception\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ndo_something();\n</pre>","debt":"20min"},{"summary":"The prefix increment/decrement form should be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Postfix increment and decrement typically involves making a copy of the object being incremented or decremented, whereas its prefix form does not.\nTherefore the prefix form is usually the more efficient form, and should be preferred.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid myFunc(int lim)\n{\n  int i;\n  for (i = 0; i &lt; lim; i++)\n  {\n    // do something\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid myFunc(int lim)\n{\n  int i;\n  for (i = 0; i &lt; lim; ++i)\n  {\n    // do something\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/TABi\">CERT, EXP18-CPP.</a> - Prefer the prefix forms of <code>++</code> and\n  <code>--</code> </li>\n</ul>","debt":"2min"},{"summary":"Rvalue references should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>Rvalue references were introduced as part of C++11. They are thus a new feature of the language, and are not yet widely understood. Using them is\ncomplicated, and code using rvalue references may be difficult to understand. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstd::vector&lt;int&gt; return_vector(void)\n{\n    std::vector&lt;int&gt; tmp {1,2,3,4,5};\n    return tmp;\n}\n\nstd::vector&lt;int&gt; &amp;&amp;rval_ref = return_vector(); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstd::vector&lt;int&gt; return_vector(void)\n{\n    std::vector&lt;int&gt; tmp {1,2,3,4,5};\n    return tmp;\n}\n\nconst std::vector&lt;int&gt;&amp; rval_ref = return_vector();\n</pre>","debt":"20min"},{"summary":"\"switch\" statements should not be nested","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Nested <code>switch</code> structures are difficult to understand because you can easily confuse the cases of an inner <code>switch</code> as\nbelonging to an outer statement. Therefore nested <code>switch</code> statements should be avoided.</p>\n<p>Specifically, you should structure your code to avoid the need for nested <code>switch</code> statements, but if you cannot, then consider moving\nthe inner <code>switch</code> to another function.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      // ...\n    case 2:\n      // ...\n    case 3:\n      switch (m) {  // Noncompliant\n    case 4:  // Bad indentation makes this particularly hard to read properly\n      // ...\n    case 5:\n      // ...\n    case 6:\n      // ...\n    }\n    case 4:\n      // ...\n    default:\n      // ...\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      // ...\n    case 2:\n      // ...\n    case 3:\n      int m2 = handle_m(m);\n    case 4:\n      // ...\n    default:\n      // ...\n  }\n}\n</pre>","debt":"10min"},{"summary":"Namespace names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all namespace names match a provided regular expression.\n</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>[a-z][a-z_0-9]*+</code>:</p>\n<pre>\nnamespace Foo // Noncompliant\n{\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nnamespace foo\n{\n}\n</pre>","debt":"10min"},{"summary":"Structures should not have too many fields","type":"Code Smell","defaultSeverity":"Major","description":"<p>A structure, such as a <code>struct</code>, <code>union</code> or <code>class</code> that grows too much tends to aggregate too many\nresponsibilities and inevitably becomes harder to understand and therefore to maintain, and having a lot of fields is an indication that a structure\nhas grown too large.</p>\n<p>Above a specific threshold, it is strongly advised to refactor the structure into smaller ones that focus on well defined topics.</p>","debt":"1h"},{"summary":"Narrow and wide string literals should not be concatenated","type":"Bug","defaultSeverity":"Major","description":"<p>Concatenation of wide and narrow string literals leads to undefined behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nwchar_t n_array[] = \"Hello\" L\"World\";     // Noncompliant\nwchar_t w_array[] = L\"Hello\" \"World\";     // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nchar_t n_array[] = \"Hello\" \"World\";     // Compliant\nwchar_t w_array[] = L\"Hello\" L\"World\";\t// Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 2-13-5 - Narrow and wide string literals shall not be concatenated. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/QIEzAg\">CERT STR10-C.</a> - Do not concatenate different type of string literals </li>\n</ul>","debt":"15min"},{"summary":"\"enum\" values should not be used as operands to built-in operators other than [ ], =, ==, !=, unary &, and the relational operators <, <=, >, >=","type":"Code Smell","defaultSeverity":"Major","description":"<p>Enumerations have implementation-defined representation and so should not be used in arithmetic contexts.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nenum { COLOUR_0, COLOUR_1, COLOUR_2, COLOUR_COUNT } colour;\nif ( COLOUR_0 == colour ) { ... }\nif ( ( COLOUR_0 + COLOUR_1 ) == colour ) { ... } // Noncompliant, arithmetic used\nif ( colour &lt; COLOUR_COUNT ) { ... }\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 4-5-2 - Expressions with type enum shall not be used as operands to builtin operators other than the subscript operator [ ],\n  the assignment operator =, the equality operators == and !=, the unary &amp; operator, and the relational operators &lt;, &lt;=, &gt;, &gt;= </li>\n</ul>","debt":"10min"},{"summary":"\"bool\" expressions should not be used as operands to built-in operators other than =, &&, ||, !, ==, !=, unary &, and the conditional operator","type":"Bug","defaultSeverity":"Major","description":"<p>The use of <code>bool</code> operands with other operators is unlikely to be meaningful (or intended). This rule allows the detection of such uses,\nwhich often occur because the logical operators (<code>&amp;&amp;</code>, <code>||</code> and <code>!</code>) can be easily confused with the bitwise\noperators (<code>&amp;</code>, <code>|</code> and <code>~</code>).</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nbool b1 = true;\nbool b2 = false;\nint8_t s8a;\nif ( b1 &amp; b2 ) // Noncompliant\nif ( ~b1 ) // Noncompliant\nif ( b1 &lt; b2 ) // Noncompliant\nif ( b1 ^ b2 ) // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif ( b1 &amp;&amp; b2 )\nif ( !b1 )\nif ( b1 == false )\nif ( b1 == b2 )\nif ( b1 != b2 )\ns8a = b1 ? 3 : 7;\n</pre>\n<h2>Exceptions</h2>\n<p>Operators <code>|=</code> and <code>&amp;=</code> are ignored when used with <code>bool</code> operands as a statement.</p>\n<pre>\nvoid test(bool b1, bool b2, int i1) {\n  b1 |= b2; // ignored\n  b1 &amp;= b2; // ignored\n  b1 &amp;= i1; // Noncompliant; right operand is not a bool\n  if (b1 |= b2) { // Noncompliant, \"|=\" on \"bool\" should not be used as expression\n    // ...\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 4-5-1 - Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator =,\n  the logical operators &amp;&amp;, ||, !, the equality operators == and !=, the unary &amp; operator, and the conditional operator. </li>\n</ul>","debt":"10min"},{"summary":"Unary minus should not be applied to an unsigned expression","type":"Bug","defaultSeverity":"Major","description":"<p>Applying the unary minus operator to an unsigned variable or expression will always yield another unsigned expression. More plainly, in some cases\nthe operation itself is meaningless, and in some other cases the result will be unexpected. In all cases it is bad practice. Therefore the unary minus\noperator should not be applied to unsigned variables or expressions.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nuint8_t a = -1U;\nint32_t b = -a; // Noncompliant; b is assigned -255\nuint32_t c = 1U;\nint64_t d = -c; // Noncompliant; d is assigned MAX_UINT\n</pre>\n<h2>Exceptions</h2>\n<p>This rule ignores <code>-1U</code> because it is commonly used as shorthand for <code>MAX_UINT</code>.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.9 - The unary minus operator shall not be applied to an expression whose underlying type is unsigned. </li>\n  <li> MISRA C++:2008, 5-3-2 - The unary minus operator shall not be applied to an expression whose underlying type is unsigned. </li>\n  <li> MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type </li>\n</ul>","debt":"30min"},{"summary":"Comma operator should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>The comma operator takes two expressions, executes them from left to right and returns the result of the second one. Use of this operator is\ngenerally detrimental to the readability and reliability of code, and the same effect can be achieved by other means.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ni = a += 2, a + b;  // What's the value of i ?\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\na +=  2;\ni = a + b;\n</pre>\n<h2>Exceptions</h2>\n<p>Use of comma operator is tolerated in initialization and increment expressions of <code>for</code> loops.</p>\n<pre>\nfor(i = 0, j = 5; i &lt; 6; i++, j++) { ... }\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.10 - The comma operator shall not be used. </li>\n  <li> MISRA C++:2008, 5-18-1 - The comma operator shall not be used. </li>\n  <li> MISRA C:2012, 12.3 - The comma operator should not be used </li>\n</ul>","debt":"5min"},{"summary":"Cognitive Complexity of functions should not be too high","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>","debt":"5min"},{"summary":"Flexible array members should not be declared","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Flexible array members are most likely to be used in conjunction with dynamic memory allocation.</p>\n<p>The presence of flexible array members modifies the behaviour of the <code>sizeof</code> operator in ways that might not be expected by a\nprogrammer. The assignment of a structure that contains a flexible array member to another structure of the same type may not behave in the expected\nmanner as it copies only those elements up to but not including the start of the flexible array member.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;stdlib.h&gt;\nstruct s\n{\n  uint16_t len;\n  uint32_t data[ ]; // Noncompliant - flexible array member\n} str;\n\nstruct s *copy ( struct s *s1 )\n{\n  struct s *s2 = malloc ( sizeof ( struct s ) + ( s1-&gt;len * sizeof ( uint32_t ) ) );\n  /* Omit malloc ( ) return check for brevity */\n  *s2 = *s1; /* Only copies s1-&gt;len */\n  return s2;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 18.7 - Flexible array members shall not be declared. </li>\n</ul>","debt":"10min"},{"summary":"\"operator=\" should return a reference to \"this\"","type":"Code Smell","defaultSeverity":"Major","description":"<p>Returning a reference to the current object from <code>operator=</code> allows operator chaining, such as <code>a = b = c = ...</code>. </p>\n<p>Additionally, it is the convention and common expectation that <code>operator=</code> will return a reference to the left-hand side of the\noperation, i.e. <code>*this</code>. Ignoring that convention in a class will make it difficult for callers to use the class.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nString&amp; String::operator=(const String&amp; rhs)\n{\n  if (&amp;rhs != this)\n  {\n    // ...\n  }\n  return rhs;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nString&amp; String::operator=(const String&amp; rhs)\n{\n  if (&amp;rhs != this)\n  {\n    // ...\n  }\n  return(*this);     // return reference to left-hand object\n}\n</pre>","debt":"20min"},{"summary":"Member variables should not be \"protected\"","type":"Code Smell","defaultSeverity":"Critical","description":"<p>If a class is just a data store without logic, it can safely contain only <code>public</code> member variables and no member functions. Otherwise,\ndata members are tightly coupled to the class' logic, and encapsulation must be used. In this case, having only <code>private</code> member variables\nensures that logic is defined only in the member functions of the class. Structuring it this way makes It easier to guarantee integrity and easier for\nmaintainers to understand the code.</p>\n<p>But when an object provides encapsulation by using <code>protected</code> member variables, data integrity logic can be spread through the class\nand all its derived class, becoming a source of complexity and that will be error prone for maintainers and extenders. </p>\n<p>That's why <code>protected</code> member variables should be changed to <code>private</code> and manipulated exclusively through\n<code>public</code> or <code>protected</code> member functions of the base class.</p>\n<p>This rule raises an issue when a <code>class</code> or <code>struct</code> contains <code>protected</code> member variables.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Stat {\npublic:\n  long int getCount() {\n    return count;\n  }\nprotected:\n  long int count = 0; // Noncompliant; expose a protected member variable.\n                      // By just looking at \"Stat\" class, it's not possible to be sure that \"count\"\n                      // is modified properly, we also need to check all derived classes\n};\n\nclass EventStat : public Stat {\npublic:\n  void onEvent() {\n    if (count &lt; LONG_MAX) {\n      count++;\n    }\n  }\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Stat {\npublic:\n  long int getCount() {\n    return count;\n  }\nprotected:\n  void increment() { // Compliant; expose a protected member function\n    if (count &lt; LONG_MAX) {\n      count++;\n    }\n  }\nprivate:\n  long int count = 0; // member variable is private\n};\n\nclass EventStat : public Stat {\npublic:\n  void onEvent() {\n    increment();\n  }\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 11-0-1 - Member data in non-POD class types shall be private. </li>\n</ul>","debt":"20min"},{"summary":"Polymorphic base class destructor should be either public virtual or protected non-virtual","type":"Code Smell","defaultSeverity":"Major","description":"<p>When a class with <code>virtual</code> methods but no <code>virtual</code> destructor is used as a base class, surprises can occur if pointers to\ninstances of this class are used. Specifically, if an instance of a derived class is assigned to a base class pointer, and <code>delete</code> is\ncalled, only the base class destructor will be invoked, so the object will only be partially destroyed. The resulting memory leak could eventually tie\nup enough resources to cause a denial of service.</p>\n<p>If it is not expected for base class pointers to be deleted, then the destructor should be made <code>protected</code> to avoid such a misuse.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Base {\npublic:\n  Base() {}\n  ~Base() {} // Noncompliant; should be virtual to match virtual methods\n  virtual void doSomething() {}\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Base {\npublic:\n  Base() {}\n  virtual ~Base() {}\n  virtual void doSomething() {}\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/UQBO\">CERT, OOP52-CPP.</a> - Do not delete a polymorphic object without a virtual\n  destructor </li>\n  <li> <a href=\"http://www.gotw.ca/publications/mill18.htm\">Virtuality article</a> </li>\n</ul>","debt":"10min"},{"summary":"Destructors should be declared \"noexcept\"","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Throwing an exception from a destructor results in undefined behavior, meaning that your program could be terminated abruptly without neatly\ndestroying others objects.</p>\n<p>Thus destructors should never <code>throw</code> exceptions. Instead, they should catch and handle those thrown by the functions they call, and be\nexplicitly declared <code>noexcept</code>.</p>\n<p>This rule raises an issue when a destructor is not explicitly specified to be <code>noexcept</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct C {\n  /* ... */\n  ~C() { // Noncompliant\n    /* ... */\n  }\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct C {\n  /* ... */\n  ~C() noexcept {\n    /* ... */\n  }\n};\n</pre>","debt":"2min"},{"summary":"Line-splicing should not be used in \"//\" comments","type":"Bug","defaultSeverity":"Minor","description":"<p>Line-splicing occurs when the \\ character is immediately followed by a new-line character. If the source line containing a <code>//</code> comment\nends with a '\\', the next line becomes part of the comment. This may result in unintentional removal of code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid f ( void )\n{\n  int x = 0; // comment \\\n  if (x)\n  {\n    ++x; /* This is always executed */\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 3.2 - Line-splicing shall not be used in // comments </li>\n</ul>","debt":"2min"},{"summary":"\"new\" and \"delete\" should be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The <code>malloc</code>, <code>realloc</code>, <code>calloc</code> and <code>free</code> instructions are used to dynamically allocate memory in\nthe heap. That can lead to conflicts with the use of the <code>new</code> and <code>delete</code> operators introduced in C++.</p>\n<p>Technically, memory allocated by <code>new</code> comes from the 'Free Store' while memory allocated by <code>malloc</code> comes from the 'Heap'.\nWhether these two areas are the same is an implementation detail, which is another reason that <code>malloc</code> and <code>new</code> can not be\nmixed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstring* pStringArray1 = static_cast&lt;string*&gt;(malloc(10 * sizeof(string)));\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstring* pStringArray1 = new string[10];\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/4AY\">CERT, MEM08-CPP.</a> - Use new and delete rather than raw memory allocation and\n  deallocation </li>\n</ul>","debt":"10min"},{"summary":"Appropriate memory de-allocation should be used","type":"Bug","defaultSeverity":"Blocker","description":"<p>The same form that was used to create an object should always be used to delete it. Specifically, arrays should be deleted with <code>delete\n[]</code> and objects should be deleted with <code>delete</code>. To do otherwise will cause segfaults (in the case of deleting an object with\n<code>delete []</code>) and memory leaks (in the case of deleting an array with <code>delete</code>).</p>\n<p>This is also true when memory was allocated with <code>malloc</code>, or one of its variants, then it must be released using <code>free()</code>\nnot <code>delete</code>. Similarly memory allocated by <code>new</code> can not be released using <code>free</code> instead of\n<code>delete</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstring* _pString1 = new string;\nstring* _pString2 = new string[100];\nchar* _pChar = (char *) malloc(100);\n\ndelete [] _pString1; // Noncompliant; an object was declared but array deletion is attempted\ndelete _pString2;  // Noncompliant; an array was declared but an object (the first in the array) is deleted\ndelete _pChar; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstring* _pString1 = new string;\nstring* _pString2 = new string[100];\nchar* _pChar = (char *) malloc(100);\n\ndelete _pString1;\ndelete [] _pString2;\nfree(_pChar);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/dQAGCQ\">CERT, MEM51-CPP.</a> - Properly deallocate dynamically allocated resources\n  </li>\n</ul>","debt":"10min"},{"summary":"Redundant pairs of parentheses should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>The use of parentheses, even those not required to enforce a desired order of operations, can clarify the intent behind a piece of code. But\nredundant pairs of parentheses could be misleading, and should be removed. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint x = (y / 2 + 1);   //Compliant even if the parenthesis are ignored by the compiler\n\nif (a &amp;&amp; ((x+y &gt; 0))) {  // Noncompliant\n  //...\n}\n\nreturn ((x + 1));  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint x = (y / 2 + 1);\n\nif (a &amp;&amp; (x+y &gt; 0)) {\n  //...\n}\n\nreturn (x + 1);\n</pre>\n<h2>Exceptions</h2>\n<p>When the result of an assignment is used as a condition, clang raises a warning to make sure the purpose was not to use <code>==</code> in place of\n<code>=</code>. Adding some parentheses around the assignment is a common way to silence this clang warning. So, no issue is raised in such case.</p>\n<pre>\nif ((x = 7)) {} // Compliant\n</pre>","debt":"1min"},{"summary":"Multiline blocks should be enclosed in curly braces","type":"Code Smell","defaultSeverity":"Major","description":"<p>Curly braces can be omitted from a one-line block, such as with an <code>if</code> statement or <code>for</code> loop, but doing so can be\nmisleading and induce bugs. </p>\n<p>This rule raises an issue when the whitespacing of the lines after a one line block indicates an intent to include those lines in the block, but\nthe omission of curly braces means the lines will be unconditionally executed once.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition)\n  firstActionInBlock();\n  secondAction();  // Noncompliant; executed unconditionally\nthirdAction();\n\nif (condition) firstActionInBlock(); secondAction();  // Noncompliant; secondAction executed unconditionally\n\nif (condition) firstActionInBlock();  // Noncompliant\n  secondAction();  // Executed unconditionally\n\nif (condition); secondAction();  // Noncompliant; secondAction executed unconditionally\n\nString str = null;\nfor (int i = 0; i &lt; array.length; i++)\n  str = array[i];\n  doTheThing(str);  // Noncompliant; executed only on last array element\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition) {\n  firstActionInBlock();\n  secondAction();\n}\nthirdAction();\n\nString str = null;\nfor (int i = 0; i &lt; array.length; i++) {\n  str = array[i];\n  doTheThing(str);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/483.html\">MITRE, CWE-483</a> - Incorrect Block Delimitation </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/3wHEAw\">CERT, EXP52-J.</a> - Use braces for the body of an if, for, or while statement\n  </li>\n</ul>","debt":"5min"},{"summary":"\"static\" members should be accessed statically","type":"Code Smell","defaultSeverity":"Major","description":"<p>While it is <em>possible</em> to access <code>static</code> members from a class instance, it's bad form, and considered by most to be misleading\nbecause it implies to the readers of your code that there's an instance of the member per class instance.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass MyClass {\npublic :\n  static void Mymethod() {\n    // ...\n  }\n};\n\nMyClass* pmyclass = new MyClass();\npmyclass-&gt;Mymethod(); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass {\npublic :\n  static Mymethod() {\n    // ...\n  }\n};\n\nMyclass::Mymethod();\n</pre>","debt":"5min"},{"summary":"Alternative operators should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>Even though the C++ standard defines both \"Primary\" and \"Alternative\" operators, it is <em>not</em> a good idea to use the alternatives. Developers\nseeing an alphabetical name expect a variable, a function, a class, a namespace... in short, anything but an operator, and they will be confused at\nbest by code that uses such operators.</p>\n<table>\n  <tbody>\n    <tr>\n      <th> Primary </th>\n      <th> Alternative </th>\n    </tr>\n    <tr>\n      <td> &amp;&amp; </td>\n      <td> and </td>\n    </tr>\n    <tr>\n      <td> &amp;= </td>\n      <td> and_eq </td>\n    </tr>\n    <tr>\n      <td> &amp; </td>\n      <td> bitand </td>\n    </tr>\n    <tr>\n      <td> | </td>\n      <td> bitor </td>\n    </tr>\n    <tr>\n      <td> ~ </td>\n      <td> compl </td>\n    </tr>\n    <tr>\n      <td> ! </td>\n      <td> not </td>\n    </tr>\n    <tr>\n      <td> != </td>\n      <td> not_eq </td>\n    </tr>\n    <tr>\n      <td> || </td>\n      <td> or </td>\n    </tr>\n    <tr>\n      <td> |= </td>\n      <td> or_eq </td>\n    </tr>\n    <tr>\n      <td> ^ </td>\n      <td> xor </td>\n    </tr>\n    <tr>\n      <td> ^= </td>\n      <td> xor_eq </td>\n    </tr>\n  </tbody>\n</table>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (not valid or error) { // Noncompliant\n  /* ... */\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (!valid || error) {\n  /* ... */\n}\n</pre>","debt":"2min"},{"summary":"Access specifiers should not be redundant","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Redundant access specifiers should be removed because they needlessly clutter the code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct S {\n  public: // Noncompliant; does not affect any declaration\n  private:\n    void method();\n  private: // Noncompliant; does not change accessibility level\n    int member;\n  private: // Noncompliant; does not affect any declaration\n};\nclass C {\n    int member;\n  private: // Noncompliant;  does not change accessibility level\n    void method();\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct S {\n  private:\n    void method();\n    int member;\n};\nclass C {\n    int member;\n    void method();\n};\n</pre>\n<h2>Exceptions</h2>\n<p>An access specifier at the very beginning of a <code>class</code> or <code>struct</code> that matches the default access level is ignored even when\nit doesn't change any accessibility levels.</p>\n<pre>\nclass C {\n  private: // redundant but accepted\n    // ...\n};\nstruct S {\n  public: // redundant but accepted\n    // ...\n};\n</pre>\n<p>Such a specifier is redundant, but ignored to allow <code>class</code>es and <code>struct</code>s to be described uniformly.</p>\n<pre>\nclass C {\n  public:\n    void call();\n\n  protected:\n    int delete();\n\n  private:\n    int code;\n};\nstruct S {\n  public: // redundant but accepted\n    int sum();\n\n  protected:\n    int min();\n\n  private:\n    int count;\n};\n</pre>","debt":"2min"},{"summary":"Assignment operators should not be \"virtual\"","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>C++ does not support polymorphic copy or move assignment operators. For example, the signature of a copy assignment operator on a \"Base\" class\nwould be <code>Base&amp; operator=(const Base&amp; other)</code>. </p>\n<p>And on a \"Derived\" class that extends \"Base\", it would be <code>Derived&amp; operator=(const Derived&amp; other)</code>.</p>\n<p>Because these are two entirely different method signatures, the second method does not override the first, and adding <code>virtual</code> to the\n\"Base\" signature does not change which method is called. </p>\n<p>It is possible to add an <code>operator=</code> override in a derived class, but doing so is an indication that you may need to reexamine your\napplication architecture.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Base {\npublic:\n  virtual Base&amp; operator=(const Base&amp; other); // Noncompliant\n};\n\nclass Derived : public Base {\npublic:\n  Derived&amp; operator=(const Derived&amp; other);\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Base {\nprotected:\n  Base&amp; operator=(const Base&amp; other); // not virtual\n};\n\nclass Derived : public Base {\npublic:\n  Derived&amp; operator=(const Derived&amp; other);\n};\n</pre>","debt":"40min"},{"summary":"Local variables should not shadow class fields","type":"Code Smell","defaultSeverity":"Major","description":"<p>Shadowing fields with a local variable is a bad practice that reduces code readability: it makes it confusing to know whether the field or the\nvariable is being used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Foo\n{\npublic:\n  void doSomething();\n\nprivate:\n  int myField;\n};\n\nvoid Foo::doSomething()\n{\n    int myField = 0; // Noncompliant\n    // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/2ADEAw\">CERT, DCL51-J.</a> - Do not shadow or obscure identifiers in subscopes </li>\n</ul>","debt":"5min"},{"summary":"\"switch\" statements should not have too many \"case\" clauses","type":"Code Smell","defaultSeverity":"Major","description":"<p>When <code>switch</code> statements have large sets of <code>case</code> clauses, it is usually an attempt to map two sets of data. A real map\nstructure would be more readable and maintainable, and should be used instead.</p>","debt":"30min"},{"summary":"Empty statements should be removed","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Empty statements, i.e. <code>;</code>, are usually introduced by mistake, for example because:</p>\n<ul>\n  <li> It was meant to be replaced by an actual statement, but this was forgotten. </li>\n  <li> There was a typo which lead the semicolon to be doubled, i.e. <code>;;</code>. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid doSomething() {\n  ;                                                       // Noncompliant - was used as a kind of TODO marker\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doSomething() {\n}\n</pre>\n<h2>Exceptions</h2>\n<p>In the case of 2 consecutive semi-colons, if one of the two is part of a macro-definition then the issue is not raised.</p>\n<p>Example:</p>\n<pre>\n#define A(x) x;\n\nvoid fun() {\n  A(5);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that\n  the first character following the null statement is a white-space character. </li>\n  <li> MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided\n  that the first character following the null statement is a white-space character. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/7gCTAw\">CERT, MSC51-J.</a> - Do not place a semicolon immediately following an if, for,\n  or while condition </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/i4FtAg\">CERT, EXP15-C.</a> - Do not place a semicolon on the same line as an if, for,\n  or while statement </li>\n</ul>","debt":"2min"},{"summary":"Only standard forms of the \"defined\" directive should be used","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>The <code>defined</code> preprocessing directive is used in the context of <code>#if</code> and <code>#elif</code> expressions to see whether a\ngiven identifier has been defined as a macro. It returns a value of 0 (false) or 1 (true), and has two valid forms, <code>defined IDENTIFIER</code>\nand <code>defined ( IDENTIFIER )</code>. Since it is essentially a macro existence check, it cannot take expressions as arguments.</p>\n<p>Note that since</p>\n<p><code>#if defined AN_IDENTIFIER</code></p>\n<p>is equivalent to</p>\n<p><code>#ifdef AN_IDENTIFIER</code></p>\n<p><code>defined</code> is most useful when there are multiple arguments to check, E.G.</p>\n<p><code>#if defined AAA || defined BBB</code></p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#if defined ( X &gt; Y ) // Noncompliant; expressions not allowed\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#if defined X &amp;&amp; defined Y &amp;&amp; X &gt; Y\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.14 - The defined preprocessor operator shall only be used in one of the two standard forms. </li>\n  <li> MISRA C++:2008, 16-1-1 - The defined preprocessor operator shall only be used in one of the two standard forms. </li>\n</ul>","debt":"5min"},{"summary":"Operands of \"&&\" and \"||\" should be primary (C) or postfix (C++) expressions","type":"Code Smell","defaultSeverity":"Major","description":"<p>The effect of this rule is to require that operands are appropriately parenthesized. Parentheses are important in this situation both for\nreadability of code and for ensuring that the behavior is as the developer intended.</p>\n<p>Where an expression consists of either a sequence of only logical <code>&amp;&amp;</code> or a sequence of logical <code>||</code>, extra\nparentheses are not required.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (x == 0 &amp;&amp; ishigh);                   // Noncompliant\nif (x || y || z);\nif (x || y &amp;&amp; z);                        // Noncompliant\nif (x &amp;&amp; !y);                            // Noncompliant\nif (is_odd(y) &amp;&amp; x);\nif ((x &gt; c1) &amp;&amp; (y &gt; c2) &amp;&amp; (z &gt; c3));\nif ((x &gt; c1) &amp;&amp; (y &gt; c2) || (z &gt; c3));   // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif ((x == 0) &amp;&amp; ishigh);\nif (x || y || z);\nif (x || (y &amp;&amp; z));\nif (x &amp;&amp; (!y));\nif (is_odd(y) &amp;&amp; x);\nif ((x &gt; c1) &amp;&amp; (y &gt; c2) &amp;&amp; (z &gt; c3));\nif ((x &gt; c1) &amp;&amp; ((y &gt; c2) || (z &gt; c3)));\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.5 - The operands of a logical &amp;&amp; or || shall be primary-expressions. </li>\n  <li> MISRA C++:2008, 5-2-1 - Each operand of a logical &amp;&amp; or || shall be a postfix-expression. </li>\n</ul>","debt":"10min"},{"summary":"Function-like macros should not be invoked without all of their arguments","type":"Bug","defaultSeverity":"Blocker","description":"<p>This is a constraint error, but preprocessors have been known to ignore this problem. Each argument in a function-like macro must consist of at\nleast one preprocessing token otherwise the behaviour is undefined.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.8 - A function-like macro shall not be invoked without all of its arguments. </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/628.html\">MITRE, CWE-628</a> - Function Call with Incorrectly Specified Arguments </li>\n</ul>","debt":"10min"},{"summary":"Function-like macros should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>It is tempting to treat function-like macros as functions, but the two things work differently. For instance, the use of functions offers parameter\ntype-checking, while the use of macros does not. Additionally, with macros, there is the potential for a macro to be evaluated multiple times. In\ngeneral, functions offer a safer, more robust mechanism than function-like macros, and that safety usually outweighs the speed advantages offered by\nmacros. Therefore functions should be used instead when possible.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#define CUBE (X) ((X) * (X) * (X)) // Noncompliant\n\nvoid func(void) {\n  int i = 2;\n  int a = CUBE(++i); // Noncompliant. Expands to: int a = ((++i) * (++i) * (++i))\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ninline int cube(int i) {\n  return i * i * i;\n}\n\nvoid func(void) {\n  int i = 2;\n  int a = cube(++i); // yields 27\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.7 - A function should be used in preference to a function-like macro. </li>\n  <li> MISRA C++:2008, 16-0-4 - Function-like macros shall not be defined. </li>\n  <li> MISRA C:2012, Dir. 4.9 - A function should be used in preference to a function-like macro where they are interchangeable </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/VIbu\">CERT, PRE00-C.</a> - Prefer inline or static functions to function-like macros\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/EwAhAQ\">CERT, PRE00-CPP.</a> - Avoid defining macros </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/N4B8Ag\">CERT, PRE10-CPP.</a> - Do not define unsafe macros </li>\n</ul>","debt":"30min"},{"summary":"Macros used in preprocessor directives should be defined before use","type":"Bug","defaultSeverity":"Major","description":"<p>An attempt to use an undefined identifier may elicit a warning from the preprocessor. Or it may not; the preprocessor may simply assume that the\nundefined token has a value of 0. </p>\n<p>Therefore macro identifiers should not be used in preprocessor directives until after they have been defined, and this limited usage should be\nenforced with the use of definition tests.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#if x &gt; 0  /* x assumed to be zero if not defined */\n#include SOMETHING_IMPORTANT\n#endif\n\n#ifdef y  /* Okay; y is not evaluated */\n#if y &gt; 0 /* Okay; y must be defined to reach this point */\n...\n#endif\n#endif\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#define x 10\n...\n#if x &gt; 0\n#include SOMETHING_IMPORTANT\n#endif\n\n#if defined ( y ) &amp;&amp; ( y &gt; 0 )  /* more compact form, same result as before */\n...\n#endif\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.11 - All macro identifiers in preprocessor directives shall be defined before use, except in #ifdef and #ifndef preprocessor\n  directives and the defined() operator. </li>\n  <li> MISRA C:2012, 20.9 - All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #defined before\n  evaluation </li>\n</ul>","debt":"5min"},{"summary":"Octal and hexadecimal escape sequences should be terminated","type":"Code Smell","defaultSeverity":"Critical","description":"<p>There is potential for confusion if an octal or hexadecimal escape sequence is immediately followed by other characters. Instead, such sequences\nshall be terminated by either:</p>\n<ul>\n  <li> The start of another escape sequence. </li>\n  <li> The end of the character constant or the end of a string literal. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst char *s1 = \"\\x41g\";  // Noncompliant\nint c1 = '\\141t'; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst char *s2 = \"\\x41\" \"g\"; // Compliant - terminated by end of literal\nconst char *s3 = \"\\x41\\x67\"; // Compliant - terminated by another escape\nint c2 = '\\141\\t'; // Compliant - terminated by another escape\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 4.1 - Octal and hexadecimal escape sequences shall be terminated </li>\n</ul>","debt":"5min"},{"summary":"\"using\" directives should not be used in header files","type":"Code Smell","defaultSeverity":"Critical","description":"<p>It is important to ensure that the order of inclusion of header files cannot affect the behavior of a program. But setting the current namespace\nfrom a header could do just that, yielding code that's nearly impossible to understand if there are similar declarations both inside and outside of\nthe namespace.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// f1.h\nvoid foo ( char_t a );\nnamespace NS1\n{\n  void foo( int32_t a );\n}\n\ninline void bar ( )\n{\n  foo ( 0 );\n}\n\n// f2.h\nnamespace NS1\n{\n}\nusing namespace NS1; // Noncompliant\n\n// f1.cc\n#include \"f1.h\"\n#include \"f2.h\"\n\nint32_t m1 ( )\n{\n  bar ( ); // bar calls foo ( char_t );\n}\n\n// f2.cc\n#include \"f2.h\"\n#include \"f1.h\"\nvoid m2 ( )\n{\n  bar ( ); // bar calls foo ( int32_t );\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 7-3-6 - using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used\n  in header files. </li>\n</ul>\n<h3>See Also</h3>\n<ul>\n  <li> ISO/IEC 14882:2003, sections 7.3.3, 7.3.4 </li>\n</ul>","debt":"20min"},{"summary":"Standard groupings should be used with digit separators","type":"Code Smell","defaultSeverity":"Critical","description":"<p>C++14 introduced the ability to use a digit separator (<code>'</code>) to split a literal number into groups of digits for better readability.</p>\n<p>To ensure that readability is really improved by using digit separators, this rule verifies:</p>\n<ul>\n  <li> <strong>Homogeneity</strong>\n    <ul>\n      <li> Except for the left-most group, which can be smaller, all groups in a number should contain the same number of digits. Mixing group sizes\n      is at best confusing for maintainers, and at worst a typographical error that is potentially a bug. </li>\n    </ul> </li>\n  <li> <strong>Standardization</strong>\n    <ul>\n      <li> It is also confusing to regroup digits using a size that is not standard. This rule enforce the following standards:\n        <ul>\n          <li> Decimal numbers should be separated using groups of 3 digits. </li>\n          <li> Hexadecimal numbers should be separated using groups of 2 or 4 digits. </li>\n          <li> Octal and Binary should be separated using groups of 2, 3 or 4 digits. </li>\n        </ul> </li>\n    </ul> </li>\n</ul>\n<p>Furthermore, using groups with more than 4 consecutive digits is not allowed because they are difficult for maintainers to read.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlong decimal_int_value     = 1'554'3124;          // Noncompliant; mixing groups of 3 and 4 digits\ndouble decimal_float_value = 7'91'87'14.3456;     // Noncompliant; using groups of 2 instead of 3 digits\nlong hexadecimal_value     = 0x8'3A3'248'6E2;     // Noncompliant; using groups of 3 instead of 2 or 4 digits\nlong octal_value           = 0442'03433'13726;    // Noncompliant; using groups of 5 instead of 2, 3 or 4 digits.\nlong binary_value          = 0b01010110'11101010; // Noncompliant; using groups of 8 instead of 2, 3 or 4 digits.\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlong decimal_int_value     = 15'543'124;\ndouble decimal_float_value = 7'918'714.3456;\nlong hexadecimal_value     = 0x83'A324'86E2;\nlong octal_value           = 04'4203'4331'3726;\nlong binary_value          = 0b0101'0110'1110'1010;\n</pre>\n<h2>Exceptions</h2>\n<p>No issue is raised on the fractional or exponent part of floating point numbers, only the integral part should comply.</p>","debt":"5min"},{"summary":"Floating point numbers should not be tested for equality","type":"Bug","defaultSeverity":"Major","description":"<p>Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a <code>float</code> or a <code>double</code> through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.</p>\n<p>Even simple floating point assignments are not simple:</p>\n<pre>\nfloat f = 0.1; // 0.100000001490116119384765625\ndouble d = 0.1; // 0.1000000000000000055511151231257827021181583404541015625\n</pre>\n<p>(Results will vary based on compiler and compiler settings.)</p>\n<p>Therefore, the use of the equality (<code>==</code>) and inequality (<code>!=</code>) operators on <code>float</code> or <code>double</code> values\nis almost always an error. </p>\n<p>The accepted solution is to use or write a float comparison library that takes floating-point granularity (FLT_EPSILON) and the magnitude of the\nnumbers being compared into account.</p>\n<p>This rule checks for the use of direct and indirect equality/inequailty tests on floats and doubles.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfloat myNumber = 3.146;\nif ( myNumber == 3.146 ) {  //Noncompliant. Because of floating point imprecision, this will be false\n  // ...\n}\n\nif (myNumber &lt;= 3.146 &amp;&amp; mNumber &gt;= 3.146) { // Noncompliant indirect equality test\n  // ...\n}\n\nif (myNumber &lt; 4 || myNumber &gt; 4) { // Noncompliant indirect inequality test\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality. </li>\n  <li> MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality </li>\n</ul>","debt":"5min"},{"summary":"Deprecated attributes should include explanations","type":"Code Smell","defaultSeverity":"Major","description":"<p>The <code>deprecated</code> attribute can be applied with or without explanations, but marking something <code>deprecated</code> without including\nadvice as to why it's deprecated or on what to use instead will lead maintainers to waste time trying to figure those things out - every single time\nthe warning is encountered.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[[deprecated]] // Noncompliant\nvoid foo1();\n\n__attribute__((deprecated)) // Noncompliant\nvoid foo2();\n\n__declspec(deprecated) // Noncompliant\nvoid foo3();\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[[deprecated(\"use 'bar' instead\")]]\nvoid foo1();\n\n__attribute__((deprecated(\"use 'bar' instead\")))\nvoid foo2();\n\n__declspec(deprecated(\"use 'bar' instead\"))\nvoid foo3();\n</pre>","debt":"5min"},{"summary":"Allocation and deallocation functions should not be explicitly declared \"static\"","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Allocation functions are always <code>static</code>. Explicitly declaring such a function <code>static</code> needlessly clutters the code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct S {\n  static void* operator new(std::size_t); // Noncompliant; static is redundant\n  static void  operator delete(void*);    // Noncompliant; static is redundant\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct S {\n  void* operator new(std::size_t);\n  void  operator delete(void*);\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> Reference: Since C++98 (ISO IEC 14882 1998) 12.5 1 and 6 </li>\n</ul>\n<blockquote>\n  <p>Any allocation function for a class T is a static member (even if not explicitly declared static).</p>\n</blockquote>\n<blockquote>\n  <p>Any deallocation function for a class X is a static member (even if not explicitly declared static). </p>\n</blockquote>","debt":"2min"},{"summary":"Digit separators should be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>C++14 adds the ability to write numbers with digit separators for better readability. Splitting a number that has more than 4 consecutive digits\nimproves readability.</p>\n<p>This rule verifies that numbers are written using digit separators when they have more than 4 consecutive digits.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlong decimal_int_value     = 5543124;            // Noncompliant; insert ' between groups of 3 digits.\ndouble decimal_float_value = 7918714.3456;       // Noncompliant; insert ' between groups of 3 digits.\nlong hexadecimal_value     = 0x83A32486E2;       // Noncompliant; insert ' between groups of 2 or 4 digits.\nlong octal_value           = 04420343313726;     // Noncompliant; insert ' between groups of 2, 3 or 4 digits.\nlong binary_value          = 0b0101011011101010; // Noncompliant; insert ' between groups of 2, 3 or 4 digits.\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlong decimal_int_value     = 5'543'124;\ndouble decimal_float_value = 7'918'714.3456;\nlong hexadecimal_value     = 0x83'A324'86E2;\nlong octal_value           = 04'4203'4331'3726;\nlong binary_value          = 0b0101'0110'1110'1010;\n</pre>\n<h2>Exceptions</h2>\n<p>No issue is raised on the fractional or exponent part of floating point numbers, only the integral part should comply.</p>","debt":"2min"},{"summary":"Inherited non-virtual functions should not be hidden","type":"Code Smell","defaultSeverity":"Critical","description":"<p>A non-virtual member function cannot be overridden in derived classes, but it can be hidden by using the same identifier. Hiding a non-virtual\nmember function creates a class that behaves differently depending on which interface is used to manipulate it. </p>\n<p>Such a class increases the inheritance complexity, and confuses consumers with its non-polymorphic behavior, which can lead to errors.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Base\n{\npublic:\n  void shutdown();\n};\n\nclass Derived : public Base\n{\npublic:\n  void shutdown(); //Noncompliant\n};\n\nvoid stopServer(Base *obj) {\n  obj-&gt;shutdown(); // always calls Base::shutdown even if the given object's type is Derived\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Base\n{\npublic:\n  virtual void shutdown();\n};\n\nclass Derived : public Base\n{\npublic:\n  void shutdown() override;\n};\n\nvoid stopServer(Base *obj) {\n  obj-&gt;shutdown(); // calls Derived::shutdown if the given object's type is Derived\n}\n</pre>\n<p>OR</p>\n<pre>\nclass Base\n{\npublic:\n  void shutdown();\n};\n\nclass Derived : public Base\n{\npublic:\n  void shutdownAndUpdate();\n};\n\nvoid stopServer(Base *obj) {\n  obj-&gt;shutdown(); // calls Base::shutdown and there is no confusion\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/display/cplusplus/OOP02-CPP.+Do+not+hide+inherited+non-virtual+member+functions\">CERT,\n  OOP02-CPP.</a> - Do not hide inherited non-virtual member functions </li>\n</ul>","debt":"20min"},{"summary":"Base class access specifiers should not be redundant","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Adding an access specifier that matches the class' current access level needlessly clutters the code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct B {\n};\n\nstruct S : public B { // Noncompliant; \"struct\" has public access for its base classes by default\n};\n\nclass C : private B { // Noncompliant; \"class\" has private access for its base classes by default\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct B {\n};\n\nstruct S : B {\n};\n\nclass C : B {\n};\n</pre>","debt":"2min"},{"summary":"Single-bit named bit fields should not be of a signed type","type":"Bug","defaultSeverity":"Major","description":"<p>The values that can be represented by a signed bit field with a length of one bit may not meet developer expectations. For example according to the\nC99 Standard, Section 6.2.6.2, a single-bit signed bit-field has a single (one) sign bit and no (zero) value bits.</p>\n<p>This rule does not apply to unnamed bit fields, as their values cannot be accessed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nsigned int f:1;  // Noncompliant; there's only room here for the sign\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nunsigned int f:1;\n</pre>\n<p>or</p>\n<pre>\nsigned int:1; // unnamed\n</pre>\n<p>or</p>\n<pre>\nsigned int f:2;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 6.5 - Bit fields of type signed int shall be at least 2 bits long </li>\n  <li> MISRA C:2012, 6.2 - Single-bit named bit fields shall not be of a signed type </li>\n  <li> MISRA C++:2008, 9-6-4 - Named bit-fields with signed integer type shall have a length of more than one bit </li>\n</ul>","debt":"5min"},{"summary":"\"inline\" should not be used redundantly","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Since C++03, a member function that is contained within a class definition is by definition <code>inline</code>, so an using an <code>inline</code>\nspecifier on such functions is redundant.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Foo {\n  inline void method() { // Noncompliant\n    // ...\n  }\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Foo {\n  void method() {\n    // ...\n  }\n};\n</pre>","debt":"1min"},{"summary":"Declarations of functions defined outside of the class should not be marked as \"inline\"","type":"Code Smell","defaultSeverity":"Minor","description":"<p>It is a best practice in the public part of a class body, to describe only information relevant for reusers of this class, without implementation\ndetails like <code>inline</code> specifier.</p>\n<p>For inline member function defined outside of the class body, this rule verifies that <code>inline</code> is set on the definition and not on the\ndeclaration of the function.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Foo {\n  public:\n    inline void method();  // Noncompliant\n    // ...\n};\nvoid Foo::method() {\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Foo {\n  public:\n    void method();\n    // ...\n};\ninline void Foo::method() {\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> https://isocpp.org/wiki/faq/inline-functions#where-to-put-inline-keyword </li>\n</ul>","debt":"2min"},{"summary":"Casts should not remove \"const\" or \"volatile\" qualifications from the type","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its\nvalue won't be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and\ncode reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nUser&amp; func(const int&amp; value, const User&amp; user) {\n  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior\n  return const_cast&lt;User&amp;&gt;(user); // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nUser&amp; func(int&amp; value, User&amp; user) {\n  value = 2;\n  return user;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>\n  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>\n  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/hAY\">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile\n  reference </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/VAE\">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ZYAyAQ\">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a\n  cv-unqualified type </li>\n</ul>","debt":"20min"},{"summary":"Only escape sequences defined in the ISO C standard should be used","type":"Bug","defaultSeverity":"Major","description":"<p>The use of an undefined escape sequence leads to undefined behavior. The defined escape sequences (ISO/IEC 14882:2003 [1] 2.13.2) are:\n<code>\\n</code>, <code>\\t</code>, <code>\\v</code>, <code>\\b</code>, <code>\\r</code>, <code>\\f</code>, <code>\\a</code>, <code>\\\\</code>,\n<code>?</code>, <code>\\'</code>, <code>\\\"</code>, <code>\\&lt;Octal Number&gt;</code>, and <code>\\x&lt;Hexadecimal Number&gt;</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst char_t a[ 2 ] = \"\\k\";   // Noncompliant\nconst char_t b[ 2 ] = \"\\b\";   // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 4.1 - Only those escape sequences that are defined in ISO C standard shall be used. </li>\n  <li> MISRA C++:2008, 2-13-1 - Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used. </li>\n</ul>","debt":"5min"},{"summary":"Octal values should not be used","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Integer literals starting with a zero are octal rather than decimal values. While using octal values is fully supported, most developers do not\nhave experience with them. They may not recognize octal values as such, mistaking them instead for decimal values.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint myNumber = 010;   // Noncompliant. myNumber will hold 8, not 10 - was this really expected?\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint myNumber = 8;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 7.1 - Octal constants (other than zero) and octal escape sequences shall not be used. </li>\n  <li> MISRA C++:2008, 2-13-2 - Octal constants (other than zero) and octal escape sequences (other than \"\\0\") shall not be used </li>\n  <li> MISRA C:2012, 7.1 - Octal constants shall not be used </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/_QC7AQ\">CERT, DCL18-C.</a> - Do not begin integer constants with 0 when specifying a\n  decimal value </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/hYClBg\">CERT, DCL50-J.</a> - Use visually distinct identifiers </li>\n</ul>","debt":"5min"},{"summary":"Unused local variables should be removed","type":"Code Smell","defaultSeverity":"Minor","description":"<p>If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will\nnot wonder what the variable is used for.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint numberOfMinutes(int hours) {\n  int seconds = 0; // never used\n  return hours * 60;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint numberOfMinutes(int hours) {\n  return hours * 60;\n}\n</pre>\n<h2>Exceptions</h2>\n<p>No issue is raised on local variables having the attribute \"unused\", on exception handler parameters and on object declarations with non-empty\narguments.</p>","debt":"5min"},{"summary":"Results of ~ and << operations on operands of underlying types unsigned char and unsigned short should immediately be cast to the operand's underlying type","type":"Bug","defaultSeverity":"Major","description":"<p>When <code>~</code> and <code>&lt;&lt;</code> are applied to small integer types (<code>unsigned char</code> or <code>unsigned short</code>), the\noperations are preceded by integral promotion, and the result may contain high-order bits which have not been anticipated.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nunsigned char port = 0x5aU;\nunsigned char result_8;\nunsigned short result_16;\nunsigned short mode;\nresult_8 = (~port) &gt;&gt; 4; // Noncompliant; '~port' is 0xFFA5 on a 16-bit machine but 0xFFFFFFA5 on a 32-bit machine. Result is 0xFA for both, but 0x0A may have been expected.\nresult_16 = ((port &lt;&lt; 4) &amp; mode) &gt;&gt; 6; // Noncompliant; result_16 value depends on the implemented size of an int.\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nresult_8 = ((unsigned char)(~port)) &gt;&gt; 4; // Compliant\nresult_16 = ((unsigned short)((unsigned short) port &lt;&lt; 4) &amp; mode) &gt;&gt; 6; // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 10.5 - If the bitwise operators ~ and &lt;&lt; are applied to an operand of underlying type unsigned char or unsigned short, the\n  result shall be immediately cast to the underlying type of the operand. </li>\n  <li> MISRA C++:2008, 5-0-10 - If the bitwise operators ~ and &lt;&lt; are applied to an operand with an underlying type of unsigned char or unsigned\n  short, the result shall be immediately cast to the underlying type of the operand. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SADFAQ\">CERT, EXP15-CPP.</a> - Beware of integer promotion when performing bitwise\n  operations on chars or shorts </li>\n</ul>","debt":"10min"},{"summary":"\"<ctime>\" should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Various aspects of <code>ctime</code> are implementation-defined or unspecified, such as the formats of times. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;ctime&gt;  /* Noncompliant */\n\nvoid f()\n{\n  clock();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 18-0-4 - The time handling functions of library &lt;ctime&gt; shall not be used. </li>\n</ul>","debt":"4h"},{"summary":"Function pointers should not be converted to any other type","type":"Bug","defaultSeverity":"Major","description":"<p>Conversion of a function pointer to a different type of pointer results in undefined behaviour. This means, for example, that a pointer to a\nfunction cannot be converted to a pointer to a different type of function.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint f(int a)\n{\n  float (*p)(float) = (float (*)(float)) &amp; f; // Noncompliant\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 11.1 - Conversions shall not be performed between a pointer to a function and any type other than an integral type. </li>\n  <li> MISRA C++:2008, 5-2-6 - A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type. </li>\n  <li> MISRA C:2012, 11.1 - Conversions shall not be performed between a pointer to a function and any other type </li>\n</ul>","debt":"10min"},{"summary":"Constants of unsigned type should have a \"U\" suffix","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The type of an integer is dependent on a complex combination of factors including:</p>\n<ul>\n  <li> The magnitude of the constant; </li>\n  <li> The implemented sizes of the integer types; </li>\n  <li> The presence of any suffixes; </li>\n  <li> The number base in which the value is expressed (i.e. decimal, octal or hexadecimal). </li>\n</ul>\n<p>For example, the value 0x8000 is of type <code>unsigned int</code> in a 16-bit environment, but of type (<code>signed</code>) <code>int</code> in a\n32-bit environment.</p>\n<p>Note:</p>\n<ul>\n  <li> Any value with a \"U\" suffix is of unsigned type; </li>\n  <li> An unsuffixed decimal value less than 2^31 is of signed type. </li>\n</ul>\n<p>But:</p>\n<ul>\n  <li> An unsuffixed hexadecimal value greater than or equal to 2^15 may be of signed or unsigned type; </li>\n  <li> For C90, an unsuffixed decimal value greater than or equal to 2^31 may be of signed or unsigned type. </li>\n</ul>\n<p>In C++, if an overload set includes candidates for an <code>unsigned int</code> and an <code>int</code>, then the overload that would be matched by\n0x8000 is therefore dependent on the implemented integer size. Adding a \"U\" suffix to the value specifies that it is unsigned.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 10.6 - A \"U\" suffix shall be applied to all constants of unsigned type. </li>\n  <li> MISRA C++:2008, 2-13-3 - A \"U\" suffix shall be applied to all octal or hexadecimal integer literals of unsigned type. </li>\n  <li> MISRA C:2012, 7.2 - A \"u\" or \"U\" suffix shall be applied to all integer constants that are represented in an unsigned type. </li>\n</ul>","debt":"5min"},{"summary":"Reserved identifiers and functions in the standard library should not be defined or declared","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Defining or declaring identifiers with reserved names may lead to undefined behavior. Similarly, defining macros, variables or functions/methods\nwith the same names as functions from the standard library is likely to lead to unexpected results. </p>\n<p>Additionally, such identifiers have the potential to thoroughly confuse people who are unfamiliar with the code base, possibly leading them to\nintroduce additional errors. Therefore reserved words and the names of standard library functions should not be used as identifiers.</p>\n<p>This rule applies to:</p>\n<ul>\n  <li> <code>defined</code> </li>\n  <li> standard library function names </li>\n  <li> identifiers that begin with two underscores </li>\n  <li> identifiers that begin with an underscore, followed by an uppercase letter </li>\n  <li> identifiers in the global namespace that start with an underscore </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#ifndef _MY_FILE\n#define _MY_FILE   // Noncompliant: starts with '_'\n\nint free(void *pArg, int len) {  // Noncompliant: free is a standard function\n  int __i; // Noncompliant: starts with \"__\"\n  //...\n}\n#endif\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#ifndef MY_FILE\n#define MY_FILE\n\nint clean(void *pArg, int len) {\n  int i;\n  //...\n}\n#endif\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.1 - Reserved identifiers, macros and functions in the standard library, shall not be defined redefined or undefined. </li>\n  <li> MISRA C++:2008, 17-0-1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined.\n  </li>\n  <li> MISRA C:2012, 21.2 - A reserved identifier or macro name shall not be declared </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/-4AzAg\">CERT, DCL37-C.</a> - Do not declare or define a reserved identifier </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/Qg8\">CERT, DCL51-CPP.</a> - Do not declare or define a reserved identifier </li>\n</ul>","debt":"10min"},{"summary":"Lines starting with \"#\" should contain valid preprocessing directives","type":"Bug","defaultSeverity":"Major","description":"<p>Preprocessing directives (lines that start with <code>#</code>) can be used to conditionally include or exclude code from compilation. Malformed\npreprocessing directives could lead to the exclusion or inclusion of more code than was intended. Therefore all preprocessing directives should be\nsyntactically meaningful.</p>\n<p>Recognized preprocessing directives are <code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>, <code>#define</code>,\n<code>#undef</code>, <code>#ifdef</code>, <code>#ifndef</code>, <code>#include</code>, <code>#line</code>, <code>#error</code>, and\n<code>#pragma</code>. Note that whitespace is allowed between the <code>#</code> and the directive.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#define AAA 2\n...\nint foo(void)\n{\n  int x = 0;\n  ...\n\n#ifndef AAA\n  x = 1;\n#else1  /* Noncompliant */\n  x = AAA;\n#endif\n\n  ...\n  return x;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#define AAA 2\n...\nint foo(void)\n{\n  int x = 0;\n  ...\n\n#ifndef AAA\n  x = 1;\n#else\n  x = AAA;\n#endif\n\n  ...\n  return x;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.16 - Preprocessing directives shall be syntactically meaningful even when excluded by preprocessor. </li>\n  <li> MISRA C++:2008, 16-0-8 - If the # token appears as the first token on a line, then it shall be immediately followed by a preprocessing token.\n  </li>\n  <li> MISRA C:2012, 20.13 - A line whose first token is # shall be a valid preprocessing directive </li>\n</ul>","debt":"5min"},{"summary":"Conditional operators should not be nested","type":"Code Smell","defaultSeverity":"Major","description":"<p>Just because you <em>can</em> do something, doesn't mean you should, and that's the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.</p>\n<p>Instead, err on the side of clarity, and use another line to express the nested operation as a separate statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint max(int p1, int p2, int p3) {\n  return p1 &gt; p2 ? (p1 &gt; p3 ? p1 : p3) : (p2 &gt; p3 ? p2 : p3); // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint max(int p1, int p2, int p3) {\n  if (p1 &gt; p2) {\n    return p1 &gt; p3 ? p1 : p3;\n  } else {\n    return p2 &gt; p3 ? p2 : p3;\n  }\n}\n</pre>","debt":"5min"},{"summary":"Child class fields should not shadow parent class fields","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you'll get confusion at\nbest, chaos at worst. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Fruit {\n  protected:\n    Season ripe;\n    static Color flesh;\n\n  // ...\n};\n\nclass Raspberry : public Fruit {\n  private:\n    bool ripe;  // Noncompliant\n    static Color FLESH; // Noncompliant\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Fruit {\n  protected:\n    Season ripe;\n    static Color flesh;\n\n  // ...\n};\n\nclass Raspberry : public Fruit {\n  private:\n    bool ripened;\n    static Color FLESH_COLOR;\n\n};\n</pre>\n<h2>Exceptions</h2>\n<p>This rule ignores same-name fields that are <code>static</code> in both the parent and child classes. This rule ignores <code>private</code> parent\nclass fields, but in all other such cases, the child class field should be renamed.</p>\n<pre>\nclass Fruit {\n  private:\n    Season ripe;\n  // ...\n};\n\nclass Raspberry : public Fruit {\n  private:\n    Season ripe;  // Compliant as parent field 'ripe' is anyway not visible from Raspberry\n  // ...\n};\n</pre>\n<p>or</p>\n<pre>\nclass Fruit {\n  public:\n    Season ripe;\n  // ...\n};\n\nclass RedFruit : private Fruit {\n};\n\nclass Raspberry : public RedFruit { // RedFruit inherits from Fruit privately\n  private:\n    Season ripe;  // Compliant as parent field 'ripe' is anyway not visible from Raspberry\n  // ...\n};\n</pre>","debt":"5min"},{"summary":"Line continuation characters '\\' should not be followed by trailing whitespace","type":"Bug","defaultSeverity":"Minor","description":"<p>The standard mentions that the line continuation character (<code>\\</code>) should be immediately followed by a newline or be the very last\ncharacter of the file in order for the lines to be joined.</p>\n<p>Several compilers relax this requirement by allowing whitespace after the <code>\\</code> character, but this is not portable because other\ncompilers may not do the same.</p>\n<h2>Compliant Solution</h2>\n<pre>\n// There should be no whitespace after the '\\'\n#define FOO BAR \\\n            BAZ\n</pre>","debt":"5min"},{"summary":"Forward declarations should not be redundant","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Redundant forward declarations simply clutter the code, and like any duplications, should be removed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct S {\n  // ...\n};\n// ...\nstruct S;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct S {\n  // ...\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"2min"},{"summary":"Macro names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all macro\nnames match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#define foo // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#define FOO\n</pre>","debt":"10min"},{"summary":"\"goto\" statements should not be used to jump into blocks","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Use of <code>goto</code> can lead to programs that are extremely difficult to comprehend and analyse, and possibly to unspecified behavior.</p>\n<p>Unfortunately, removing <code>goto</code> from some code can lead to a rewritten version that is even more difficult to understand than the\noriginal. Therefore, limited use of <code>goto</code> is sometimes advised. </p>\n<p>However, the use of <code>goto</code> to jump into or out of a sub-block of code, such as into the body of a <code>for</code> loop is never\nacceptable, because it is extremely difficult to understand and will likely yield results other than what is intended. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid f1 (int a) {\n  if (a &lt;=0) {\n    goto L2;  // Noncompliant; jumps into a different block\n  }\n\n  if (a == 0) {\n  {\n    goto L1; // Compliant\n  }\n  goto L2;  // Noncompliant; jumps into a block\n\nL1:\n  for (int i = 0; i &lt; a; i++) {\n  L2:\n    //...  Should only have come here with a &gt;=0. Loop is infinite if a &lt; 0\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid f1 (int a) {\n  if (a &lt;=0) {\n    // ...\n  }\n\n  if (a == 0) {\n  {\n    goto L1; // Compliant\n  }\n\nL1:\n  for (int i = 0; i &lt; a; i++) {\n  L2:\n    //...\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 6-6-1 - Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto\n  statement </li>\n  <li> MISRA C:2012, 15.3 - Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement\n  </li>\n</ul>","debt":"1h"},{"summary":"Dead stores should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value\nonly to then overwrite it or throw it away, could indicate a serious error in the code. Even if it's not an error, it is at best a waste of resources.\nTherefore all calculated values should be used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid pow(int a, int b) {\n  if (b == 0) {\n    return 0;\n  }\n  int x = a;\n  for (int i = 1; i &lt; b; i++) {\n    x = x * a;  // Dead store because the last return statement should return x instead of returning a\n  }\n  return a;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid pow(int a, int b) {\n  if (b == 0) {\n    return 0;\n  }\n  int x = a;\n  for (int i = 1; i &lt; b; i++) {\n    x = x * a;\n  }\n  return x;\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule ignores:</p>\n<ul>\n  <li> variable declarations initializers </li>\n  <li> prefix and postfix increments and decrements <code>x++;</code> </li>\n  <li> null pointer assignments <code>x = NULL;</code> </li>\n  <li> self assignments (i.e. <code>x = x;</code>) </li>\n</ul>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/563.html\">MITRE, CWE-563</a> - Assignment to Variable without Use ('Unused Variable') </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/QYA5\">CERT, MSC13-C.</a> - Detect and remove unused values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/S4IyAQ\">CERT, MSC13-CPP.</a> - Detect and remove unused values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/uQCSBg\">CERT, MSC56-J.</a> - Detect and remove superfluous code and values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"15min"},{"summary":"Standard C++ headers should be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>The <code>iostream.h</code> header was provided with the first C++ compiler, CFront, and became the de facto standard. During the formal\nstandardization process of C++, many shortcomings in <code>iostream.h</code> were fixed, but at the cost of introducing incompatibilities. Therefore,\nit was decided not to change the existing <code>iostream.h</code> and introduce the standard version as a new <code>iostream</code> header.</p>\n<p>Modern compilers tend to remove the support of the legacy <code>iostream.h</code> header, and migrating to the standard version is encouraged.</p>\n<p>This rule applies not only to <code>iostream</code>, but to all standard C++ headers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;iostream.h&gt; // Noncompliant\n#include &lt;fstream.h&gt;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n</pre>","debt":"20min"},{"summary":"Preprocessor directives should not be indented","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Indenting preprocessor directives reduces the code readability, because it make preprocessor directives harder to spot.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid optimal()\n{\n  #if INTEL             /* Noncompliant - hard to spot */\n  specificIntelStuff();\n  #endif                /* Noncompliant - hard to spot */\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid optimal()\n{\n#if INTEL               /* Compliant */\n  specificIntelStuff();\n#endif                  /* Compliant */\n}\n</pre>","debt":"5min"},{"summary":"\"override\" or \"final\" should be used instead of \"virtual\"","type":"Code Smell","defaultSeverity":"Minor","description":"<p>In a base class, <code>virtual</code> indicates that a function can be overridden. In a derived class, it indicates an override. But given the\nspecifier's dual meaning, it would be both clearer and more sound to use derived class-specific specifiers instead: <code>override</code> or\n<code>final</code>. </p>\n<ul>\n  <li> <code>final</code> indicates a function <code>override</code> that cannot itself be overridden. The compiler will issue a warning if the\n  signature does not match the signature of a base-class <code>virtual</code> function. </li>\n  <li> <code>override</code> indicates that a function is intended to override a base-class function. The compiler will issue a warning if this is not\n  the case. It is redundant in combination with <code>final</code>. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Counter {\nprotected:\n  int c = 0;\npublic:\n  virtual void count() {\n    c++;\n  }\n};\n\nclass FastCounter: public Counter {\npublic:\n  virtual void count() {  // Noncompliant\n    c += 2;\n  }\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Counter {\nprotected:\n  int c = 0;\npublic:\n  virtual void count() {\n    c++;\n  }\n};\n\nclass FastCounter: public Counter {\npublic:\n  void count() override {\n    c += 2;\n  }\n};\n</pre>\n<p>or</p>\n<pre>\nclass Counter {\nprotected:\n  int c = 0;\npublic:\n  virtual void count() {\n    c++;\n  }\n};\n\nclass FastCounter: public Counter {\npublic:\n  void count() final {\n    c += 2;\n  }\n};\n</pre>\n<h3>See also</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=cpp%3AS1016'>S1016</a> </li>\n</ul>","debt":"5min"},{"summary":"Unused function parameters should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid doSomething(int a, int b) { // Noncompliant, \"b\" is unused\n  compute(a);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doSomething(int a) {\n  compute(a);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>\n  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"5min"},{"summary":"Initialization lists should be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>The omission of an initialization list means that your class members will first be initialized with default values before their assignments to\ntheir actual values in the class body. For primitive class members, this overhead is negligible, but for non-trivial, user classes it could be\nsignificant.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass MyClass {\n  private:\n    FatClass first, second;\n\n  public:\n    MyClass(FatClass first_var, FatClass sec_var) {\n      first = first_var; // Noncompliant\n      second = sec_var; // Noncompliant\n    }\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass {\n  private:\n    FatClass first, second;\n\n  public:\n    MyClass(FatClass first_var, FatClass sec_var): first(first_var), second(sec_var) { }\n};\n</pre>","debt":"10min"},{"summary":"Assignments should not be made from within sub-expressions","type":"Code Smell","defaultSeverity":"Major","description":"<p>Assignments within sub-expressions are hard to spot and therefore make the code less readable. Ideally, sub-expressions should not have\nside-effects.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ((str = cont.substring(pos1, pos2)).isEmpty()) {  // Noncompliant\n  //...\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstr = cont.substring(pos1, pos2);\nif (str.isEmpty()) {\n  //...\n</pre>\n<h2>Exceptions</h2>\n<p>Assignments explicitly enclosed in parentheses are ignored.</p>\n<pre>\nwhile ((run = keepRunning())) {\n  //...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.1 - Assignment operators shall not be used in expressions that yield a Boolean value </li>\n  <li> MISRA C++:2008, 6-2-1 - Assignment operators shall not be used in sub-expressions </li>\n  <li> MISRA C:2012, 13.4 - The result of an assignment operator should not be used </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/481.html\">MITRE, CWE-481</a> - Assigning instead of Comparing </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/nYFtAg\">CERT, EXP45-C.</a> - Do not perform assignments in selection statements </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/1gCTAw\">CERT, EXP51-J.</a> - Do not perform assignments in conditional expressions\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KQvhAg\">CERT, EXP19-CPP.</a> - Do not perform assignments in conditional expressions\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KYIyAQ\">CERT, MSC02-CPP.</a> - Avoid errors of omission </li>\n</ul>","debt":"5min"},{"summary":"Stack allocated memory should not be freed","type":"Bug","defaultSeverity":"Blocker","description":"<p>Stack allocated memory allocated with functions <code>alloca</code>, <code>_alloca</code>, <code>_malloca</code>, <code>__builtin_alloca</code> is\nautomatically released at the end of the function, it should not be released with <code>free</code>. Explicitly <code>free</code>-ing such memory\nresults in undefined behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fun() {\n  char *name = (char *) alloca(size);\n  // ...\n  free(name); // Noncompliant, memory allocated on the stack\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid fun() {\n  char *name = (char *) alloca(size);\n  // ...\n}\n</pre>","debt":"2min"},{"summary":"Standard namespaces should not be modified","type":"Code Smell","defaultSeverity":"Critical","description":"<p>It may seem tidy to add your new declarations to the <code>std</code> or <code>posix</code> namespaces, but doing so results in undefined behavior.\nThe C++14 Standard, [namespace.std] (ISO/IEC 14882-2014 17.6.4.2.1), paragraphs 1 and 2 states:</p>\n<blockquote>\n  <ol>\n    <li> The behavior of a C++ program is undefined if it adds declarations or definitions to namespace std or to a namespace within namespace std\n    unless otherwise specified. A program may add a template specialization for any standard library template to namespace std only if the declaration\n    depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly\n    prohibited. </li>\n    <li> The behavior of a C++ program is undefined if it declares:\n      <ul>\n        <li> an explicit specialization of any member function of a standard library class template, or </li>\n        <li> an explicit specialization of any member function template of a standard library class or class template, or </li>\n        <li> an explicit or partial specialization of any member class template of a standard library class or class template. </li>\n      </ul> </li>\n  </ol>\n</blockquote>\n<p>In addition to restricting extensions to the the <code>std</code> namespace, the C++14 Standard goes on in 17.6.4.2.2 to say:</p>\n<blockquote>\n  <ol>\n    <li> The behavior of a C++ program is undefined if it adds declarations or definitions to namespace posix or to a namespace within namespace posix\n    unless otherwise specified. The namespace posix is reserved for use by ISO/IEC 9945 and other POSIX standards. </li>\n  </ol>\n</blockquote>\n<p>On paper, the only exception is the addition of a template specialization that depends on a user-defined type that meets the requirements for the\noriginal template, but this exception is not supported and so this rule bans any modification of the standard <code>std</code> and <code>posix</code>\nnamespaces.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnamespace std {  // Noncompliant\n  int x;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nnamespace expanded_std {\n  int x;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/LwDTAQ\">CERT, DCL58-CPP.</a> - Do not modify the standard namespaces </li>\n</ul>","debt":"15min"},{"summary":"Track uses of \"NOSONAR\" comments","type":"Code Smell","defaultSeverity":"Major","description":"<p>Any issue to quality rule can be deactivated with the <code>NOSONAR</code> marker. This marker is pretty useful to exclude false-positive results\nbut it can also be used abusively to hide real quality flaws.</p>\n<p>This rule raises an issue when <code>NOSONAR</code> is used.</p>","debt":"1min"},{"summary":"Object declarations should contain no more than 2 levels of pointer indirection","type":"Code Smell","defaultSeverity":"Critical","description":"<p>While they are extraordinarily useful, pointers are not the most intuitive concept in the world. Pointers to pointers are even harder to understand\nand use correctly. And with each additional level of indirection, pointer variables become more difficult to use correctly. Therefore pointer\ndeclarators should be limited to no more than two levels of nesting. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntypedef int * INTPTR;\nstruct s {\n int ** s1;\n int *** s2; // Noncompliant\n};\n\nstruct s ** ps1;\nstruct s *** ps2; // Noncompliant\n\nint ** ( *pfunc1)();\nint ** ( **pfunc2)();\nint ** (***pfunc3)(); // Noncompliant\nint *** ( **pfunc4)(); // Noncompliant\n\nvoid function( int ** par1,\n               int *** par2, // Noncompliant\n               INTPTR * par3,\n               int * par4[],\n               int ** par5[]) // Noncompliant\n{\n  int ** ptr1;\n  int *** ptr2; // Noncompliant\n  INTPTR * ptr3;\n  int * ptr4[ 10 ];\n  int ** ptr5[ 10 ]; //Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntypedef int * INTPTR;\nstruct s {\n int ** s1;\n int ** s2;\n};\n\nstruct s ** ps1;\nstruct s ** ps2;\n\nint ** (*pfunc1)();\nint ** (**pfunc2)();\nint ** (**pfunc3)();\nint ** (**pfunc4)();\n\nvoid function( int ** par1,\n               int ** par2,\n               INTPTR * par3,\n               int * par4[],\n               int * par5[])\n{\n  int ** ptr1;\n  int ** ptr2;\n  INTPTR * ptr3;\n  int * ptr4[ 10 ];\n  int * ptr5[ 10 ];\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 17.5 - The declaration of objects should contain no more than 2 levels of pointer indirection </li>\n  <li> MISRA C++:2008, 5-0-19 - The declaration of objects shall contain no more than two levels of pointer indirection </li>\n  <li> MISRA C:2012, 18.5 - Declarations should contain no more than two levels of pointer nesting </li>\n</ul>","debt":"15min"},{"summary":"Functions should not be declared at block scope","type":"Code Smell","defaultSeverity":"Major","description":"<p>A function declared at block scope will refer to a member of the enclosing namespace, and so the declaration should be explicitly placed at the\nnamespace level.</p>\n<p>Additionally, where a declaration statement could either declare a function or an object, the compiler will choose to declare the function. To\navoid potential developer confusion over the meaning of a declaration, functions should not be declared at block scope.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass A {\n};\n\nvoid fun() {\n  void nestedFun();  // Noncompliant; declares a function in block scope\n\n  A a();      // Noncompliant; declares a function at block scope, not an object\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 8.6 - Functions shall be declared at file scope </li>\n  <li> MISRA C++:2008, 3-1-2 - Functions shall not be declared at block scope </li>\n</ul>","debt":"5min"},{"summary":"The name \"main\" should not be used for any function other than the global \"main\" function","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>A global function named <code>main</code> is the entry point to the program, and is the only identifier which must be in the global namespace. The\nuse of <code>main</code> for other functions may not meet developer expectations.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint main() {       // Compliant\n}\n\nnamespace {\n  int main() {     // Noncompliant\n  }\n}\nnamespace NS {\n  int main() {     // Noncompliant\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 7-3-2 - The identifier main shall not be used for a function other than global function main. </li>\n</ul>","debt":"20min"},{"summary":"\"<cstdio>\" should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>This includes file and I/O functions <code>fgetpos</code>, <code>fopen</code>, <code>ftell</code>, <code>gets</code>, <code>perror</code>,\n<code>remove</code>, <code>rename</code>, etc.</p>\n<p>Streams and file I/O have a large number of unspecified, undefined and implementation-defined behaviors associated with them.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;cstdio&gt;  /* Noncompliant */\n\nvoid fn()\n{\n  char_t array[10];\n  gets(array);           /* Can lead to buffer over-run */\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 27-0-1 - The stream input/output library <em>&lt;cstdio&gt;</em> shall not be used. </li>\n</ul>","debt":"4h"},{"summary":"Related \"if/else if\" statements should not have the same condition","type":"Bug","defaultSeverity":"Major","description":"<p>A chain of <code>if</code>/<code>else if</code> statements is evaluated from top to bottom. At most, only one branch will be executed: the first\none with a condition that evaluates to <code>true</code>. </p>\n<p>Therefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it's simply dead code and\nat worst, it's a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (param == 1)\n  openWindow();\nelse if (param == 2)\n  closeWindow();\nelse if (param == 1)  // Noncompliant\n  moveWindowToTheBackground();\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (param == 1)\n  openWindow();\nelse if (param == 2)\n  closeWindow();\nelse if (param == 3)\n  moveWindowToTheBackground();\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"10min"},{"summary":"Unused \"private\" fields should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>If a <code>private</code> field is declared but not used in the program, it can be considered dead code and should therefore be removed. This will\nimprove maintainability because developers will not wonder what the variable is used for.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass MyClass {\n  private:\n    int foo = 42;  // Noncompliant, foo is unused\n\n  public:\n    int compute(int a) {\n      return a * 42;\n    }\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass {\n  public:\n    int compute(int a) {\n      return a * 42;\n    }\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"5min"},{"summary":"Lambdas should not have too many lines","type":"Code Smell","defaultSeverity":"Major","description":"<p>Lambdas (introduced in C++11) are a very convenient and compact way to inject a behavior without having to create a dedicated function. But those\nlambdas should be used only if the behavior to be injected can be defined in a few lines of code, otherwise the source code can quickly become\nunreadable.</p>","debt":"20min"},{"summary":"Expressions should not be too complex","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The complexity of an expression is defined by the number of <code>&amp;&amp;</code>, <code>||</code> and <code>condition ? ifTrue : ifFalse</code>\noperators it contains.</p>\n<p>A single expression's complexity should not become too high to keep the code readable.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold value 3.</p>\n<pre>\nif (((condition1 &amp;&amp; condition2) || (condition3 &amp;&amp; condition4)) &amp;&amp; condition5) { ... }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif ((myFirstCondition() || mySecondCondition()) &amp;&amp; myLastCondition()) { ... }\n</pre>","debt":"5min"},{"summary":"\"final\" classes should not have \"protected\" members","type":"Code Smell","defaultSeverity":"Minor","description":"<p>The difference between <code>private</code> and <code>protected</code> visibility is that child classes can see and use <code>protected</code>\nmembers, but they cannot see <code>private</code> ones. Since a <code>final</code> class will have no children, marking the members of a\n<code>final</code> class <code>protected</code> is confusingly pointless.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass C final {\nprotected:  // Noncompliant\n  void fun();\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass C final {\nprivate:\n  void fun();\n};\n</pre>","debt":"5min"},{"summary":"Collapsible \"if\" statements should be merged","type":"Code Smell","defaultSeverity":"Major","description":"<p>Merging collapsible <code>if</code> statements increases the code's readability.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition1) {\n  if (condition2) {             // NonCompliant\n    /* ... */\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition1 &amp;&amp; condition2) { // Compliant\n  /* ... */\n}\n</pre>","debt":"5min"},{"summary":"Unused labels should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>If a label is declared but not used in the program, it can be considered as dead code and should therefore be removed.</p>\n<p>This will improve maintainability as developers will not wonder what this label is used for.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fun() {\n  label: doSomething();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid fun() {\n  doSomething();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 2.6 - A function should not contain unused label declarations </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"2min"},{"summary":"Methods should not be empty","type":"Code Smell","defaultSeverity":"Critical","description":"<p>There are several reasons for a method not to have a method body:</p>\n<ul>\n  <li> It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. </li>\n  <li> It is not yet, or never will be, supported. In this case an exception should be thrown in languages where that mechanism is available. </li>\n  <li> The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fun(int p1) {\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid fun(int p1) {\n  int a = doSomething(p1);\n  int threshold = 42;\n  if (a &gt; threshold) {\n    // ...\n  }\n}\n</pre>\n<p>or </p>\n<pre>\nvoid fun(int p1) {\n  // Intentionally unimplemented...\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule doesn't raise an issue for empty class constructors or destructors. For instance this is the only way to define user-defined default\nconstructors.</p>","debt":"5min"},{"summary":"Overriding methods should do more than simply call the same method in the super class","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Overriding a method just to call the same method from the super class without performing any other actions is useless and misleading. The only time\nthis is justified is in <code>final</code> overriding methods, where the effect is to lock in the parent class behavior. This rule ignores such\noverrides of <code>equals</code>, <code>hashCode</code> and <code>toString</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Base {\npublic:\n  virtual void f();\n};\n\nclass Derived : public Base {\npublic:\n  virtual void f() {\n    Base::f(); // Noncompliant\n  }\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Base {\npublic:\n  virtual void f();\n};\n\nclass Derived : public Base {\n};\n</pre>\n<p>or</p>\n<pre>\nclass Base {\npublic:\n  void f();\n};\n\nclass Derived : public Base {\nprivate: // change of visibility\n  virtual void f() {\n    Base::f();\n  }\n};\n</pre>\n<p>or</p>\n<pre>\nclass Base {\npublic:\n  void f();\n};\n\nclass Derived : public Base {\npublic:\n  void f() final { // final\n    Base::f();\n  }\n};\n</pre>","debt":"2min"},{"summary":"\"#include\" paths should be portable","type":"Code Smell","defaultSeverity":"Major","description":"<p>The path provided here doesn't match the actual path on this file system (e.g. the case is different). While this may work on a particular\nenvironment, this is not portable and may fail on a different environment.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include \"Foo.h\" // Noncompliant, the file name is \"foo.h\"\n</pre>","debt":"5min"},{"summary":"Non-reentrant POSIX functions should be replaced with their reentrant versions","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>A function is called reentrant if it can be interrupted in the middle of its execution and then safely called again (\"re-entered\") before its\nprevious invocations complete execution.</p>\n<p>It is especially important that multi-threaded applications do not call the same non-reentrant function from different threads.</p>\n<p>This rule will trigger an issue each time a function in the configurable list is invoked.</p>\n<h2>Noncompliant Code Example</h2>\n<p>Given a function that includes <code>localtime</code>:</p>\n<pre>\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nvoid print_date_and_time(struct tm *time_ptr)\n{\n  printf(\n    \"Current date and time: %d/%02d/%02d %02d:%02d:%02d\\n\",\n    time_ptr-&gt;tm_year + 1900,\n    time_ptr-&gt;tm_mon,\n    time_ptr-&gt;tm_mday,\n    time_ptr-&gt;tm_hour,\n    time_ptr-&gt;tm_min,\n    time_ptr-&gt;tm_sec);\n}\n\nvoid print_unix_epoch_date_and_time()\n{\n  time_t unix_epoch_time = (time_t)0;\n  struct tm *local_time_ptr = localtime(&amp;unix_epoch_time); // Noncompliant, call to the non-reentrant localtime() function\n  print_date_and_time(local_time_ptr);\n}\n\nint main(int argc, char* argv[])\n{\n  time_t current_time;\n  struct tm *local_time_ptr;\n\n  time(&amp;current_time);\n\n  local_time_ptr = localtime(&amp;current_time); // Noncompliant, call to the non-reentrant localtime() function\n\n  // As expected, this will print: Current date and time: 1970/00/01 01:00:00\n  print_unix_epoch_date_and_time();\n\n  // This will actually also print Current date and time: 1970/00/01 01:00:00\n  // Indeed, localtime() is non-reentrant, and always returns the same pointer\n  print_date_and_time(local_time_ptr);\n\n  return 0;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nvoid print_date_and_time(struct tm *time_ptr)\n{\n  printf(\n    \"Current date and time: %d/%02d/%02d %02d:%02d:%02d\\n\",\n    time_ptr-&gt;tm_year + 1900,\n    time_ptr-&gt;tm_mon,\n    time_ptr-&gt;tm_mday,\n    time_ptr-&gt;tm_hour,\n    time_ptr-&gt;tm_min,\n    time_ptr-&gt;tm_sec);\n}\n\nvoid print_unix_epoch_date_and_time()\n{\n  time_t unix_epoch_time = (time_t)0;\n  struct tm local_time;\n  localtime_r(&amp;unix_epoch_time, &amp;local_time); // Compliant\n  print_date_and_time(&amp;local_time);\n}\n\nint main(int argc, char* argv[])\n{\n  time_t current_time;\n  struct tm local_time;\n\n  time(&amp;current_time);\n\n  localtime_r(&amp;current_time, &amp;local_time); // Compliant\n\n  // As expected, this will print: Current date and time: 1970/00/01 01:00:00\n  print_unix_epoch_date_and_time();\n\n  // As expected, this will print the current date and time, as expected\n  print_date_and_time(&amp;local_time);\n\n  return 0;\n}\n</pre>","debt":"30min"},{"summary":"Comment styles \"//\" and \"/* ... */\" should not be mixed within a file","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Use either the <code>// ...</code> or <code>/* ... */</code> comment syntax, but be consistent and do not mix them within the same file.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n/* Noncompliant; both comment syntaxes are used in the same file */\n// Foo\n/* Bar */\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// Compliant; uniform comment syntax\n// Foo\n// Bar\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/DQBWB\">CERT, MSC55-J.</a> - Use comments consistently and in a readable fashion </li>\n</ul>","debt":"5min"},{"summary":"Parameter values should be appropriate","type":"Bug","defaultSeverity":"Critical","description":"<p>The standard C library includes a number of functions for string and memory manipulation. They take pointers and a lengths as parameters. Passing\n<code>NULL</code> for the pointers will at best do nothing and at worst crash the application.</p>\n<p>This rule raises an issue when <code>NULL</code> is passed as a pointer in to any of the following functions:</p>\n<ul>\n  <li> <code>void *memcpy(void *dest, const void *src, size_t n);</code> </li>\n  <li> <code>void *memmove(void *dest, const void *src, size_t n);</code> </li>\n  <li> <code>void *memccpy(void *dest, const void *src, int c, size_t n);</code> </li>\n  <li> <code>void *memset(void *s, int c, size_t n);</code> </li>\n  <li> <code>int memcmp(const void *s1, const void *s2, size_t n);</code> </li>\n  <li> <code>void *memchr(const void *s, int c, size_t n);</code> </li>\n  <li> <code>void *rawmemchr(const void *s, int c);</code> </li>\n  <li> <code>void *memrchr(const void *s, int c, size_t n);</code> </li>\n  <li> <code>char *strcpy(char *dest, const char *src);</code> </li>\n  <li> <code>char *strncpy(char *dest, const char *src, size_t n);</code> </li>\n  <li> <code>char *strcat(char *dest, const char *src);</code> </li>\n  <li> <code>char *strncat(char *dest, const char *src, size_t n);</code> </li>\n  <li> <code>int strcmp(const char *s1, const char *s2);</code> </li>\n  <li> <code>int strncmp(const char *s1, const char *s2, size_t n);</code> </li>\n  <li> <code>int strcoll(const char *s1, const char *s2);</code> </li>\n  <li> <code>size_t strxfrm(char *dest, const char *src, size_t n);</code> </li>\n  <li> <code>int strcoll_l(const char *s1, const char *s2, locale_t loc);</code> </li>\n  <li> <code>size_t strxfrm_l(char *restrict s1, const char *restrict s2, size_t n, locale_t loc);</code> </li>\n  <li> <code>char *strdup(const char *s);</code> </li>\n  <li> <code>char *strndup(const char *s, size_t n);</code> </li>\n  <li> <code>char *strchr(const char *s, int c);</code> </li>\n  <li> <code>char *strrchr(const char *s, int c);</code> </li>\n  <li> <code>char *strchrnul(const char *s, int c);</code> </li>\n  <li> <code>size_t strcspn(const char *s, const char *reject);</code> </li>\n  <li> <code>size_t strspn(const char *s, const char *accept);</code> </li>\n  <li> <code>char *strpbrk(const char *s, const char *accept);</code> </li>\n  <li> <code>char *strstr(const char *haystack, const char *needle);</code> </li>\n  <li> <code>char *strtok(char *s, const char *delim);</code> </li>\n  <li> <code>char *strtok_r(char *str, const char *delim, char **saveptr);</code> </li>\n  <li> <code>char *strcasestr(const char *haystack, const char *needle);</code> </li>\n  <li> <code>void *memmem(const void *haystack, size_t haystacklen, const void *needle, size_t needlelen);</code> </li>\n  <li> <code>void *mempcpy(void *dest, const void *src, size_t n);</code> </li>\n  <li> <code>size_t strlen(const char *s);</code> </li>\n  <li> <code>size_t strnlen(const char *s, size_t maxlen);</code> </li>\n  <li> <code>char *strerror_r(int errnum, char *buf, size_t buflen);</code> </li>\n  <li> <code>void bcopy(const void *src, void *dest, size_t n);</code> </li>\n  <li> <code>void bzero(void *s, size_t n);</code> </li>\n  <li> <code>int bcmp(const void *s1, const void *s2, size_t n);</code> </li>\n  <li> <code>char *index(const char *s, int c);</code> </li>\n  <li> <code>char *rindex(const char *s, int c);</code> </li>\n  <li> <code>int strcasecmp(const char *s1, const char *s2);</code> </li>\n  <li> <code>int strncasecmp(const char *s1, const char *s2, size_t n);</code> </li>\n  <li> <code>int strcasecmp_l(const char *s1, const char *s2, locale_t loc);</code> </li>\n  <li> <code>int strncasecmp_l(const char *s1, const char *s2, size_t n, locale_t loc);</code> </li>\n  <li> <code>char *strsep(char **stringp, const char *delim);</code> </li>\n  <li> <code>char *stpcpy(char *dest, const char *src);</code> </li>\n  <li> <code>char *stpncpy(char *dest, const char *src, size_t n);</code> </li>\n  <li> <code>int strverscmp(const char *s1, const char *s2);</code> </li>\n  <li> <code>char *strfry(char *string);</code> </li>\n  <li> <code>void *memfrob(void *s, size_t n);</code> </li>\n  <li> <code>char *basename(char *path);</code> </li>\n</ul>\n<p>This rule raises an issue when 0 is passed as a length to any of the following functions, since the last two parameters might have been swapped by\nmistake:</p>\n<ul>\n  <li> <code>void *memccpy(void *dest, const void *src, int c, size_t n);</code> </li>\n  <li> <code>void *memset(void *s, int c, size_t n);</code> </li>\n  <li> <code>void *memchr(const void *s, int c, size_t n);</code> </li>\n  <li> <code>void *memrchr(const void *s, int c, size_t n);</code> </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nmemcpy(NULL, src, 10); // Noncompliant, null pointer\nmemset(ptr, 0, 0); // Noncompliant, length is zero\n</pre>","debt":"5min"},{"summary":"Type specifiers should be listed in a standard order","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that type specifiers always appear in the following order:</p>\n<ol>\n  <li> <code>typedef</code> </li>\n  <li> <code>const</code> </li>\n  <li> type name, spelling of built-in types with more than one type-specifier:\n    <ol>\n      <li> signedness - <code>signed</code> or <code>unsigned</code> </li>\n      <li> last single type-specifier or\n        <ul>\n          <li> <code>short int</code> </li>\n          <li> <code>long int</code> </li>\n          <li> <code>long long int</code> </li>\n          <li> <code>long double</code> </li>\n        </ul> </li>\n    </ol> </li>\n</ol>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint typedef T;\n\ndouble long d;\nchar unsigned ch;\nlong signed int i;\n\nint const *p;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntypedef int T;\n\nlong double d;\nunsigned char ch;\nsigned long int i;\n\nconst int *p; // or \"int * const p;\"\n</pre>","debt":"2min"},{"summary":"Empty throws (\"throw;\") should only be used in the compound statements of catch handlers","type":"Bug","defaultSeverity":"Critical","description":"<p>An empty <code>throw</code> re-throws the temporary object that represents an exception. Its use is intended to enable the handling of an exception\nto be split across two or more handlers.</p>\n<p>However, syntactically, there is nothing to prevent <code>throw;</code> being used outside a catch handler, where there is no exception object to\nre-throw. This may lead to implementation-defined program termination.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid f1(void)\n{\n  throw;   // Noncompliant - will call std::terminate()\n}\n\nvoid g1(void)\n{\n  try\n  {\n    f1();\n    throw; // Noncompliant\n  }\n  catch (...)\n  {\n    // ...\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid f1(void)\n{\n  try\n  {\n    throw(42);\n  }\n  catch (int32_t i) // int will be handled first here\n  {\n    if (i &gt; 0)\n    {\n      throw;        // and then re-thrown - Compliant\n    }\n  }\n}\n\nvoid g1(void)\n{\n  try\n  {\n    f1();\n  }\n  catch (int32_t i)\n  {\n    // Handle re-throw from f1()\n    // after f1's handler has done what it needs\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 15-1-3 - An empty throw (<code>throw;</code>) shall only be used in the compound-statement of a catch handler. </li>\n</ul>","debt":"20min"},{"summary":"\"#import\" should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>#import</code> comes from Objective-C and is a variant of <code>#include</code>. GCC does support it, but it requires the users of a header\nfile to know that it should only be included once. It is much better for the header file's implementor to write the file so that users don't need to\nknow this. Using a wrapper <code>#ifndef</code> accomplishes this goal.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#import \"foo.h\" // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include \"foo.h\"\n</pre>","debt":"1min"},{"summary":"All branches in a conditional structure should not have exactly the same implementation","type":"Bug","defaultSeverity":"Major","description":"<p>Having all branches in a <code>switch</code> or <code>if</code> chain with the same implementation is an error. Either a copy-paste error was made\nand something different should be executed, or there shouldn't be a <code>switch</code>/<code>if</code> chain at all. Note that this rule does not\napply to <code>if</code> chains without <code>else</code>-s, or to <code>switch</code>-es without <code>default</code> clauses.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (b == 0) {  // Noncompliant\n  doOneMoreThing();\n}\nelse {\n  doOneMoreThing();\n}\n\nint b = a &gt; 12 ? 4 : 4;  // Noncompliant\n\nswitch (i) {  // Noncompliant\n  case 1:\n    doSomething();\n    break;\n  case 2:\n    doSomething();\n    break;\n  case 3:\n    doSomething();\n    break;\n  default:\n    doSomething();\n}\n</pre>","debt":"15min"},{"summary":"Variables should be initialized before use","type":"Bug","defaultSeverity":"Major","description":"<p>Variables should be initialized before their use to avoid unexpected behaviors due to garbage values.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid function(int flag, int b) {\n  int a;\n  if (flag) {\n    a = b;\n  }\n  return a; // Noncompliant - \"a\" has not been initialized in all paths\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid function(int flag, int b) {\n  int a = 0;\n  if (flag) {\n    a = b;\n  }\n  return a;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/457.html\">MITRE, CWE-457</a> - Use of Uninitialized Variable </li>\n  <li> MISRA C:2004, 9.1 - All automatic variables shall have been assigned a value before being used. </li>\n  <li> MISRA C++:2008, 8-5-1 - All variables shall have a defined value before they are used. </li>\n</ul>","debt":"15min"},{"summary":"Literal suffixes shall be upper case","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Using upper case literal suffixes removes the potential ambiguity between \"1\" (digit 1) and \"l\" (letter el) for declaring literals.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst int        a = 0u;      // Noncompliant\nconst int        b = 0l;      // Noncompliant\nconst int        c = 0Ul;     // Noncompliant\nconst int        d = 0x12bu;  // Noncompliant\nconst float      m = 1.2f;    // Noncompliant\nconst float      n = 1.2l;    // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst int        a = 0U;\nconst int        b = 0L;\nconst int        c = 0UL;\nconst int        d = 0x12bU;\nconst float      m = 1.2F;\nconst float      n = 1.2L;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 2-13-4 - Literal suffixes shall be upper case </li>\n  <li> MISRA C:2012, 7.3 - The lowercase character \"l\" shall not be used in a literal suffix </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/koAtAQ\">CERT DCL16-C.</a> - Use \"L,\" not \"l,\" to indicate a long value </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/n4AtAQ\">CERT DCL16-CPP.</a> - Use \"L,\" not \"l,\" to indicate a long value </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/hYClBg\">CERT, DCL50-J.</a> - Use visually distinct identifiers </li>\n</ul>","debt":"2min"},{"summary":"Macros should not be #define'd or #undef'd within a block","type":"Code Smell","defaultSeverity":"Critical","description":"<p>While it is legal to place <code>#define</code> and <code>#undef</code> directives anywhere in a source file, placing them outside of the global\nnamespace is misleading since their scope is not actually restricted. This may be inconsistent with developer expectations.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnamespace NS\n{\n  #ifndef MY_HDR\n  #define MY_HDR    /* Noncompliant */\n  #undef FOO        /* Noncompliant */\n  #endif\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#ifndef MY_HDR\n#define MY_HDR\n#undef FOO\n#endif\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.5 - Macros shall not be #define'd or #undef'd within a block. </li>\n  <li> MISRA C++:2008, 16-0-2 - Macros shall only be #define'd or #undef'd in the global namespace. </li>\n</ul>","debt":"10min"},{"summary":"Generic exceptions should not be caught","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>std::exception</code> is the superclass of all exceptions in C++.</p>\n<p>Catching <code>std::exception</code> will also catch <code>std::bad_alloc</code> and <code>std::bad_exception</code>, from which an application\nshould not attempt to recover. More generally, catching generic exception types is a bad idea, because it implies that the \"catch\" bock is clever\nenough to handle any type of exception.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntry {\n  /* code that may throw std::system_error */\n} catch (const std::exception &amp;ex) { // Noncompliant\n  /*...*/\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntry {\n  /* code that may throw std::system_error */\n} catch (const std::system_error &amp;ex) {\n  /*...*/\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/396.html\">MITRE, CWE-396</a> - Declaration of Catch for Generic Exception </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/BIB3AQ\">CERT, ERR08-J.</a> - Do not catch NullPointerException or any of its ancestors\n  </li>\n</ul>","debt":"20min"},{"summary":"Array declarations should include an explicit size specification","type":"Code Smell","defaultSeverity":"Major","description":"<p>It is possible to declare an array without explicitly specifying its size, but using an explicit size declaration is clearer, and is therefore\npreferred.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint arr1 [ ];  // Noncompliant; nothing specified\nint arr2 [ ] = { [0] = 1, [12] = 36, [4] = 93 }; // Noncompliant; highest index determines size. May be difficult to spot\nint pirate [ ] = { 2, 4, 8, 42, 501, 90210, 7, 1776 }; // Noncompliant; size is implicit, not explicit\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint arr1 [10];\nint arr2 [13] = { [0] = 1, [12] = 36, [4] = 93 };\nint pirate [10] = { 2, 4, 8, 42, 501, 90210, 7, 1776 }; // Implicitly-assigned size was 8. Desired size was 10.\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 8.12 - When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by\n  initialisation </li>\n  <li> MISRA C++:2008, 3-1-3 - When an array is declared, its size shall either be stated explicitly or defined implicitly by initialization </li>\n  <li> MISRA C:2012, 8.11 - When an array with external linkage is declared, its size should be explicitely specified </li>\n  <li> MISRA C:2012, 9.5 - Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/HQEOAQ\">CERT, ARR02-C.</a> - Explicitly specify array bounds, even if implicitly\n  defined by an initializer </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/_IAyAQ\">CERT, CTR02-CPP.</a> - Explicitly specify array bounds, even if implicitly\n  defined by an initializer </li>\n</ul>","debt":"2min"},{"summary":"Empty \"case\" clauses that fall through to the \"default\" should be omitted","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Empty <code>case</code> clauses that fall through to the default are useless. Whether or not such a <code>case</code> is present, the\n<code>default</code> clause will be invoked. Such <code>case</code>s simply clutter the code, and should be removed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch(ch)\n{\n  case 'a' :\n    handleA();\n    break;\n  case 'b' :\n    handleB();\n    break;\n  case 'c' :  // Noncompliant\n  default:\n    handleTheRest();\n    break;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch(ch)\n{\n  case 'a' :\n    handleA();\n    break;\n  case 'b' :\n    handleB();\n    break;\n  default:\n    handleTheRest();\n    break;\n}\n</pre>","debt":"1min"},{"summary":"Nested blocks of code should not be left empty","type":"Code Smell","defaultSeverity":"Major","description":"<p>Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid foo()\n{\n  int x;\n  if (x == 42)\n  {                     /* Noncompliant */\n    /* do nothing */\n  }\n  else\n  {\n    printf(\"x != 42\");\n  }\n}\n\nvoid bar()\n{                       /* Compliant - functions are not nested blocks */\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid foo()\n{\n  int x;\n  if (x != 42)\n  {                     /* Compliant */\n    printf(\"x != 42\");\n  }\n}\n\n/* ... */\n</pre>\n<h2>Exceptions</h2>\n<p>When a block contains a comment, this block is not considered to be empty.</p>","debt":"5min"},{"summary":"\"final\" classes should not have \"virtual\" functions","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Since <code>final</code> classes can't be extended, indicating that functions in such a class are overrideable by adding the <code>virtual</code>\nspecifier is possibly misguided, and definitely confusing.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Base {\n  virtual void f1();\n};\n\nclass C final : Base {\n  virtual void f1();  // Noncompliant\n  virtual void f2();  // Noncompliant\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Base {\n  virtual void f1();\n};\n\nclass C final : Base {\n  void f1() override;\n  void f2();\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href='/coding_rules#rule_key=cpp%3AS3471'>S3471</a> - \"override\" or \"final\" should be used instead of \"virtual\" </li>\n</ul>","debt":"2min"},{"summary":"Control should not be transferred into a complex logic block using a \"goto\" or a \"switch\" statement","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Having a <code>switch</code> and its cases wholly encompassed by a control structure such as a <code>try</code>, <code>@try</code>,\n<code>catch</code>, <code>@catch</code>, or a loop is perfectly acceptable. (<code>try</code> and <code>catch</code> are used hereafter to refer to\nboth variants.) It is also acceptable to have a <code>goto</code> and its target label wholly encompassed in a control structure. </p>\n<p>What is not acceptable is using a <code>goto</code> or <code>case</code> to suddenly jump into the body of a <code>try</code>, <code>catch</code>,\nObjective-C <code>@finally</code>, or loop structure. Tangling labels or <code>switch</code> blocks with other control structures results in code that\nis difficult, if not impossible to understand. More importantly, when it compiles (some of these constructs won't compile under ISO-conformant\ncompilers), it can lead to unexpected results. Therefore this usage should be strictly avoided.</p>\n<p>This C++ code sample, which is also applicable to Objective-C if <code>try</code> and <code>catch</code> are converted to <code>@try</code> and\n<code>@catch</code>, demonstrates jumping into a <code>switch</code> and into a <code>try</code> and <code>catch</code> :</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid f ( int32_t i )\n{\n  if ( 10 == i )\n  {\n    goto Label_10; // Noncompliant; goto transfers control into try block\n  }\n\n  if ( 11 == i )\n  {\n    goto Label_11; // Noncompliant; goto transfers control into catch block\n  }\n\n  switch ( i )\n  {\n    case 1:\n      try\n      {\n        Label_10:\n        case 2:  // Noncompliant; switch transfers control into try block\n          // Action\n          break;\n      }\n      catch ( ... )\n      {\n        Label_11:\n        case 3: // Noncompliant; switch transfers control into catch block\n          // Action\n          break;\n      }\n      break;\n    default:\n    {\n      // Default Action\n      break;\n    }\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid f ( int32_t i )\n{\n  switch ( i )\n  {\n    case 1:\n    case 2:\n      // Action\n      break;\n    case 3:\n      // Action\n      break;\n    case 10:\n\n    default:\n    {\n      // Default Action\n      break;\n    }\n  }\n\n  try\n  {\n    if ( 2 == i || 10 == i)\n    {\n      // Action\n    }\n  }\n  catch ( ... )\n  {\n    if (3 == i || 11 == i)\n    {\n      // Action\n    }\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 15-0-3 - Control shall not be transferred into a try or catch block using goto or switch statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/DgDFAQ\">CERT, MSC20-C.</a> - Do not use a switch statement to transfer control into a\n  complex block </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/wwDAAQ\">CERT, MSC20-CPP.</a> - Do not use a switch statement to transfer control into a\n  complex block </li>\n</ul>","debt":"15min"},{"summary":"An exception object should not have pointer type","type":"Bug","defaultSeverity":"Critical","description":"<p>If an exception object of pointer type is thrown and that pointer refers to a dynamically created object, then it may be unclear which function is\nresponsible for destroying it, and when. This ambiguity does not exist if the object is thrown by value and caught by reference.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass E\n{\n  // Implementation\n};\n\nvoid fn ( int16_t i )\n{\n  static E e1;\n  E * e2 = new E;\n  if ( i &gt; 10 )\n  {\n    throw ( &amp;e1 ); // Non-compliant  pointer type thrown\n  }\n  else\n  {\n    throw ( e2 ); // Non-compliant  pointer type thrown\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass E\n{\n  // Implementation\n};\n\nvoid fn ( int16_t i )\n{\n  static E e;\n  throw ( &amp;e ); // Compliant  reference type thrown\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 15-0-2 - An exception object should not have pointer type. </li>\n</ul>","debt":"10min"},{"summary":"Non-exception types should not be caught","type":"Code Smell","defaultSeverity":"Major","description":"<p>Throwing as an exception an object that is not derived from <code>std::exception</code> is a bad practice. It is usually unreliable, meaningless,\nand a source of type clashes.</p>\n<p>For the same reason, catching a non-exception type is a sign that your application has a bad exception-handling design. You should use standard\nexception types or create your own exception types that inherit at some level from <code>std::exception</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntry {\n  /* code that can throw: 42 */\n} catch (int ex) { // Noncompliant\n  if (ex == 42) {\n    /*...*/\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntry {\n  /* code that can throw: std::domain_error(\"User ID not found.\") */\n} catch (const std::domain_error&amp; ex) {\n  /*...*/\n}\n</pre>","debt":"20min"},{"summary":"Lambda return types should be implicit","type":"Code Smell","defaultSeverity":"Minor","description":"<p>It is a best practice to make lambda return types implicit. First and foremost, doing so avoids implicit conversions which could result in data or\nprecision loss. Second, omitting the return type helps future-proof the code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[](int i) -&gt; int // Noncompliant\n{ return i + 42; }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[](int i)\n{ return i + 42; }\n</pre>","debt":"2min"},{"summary":"Values should not be uselessly incremented","type":"Bug","defaultSeverity":"Major","description":"<p>A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint pickNumber() {\n  int i = 0;\n  int j = 0;\n\n  i = i++; // Noncompliant; i is still zero\n\n  return j++; // Noncompliant; 0 returned\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint pickNumber() {\n  int i = 0;\n  int j = 0;\n\n  i++;\n  return ++j;\n}\n</pre>","debt":"5min"},{"summary":"Non-exception types should not be thrown","type":"Code Smell","defaultSeverity":"Major","description":"<p>Just because you <em>can</em> stick your hand in a blender, that doesn't mean you <em>should</em>. Similarly, you <em>can</em> <code>throw</code>\nanything, but that doesn't mean you <em>should</em> <code>throw</code> something that's not derived at some level from\n<code>std::exception</code>.</p>\n<p>If you can't find an existing exception type that suitably conveys what you need to convey, then you should extend <code>std::exception</code> to\ncreate one.</p>\n<p>Specifically, part of the point of throwing exceptions is to communicate about the conditions of the error, but primitives have far less ability to\ncommunicate meaningfully than <code>exception</code>s. And, the creation of some other object type could itself <code>throw</code> an exception,\nresulting in program termination.</p>\n<p>Further, <code>catch</code>ing non-exception types is painful and fraught with the potential for (further) error.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nthrow 42;                               // Noncompliant\nthrow \"Invalid negative index.\";        // Noncompliant\nthrow std::string(\"Permission denied\"); // Noncompliant\nthrow nullptr;                          // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nthrow std::domain_error(\"User ID not found.\");\nthrow std::out_of_range(\"Invalid negative index.\");\nthrow std::system_error(EACCES, std::system_category());\nthrow std::invalid_argument(\"Unexpected null 'user_id' argument.\");\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 15-1-2 - NULL shall not be thrown explicitly. </li>\n</ul>","debt":"20min"},{"summary":"Exceptions should not be ignored","type":"Code Smell","defaultSeverity":"Minor","description":"<p>When exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid save() {\n  try {\n    saveDocument();\n  } catch (const std::exception&amp; ex) {\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid save() {\n  try {\n    saveDocument();\n  } catch (const std::exception&amp; ex) {\n    log &lt;&lt; \"Exception while saving the document: \" &lt;&lt; ex.what();\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/391.html\">MITRE, CWE-391</a> - Unchecked Error Condition </li>\n</ul>","debt":"1h"},{"summary":"Control flow statements \"if\", \"for\", \"while\", \"switch\" and \"try\" should not be nested too deeply","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Nested <code>if</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>switch</code> and <code>try</code> statements is a key\ningredient for making what's known as \"Spaghetti code\".</p>\n<p>Such code is hard to read, refactor and therefore maintain.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold of 3:</p>\n<pre>\n  if (condition1) {                  // Compliant; depth = 1\n    /* ... */\n    if (condition2) {                // Compliant; depth = 2\n      /* ... */\n      for(int i = 0; i &lt; 10; i++) {  // Compliant; depth = 3, not exceeding the limit\n        /* ... */\n        if (condition4) {            // Noncompliant; depth = 4\n          if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4\n            /* ... */\n          }\n          return;\n        }\n      }\n    }\n  }\n</pre>\n<h2>Exceptions</h2>\n<p>Each use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow\nstatement.</p>\n<pre>\n  #define FOREACH(V,ARR) if(ARR!=nullptr) for(int V=0; V&lt;(sizeof(ARR)/sizeof(ARR[0])); V++)\n\n  if (condition1) {       // Compliant; depth = 1\n    if (condition2) {     // Compliant; depth = 2\n      FOREACH(i, arr) {     // Compliant; depth = 3 (not 4)\n        if (condition3) {   // Noncompliant; depth = 4\n          /* ... */\n        }\n      }\n    }\n  }\n</pre>","debt":"10min"},{"summary":"Bit fields should not be used","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>The real need for bit fields is narrow and highly specialized. Previously, they were used to save memory, but that's less a concern in modern\nsystems than are the extra instructions required to interact with them. Today, they may be needed in direct hardware interaction, but since their\nbehavior is platform-dependent, getting them right can be tricky, and since their use is increasingly rare these days, they're likely to confuse\nmaintainers. For these reasons, it's simpler and more performant to use another field type instead of bit fields.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nunsigned int b1 : 3;  // Noncompliant\nunsigned char b2 : 3;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nunsigned int b1;\nunsigned char b2;\n</pre>","debt":"10min"},{"summary":"Default parameters should not be defined","type":"Code Smell","defaultSeverity":"Major","description":"<p>Setting method parameter defaults seems like a tidy way to make a method more usable. However, function pointers to methods with defaulted\nparameters can be confusing, because the function signature may not seem to match the call signature. Therefore, the use of multiple, overloaded\nmethods is preferred.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid HelloWorld (string name=\"World\")\n{\n    cout &lt;&lt; \"Hello \" &lt;&lt; name &lt;&lt; endl;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid HelloWorld (string name)\n{\n    cout &lt;&lt; \"Hello \" &lt;&lt; name &lt;&lt; endl;\n}\n\nvoid HelloWorld ()\n{\n    HelloWorld(\"World\");\n}\nstring Foo (string\n</pre>\n<h3>See also</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=cpp%3AS3719'>S3719</a> </li>\n</ul>","debt":"5min"},{"summary":"Digraphs should not be used","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>The use of digraphs may not meet developer expectations.</p>\n<p>The digraphs are: </p>\n<ul>\n  <li> <code>&lt;%</code> </li>\n  <li> <code>%&gt;</code> </li>\n  <li> <code>&lt;:</code> </li>\n  <li> <code>:&gt;</code> </li>\n  <li> <code>%:</code> </li>\n  <li> <code>%:%:</code> </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntemplate &lt;typename T&gt;\nclass A\n{\n  public:\n    template&lt;int32_t i&gt;\n    void f2();\n};\n\nvoid f(A&lt;int32_t&gt; * a&lt;:10:&gt;)    /* Noncompliant - usage of '&lt;:' instead of '[' and ':&gt;' instead of ']' */\n&lt;%                              /* Noncompliant - usage of '&lt;%' instead of '{' */\n  a&lt;:0:&gt;-&gt;f2&lt;20&gt;();             /* Noncompliant - usage of '&lt;:' and ':&gt;' */\n%&gt;                              /* Noncompliant - usage of '%&gt;' instead of '}' */\n</pre>\n<h2>Compliant Solution</h2>\n<pre>/* ... */\n\nvoid f(A&lt;int32_t&gt; * a[10])      /* Compliant */\n{                               /* Compliant */\n  a[0]-&gt;f2&lt;20&gt;();               /* Compliant */\n}                               /* Compliant */\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 2-5-1 - Digraphs should not be used. </li>\n</ul>","debt":"5min"},{"summary":"Functions should not be too complex","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The Cyclomatic Complexity of functions should not exceed a defined threshold. Complex code may perform poorly and can be difficult to test\nthoroughly.</p>","debt":"10min"},{"summary":"\"<time.h>\" should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Includes <code>time</code>, <code>strftime</code>. This library is associated with clock times. Various aspects are implementation dependent or\nunspecified, such as the formats of times. If any of the facilities of <code>time.h</code> are used, then the exact implementation for the compiler\nbeing used must be determined, and a deviation raised.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;time.h&gt;  /* Noncompliant */\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.12 - The time handling functions of library &lt;time.h&gt; shall not be used. </li>\n  <li> MISRA C:2012, 21.10 - The Standard Library time and date functions shall not be used </li>\n</ul>","debt":"4h"},{"summary":"Recursion should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Recursion is a powerful tool, but it can be tricky to get right. Getting it wrong can lead to stack overflow errors and cause system problems. Even\nwhen you do get it right, recursive code can be difficult to understand, perhaps leading to maintenance problems in the future. Therefore recursion\nshould be avoided in general and used only with due deliberation and caution when it is strictly necessary.</p>\n<p>This rule checks for direct recursion (when a function calls itself).</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint pow(int num, int exponent) {\n  if (exponent &gt; 1) {\n    num = num * pow(num, exponent-1);  // Noncompliant; direct recursion\n  }\n  return num;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint pow(int num, int exponent) {\n  int val = num;\n  while (exponent &gt; 0) {\n    val *= num;\n    --exponent;\n  }\n  return val;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.2 - Functions shall not call themselves, either directly or indirectly. </li>\n  <li> MISRA C++:2008, 7-5-4 - Functions should not call themselves, either directly or indirectly. </li>\n  <li> MISRA C:2012, 17.2 - Functions shall not call themselves, either directly or indirectly </li>\n</ul>","debt":"30min"},{"summary":"Sections of code should not be \"commented out\"","type":"Code Smell","defaultSeverity":"Major","description":"<p>Programmers should not comment out code as it bloats programs and reduces readability.</p>\n<p>Unused code should be deleted and can be retrieved from source control history if required.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 2.4 - Sections of code should not be \"commented out\". </li>\n  <li> MISRA C++:2008, 2-7-2 - Sections of code shall not be \"commented out\" using C-style comments. </li>\n  <li> MISRA C++:2008, 2-7-3 - Sections of code should not be \"commented out\" using C++ comments. </li>\n  <li> MISRA C:2012, Dir. 4.4 - Sections of code should not be \"commented out\" </li>\n</ul>","debt":"5min"},{"summary":"Track comments matching a regular expression","type":"Code Smell","defaultSeverity":"Major","description":"<p>This rule template can be used to create rules which will be triggered when a comment matches a given regular expression.</p>\n<p>For example, one can create a rule with the regular expression <code>.*REVIEW.*</code> to match all comment containing \"REVIEW\".</p>\n<p>Note that, in order to match REVIEW regardless of the case, the <code>(?i)</code> modifier should be prepended to the expression, as in\n<code>(?i).*REVIEW.*</code>.</p>"},{"summary":"Parameters in a function prototype should be named","type":"Code Smell","defaultSeverity":"Major","description":"<p>Naming the parameters in a function prototype helps identify how they'll be used by the function, thereby acting as a thin layer of documentation\nfor the function.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid divide (int, int);\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid divide (int numerator, int denominator);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.3 - Identifiers shall be given for all of the parameters in a function prototype declaration </li>\n  <li> MISRA C:2012, 8.2 - Function types shall be in prototype form with named parameters </li>\n</ul>","debt":"5min"},{"summary":"Functions without parameters should be declared with parameter type \"void\"","type":"Code Smell","defaultSeverity":"Critical","description":"<p>There is a real, functional difference between a function with an empty parameter list and one with an explicitly <code>void</code> parameter list:\nIt is possible to pass parameters to a function with an empty list; the compiler won't complain. That is not the case for a function with a\n<code>void</code> list. Thus, it is possible, and even easy to invoke empty-list functions incorrectly without knowing it, and thereby introduce the\nkind of subtle bug that can be very difficult to track down.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid myfunc ();  // Noncompliant\n\n//...\n\nvoid otherFunc() {\n  int a = 4;\n  //...\n  myfunc(a); // Compiler allows this\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid myfunc ( void );\n\n//...\n\nvoid otherFunc() {\n  int a = 4;\n  //...\n  myfunc(a); // Compiler error!\n}\n\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.5 - Functions with no parameters shall be declared with parameter type void </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/9YAzAg\">CERT, DCL20-C.</a> - Explicitly specify void when a function accepts no\n  arguments </li>\n</ul>","debt":"1min"},{"summary":"\"explicit\" should be used on single-parameter constructors and conversion operators","type":"Code Smell","defaultSeverity":"Critical","description":"<p>If you invoked a method with arguments of the wrong type, you would typically expect an error at compile time (if not in the IDE). However, when\nthe expected parameter is a class with a single-argument constructor, the compiler will implicitly pass the method argument to that constructor to\nimplicitly create an object of the correct type for the method invocation. Alternately, if the wrong type has a conversion operator to the correct\ntype, the operator will be called to create an object of the needed type.</p>\n<p>But just because you <em>can</em> do something, that doesn't mean you <em>should</em>, and using implicit conversions makes the execution flow\ndifficult to understand. Readers may not notice that a conversion occurs, and if they do notice, it will raise a lot of questions: Is the source type\nable to convert to the destination type? Is the destination type able to construct an instance from the source? Is it both? And if so, which method is\ncalled by the compiler? </p>\n<p>Moreover, implicit promotions can lead to unexpected behavior, so they should be prevented by using the <code>explicit</code> keyword on\nsingle-argument constructors and (C++11) conversion operators. Doing so will prevent the compiler from performing implicit conversions.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct Bar {\n};\n\nstruct Foo {\n  Foo(Bar&amp; bar); // Noncompliant; allow implicit conversion from 'Bar' to 'Foo'\n};\n\nstruct Baz {\n  operator Foo(); // Noncompliant; allow implicit conversion from 'Baz' to 'Foo'\n};\n\nvoid func(const Foo&amp; b); // this function needs a 'Foo' not a 'Bar' nor a 'Baz'\n\nint test(Bar&amp; bar, Baz&amp; baz) {\n  func(bar); // implicit conversion using Foo::Foo(Bar&amp; bar)\n  func(baz); // implicit conversion using Baz::operator Foo()\n  func(baz);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct Bar {\n};\n\nstruct Foo {\n  explicit Foo(Bar&amp; bar); // Compliant, using \"explicit\" keyword\n};\n\nstruct Baz {\n  Foo asFoo();             // Compliant, explicit function\n  explicit operator Foo(); // Compliant, using C++11 \"explicit\" keyword for conversion function\n};\n\nvoid func(const Foo&amp; b); // this function needs a 'Foo' not a 'Bar' nor a 'Baz'\n\nint test(Bar&amp; bar, Baz&amp; baz) {\n  func(Foo(bar));              // explicit conversion using Foo::Foo(Bar&amp; bar)\n  func(baz.asFoo());           // explicit conversion using Baz::asFoo()\n  func(static_cast&lt;Foo&gt;(baz)); // explicit conversion using Baz::operator Foo()\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 12-1-3 - All constructors that are callable with a single argument of fundamental type shall be declared <code>explicit</code>.\n  </li>\n  <li> <a\n  href=\"https://www.securecoding.cert.org/confluence/display/cplusplus/OOP01-CPP.+Be+careful+with+the+definition+of+conversion+operators\">CERT,\n  OOP01-CPP.</a> - Be careful with the definition of conversion operators </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/WA0\">CERT, OOP09-CPP.</a> - Ensure that single-argument constructors are marked\n  \"explicit\" </li>\n</ul>","debt":"2min"},{"summary":"C++ comments should be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>C++ comments (<code>//</code>) require fewer keystrokes, and take less space. Perhaps most importantly, they do not have the nesting problems that\nC-style comments do. Therefore C++ comments are preferred.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n/* this is my comment ... */\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// this is my comment ...\n</pre>\n<h2>Exceptions</h2>\n<p>Because a C++ header file may be included by a C source file, header files are ignored by this rule.</p>","debt":"2min"},{"summary":"Track \"TODO\" and \"FIXME\" comments that do not contain a reference to a person","type":"Code Smell","defaultSeverity":"Minor","description":"<p>TODO and FIXME comments are typically intended to be short-lived; they are placeholders and reminders that programmers leave for themselves.\nUnfortunately, even with the best of intentions, those comments are not always acted on and removed in a timely manner. Thus, they can become\nmysterious, lingering cruft in a code base, reducing both readability and understand-ability.</p>\n<p>This rule flags all FIXME and TODO comments that do not have an attribution matching the specified regular expression immediately after the FIXME\nor TODO. Ideally, such comments will also contain information about what needs to be fixed or done, but this rule does not enforce that.</p>\n<h2>Noncompliant Code Example</h2>\n<p>Using the default regular expression: <code>[ ]*\\([ _a-zA-Z0-9@.]+\\)</code>:</p>\n<pre>\n// TODO\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// TODO(ganncamp) per the business partners, more checks needed\n</pre>"},{"summary":"Partial specialization syntax should not be used for function templates","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Class templates can be explicitly or partially specialized. But according to the C++ standard, function templates cannot be partially specialized.\nUnder certain conditions, the Microsoft compiler will silently ignore the confusing application of partial specialization syntax to a function, but\nother compilers will raise an error for it and fail compilation.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntemplate&lt;typename T&gt;\nvoid fun(T p);\n\ntemplate&lt;typename T&gt;\nvoid fun&lt;T&gt;(T p) { // Noncompliant\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntemplate&lt;typename T&gt;\nvoid fun(T p);\n\ntemplate&lt;typename T&gt;\nvoid fun(T p) {\n  // ...\n}\n</pre>","debt":"30min"},{"summary":"\"switch case\" clauses should not have too many lines of code","type":"Code Smell","defaultSeverity":"Major","description":"<p>The <code>switch</code> statement should be used only to clearly define some new branches in the control flow. As soon as a <code>case</code>\nclause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of\n<code>case</code> clause should be extracted in a dedicated function.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold of 5:</p>\n<pre>\nswitch (myVariable) {\n  case 0: // 6 lines till next case\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    break;\n  case 1:\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch (myVariable) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n  // ...\n}\n// ...\nvoid doSomething(){\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n}\n</pre>","debt":"5min"},{"summary":"Comparison operators should not be virtual","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Making a comparison operator <code>virtual</code> implies that you want to compare objects of different types by overriding\n<code>operator==</code>, for instance, in a subclass to compare instances of the base class with instances of the subclass. But polymorphic comparison\noperators are very difficult to get right, and are actually questionable in concept. After all, can two objects with only a few common members really\nbe equal?</p>\n<p>This rule raises issues on <code>virtual</code> comparison operators.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct Foo {\n  virtual bool operator==(const Foo &amp;other) const; // Noncompliant\n  virtual bool operator!=(const Foo &amp;other) const; // Noncompliant\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct Foo {\n  bool operator==(const Foo &amp;other) const;\n  bool operator!=(const Foo &amp;other) const;\n};\n</pre>","debt":"1h"},{"summary":"\"::\" operator should be used to access global variables and functions","type":"Code Smell","defaultSeverity":"Major","description":"<p>While it is possible to access a global variable or function without using the <code>::</code> operator, it's considered by most to be misleading\nbecause it might imply to the readers of your code that this is a local or class variable/function and not a global one. It also allows more freedom\nin naming local variables without the chance of clashing with global names.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint a = 10;\nint main()\n{\n  ...\n  int b = a;    // Noncompliant\n  ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint a = 10;\nint main()\n{\n  ...\n  int b = ::a;    // Compliant\n  ...\n}\n</pre>","debt":"2min"},{"summary":"Functions without parameters should not use \"(void)\"","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Explicitly specifying a <code>void</code> parameter list is required in C, but optional in C++. Using <code>void</code> for a parameter-less\nfunction decreases its readability. The at-a-glance impression is that the function <em>does</em> take a parameter, and it takes a second look to\nascertain that it does not. Therefore the more compact notation is preferred.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint fun(void);\n\nint fun(void) {\n  ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint fun();\n\nint fun() {\n  ...\n}\n</pre>","debt":"2min"},{"summary":"Switch statement conditions should not have essentially boolean type","type":"Code Smell","defaultSeverity":"Minor","description":"<p>When there is only a single condition to test, you have the option of using either a <code>switch</code> statement or an <code>if</code>-<code>else\nif</code>-<code>else</code> statement. For a larger set of potential values, a <code>switch</code> can be easier to read, but when the condition being\ntested is essentially boolean, then an <code>if</code>/<code>else</code> statement should be used instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n_Bool b = p &gt; 0;\nswitch (b) { // Noncompliant\n...\n}\nswitch (x == 0) { // Noncompliant\n...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n_Bool b = p &gt; 0;\nif (b) {\n...\n} else {\n...\n}\nif (x == 0) {\n...\n} else {\n...\n}\n</pre> \n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.4 - A switch expression shall not represent a value that is effectively Boolean </li>\n  <li> MISRA C++:2008, 6-4-7 - The condition of a switch statement shall not have bool type </li>\n  <li> MISRA C:2012, 16.7 - A switch-expression shall not have essentially Boolean type </li>\n</ul>","debt":"10min"},{"summary":"Functions should not be defined with a variable number of arguments","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Passing arguments via an ellipsis bypasses the type checking performed by the compiler. Additionally, passing an argument with non-POD class type\nleads to undefined behavior. Note that the rule specifies \"defined\" (and not \"declared\") so as to permit the use of existing library functions.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid MyPrintf ( char_t * pFormat, ... )\t// Noncompliant\n{\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.1 - Functions shall not be defined with a variable number of arguments. </li>\n  <li> MISRA C++:2008, 8-4-1 - Functions shall not be defined using the ellipsis notation. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/i4CW\">CERT, DCL50-CPP.</a> - Do not define a C-style variadic function </li>\n</ul>","debt":"30min"},{"summary":"Ambiguous constructs should not be used","type":"Bug","defaultSeverity":"Major","description":"<p>Like a clever insect posing as a leaf, there are constructs in C++ which look like variable declarations, but which are actually interpreted by the\ncompiler as function or function pointer declarations. Beyond the problem of confusing maintainers, it's highly likely in such cases that what the\ncoder intended is not what the compiler will do.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid doWork(Status status) {\n  Lock lock();  // Noncompliant; declares function named \"lock\"\n  ...\n  Form form(ProgressBar(status)); // Noncompliant; declares function named \"form\" with \"status\" parameter\n  ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doWork(Status status) {\n  Lock lock;  // remove the parentheses to declare a variable\n  ...\n  Form form((ProgressBar(status))); // add a pair of parentheses to declare a variable\n  ...\n}\n</pre>\n<p>Since C++11 you can also use direct initialization to declare a variable:</p>\n<pre>\nvoid doWork(Status status) {\n  Lock lock{};\n  ...\n  Form form{ProgressBar{status}};\n  ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/zwCyAQ\">CERT, DCL53-CPP.</a> - Do not write syntactically ambiguous declarations </li>\n</ul>","debt":"5min"},{"summary":"Null pointers should not be dereferenced","type":"Bug","defaultSeverity":"Major","description":"<p>A pointer to null (the 0 memory address) should never be dereferenced/accessed. Doing so will at best cause abrupt program termination, without the\nability to run any cleanup processes. At worst, it could expose debugging formation that would be useful to an attacker or it could allow an attacker\nto bypass security measures.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nchar *p1 = ... ;\nif (p1 == NULL &amp;&amp; *p1 == '\\t') { // Noncompliant, p1 will be dereferenced IFF it is null\n  // ...\n}\n\nchar *p2 = ... ;\nif (p2 != NULL) {\n    // ...\n}\n*p2 = '\\t'; // Noncompliant; potential null-dereference\n\nchar *p3, *p4;\np3 = NULL;\n// ...\np4 = p3;\n*p4;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nchar *p1 = ... ;\nif (p1 != NULL &amp;&amp; *p1 == '\\t') { // Compliant, *p1 cannot be evaluated when p1 is NULL\n  // ...\n}\n\nchar *p2 = ... ;\nif (p2 != NULL) {\n    // ...\n  *p2 = '\\t'; // Compliant\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/476.html\">MITRE, CWE-476</a> - NULL Pointer Dereference </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/PAw\">CERT, EXP34-C.</a> - Do not dereference null pointers </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ZwDOAQ\">CERT, EXP01-J.</a> - Do not use a null in a case where an object is required\n  </li>\n</ul>","debt":"10min"},{"summary":"Inheritance should be \"public\"","type":"Code Smell","defaultSeverity":"Minor","description":"<p>While it's possible for inheritance to be non-<code>public</code>, it is rarely justified, and complicates the use of the derived class. For\ninstance, inherited member visibility is diminished, and implicit and <code>static_cast</code> casts from the base class to the derived class won't\nwork. </p>\n<p>It is sometimes used to limit the base class functionality available in the derived class. When that's the desire, composition should be used\ninstead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass B : private A {  // Noncompliant\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass B : public A {\n  // ...\n}\n</pre>\n<p>or</p>\n<pre>\nclass B {\n  private:\n  A a;\n  // ...\n}\n</pre>","debt":"20min"},{"summary":"Closed resources should not be accessed","type":"Bug","defaultSeverity":"Blocker","description":"<p>Using the value of a pointer to a <code>FILE</code> object after the associated file is closed is undefined behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fun() {\n  FILE * pFile;\n  pFile = fopen(fileName, \"w\");\n\n  if (condition) {\n    fclose(pFile);\n    // ...\n  }\n\n  fclose(pFile); // Noncompliant, the file has already been closed\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid fun() {\n  FILE * pFile;\n  pFile = fopen(fileName, \"w\");\n\n  if (condition) {\n    // ...\n  }\n\n  fclose(pFile);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KAGQBw\">CERT, FIO46-C.</a> - Do not access a closed file </li>\n</ul>","debt":"15min"},{"summary":"Label names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate effectively. This rule checks that labels match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With default provided regular expression <code>[A-Z][A-Z0-9-_]++</code>:</p>\n<pre>\nexit:  // Noncompliant\n  doCleanup();\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nEXIT:  // Compliant\n  doCleanup();\n</pre>","debt":"5min"},{"summary":"Handlers in a single try-catch or function-try-block for a derived class and some or all of its bases should be ordered most-derived-first","type":"Bug","defaultSeverity":"Major","description":"<p>When testing to see if the type of an exception matches the type of a handler, a derived class exception will match with a handler for its base\nclass. If the base class handler is found before the handler for the derived class, the base class handler will be used. The derived class handler is\nunreachable code and can never be executed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// classes used for exception handling\nclass B { };\nclass D: public B { };\n// Using the classes from above ...\ntry\n{\n  // ...\n}\ncatch ( B &amp;b ) // Noncompliant  will catch derived classes as well\n{\n  // ...\n}\ncatch ( D &amp;d ) // Noncompliant  Derived class will be caught above\n{\n  // Any code here will be unreachable,\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// Using the same classes from above ...\ntry\n{\n  // ...\n}\ncatch ( D &amp;d ) // Compliant  Derived class caught before base class\n{\n  // ...\n}\ncatch ( B &amp;b ) // Compliant  Base class caught after derived class\n{\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 15-3-6 </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/8ADOAQ\">CERT, ERR54-CPP.</a> - Catch handlers should order their parameter types from\n  most derived to least derived </li>\n</ul>","debt":"5min"},{"summary":"Exception classes should be caught by reference","type":"Bug","defaultSeverity":"Major","description":"<p>When exception classes are caught by value, rather than by reference, slicing occurs, yielding an instance of the exception's base class, rather\nthan the potentially more specific exception class that was actually thrown. This means that only the base class' functions will be available; any\nadditional data or functionality that is offered by the extended class will not be accessible. Therefore exception classes should always be caught by\nreference.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntry\n{\n  // ...\n}\ncatch(ExceptionClass ex)\n{\n  //...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntry\n{\n  // ...\n}\ncatch(ExceptionClass &amp;ex)\n{\n  //...\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule doesn't raise an issue when no parameter name is provided for the exception.</p>\n<pre>\ntry {\n  // ...\n} catch(ExceptionClass) {\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 15-3-5 - A class type exception shall always be caught by reference </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/TAD5CQ\">CERT, ERR61-CPP.</a> - Catch exceptions by lvalue reference </li>\n</ul>","debt":"5min"},{"summary":"Dynamically allocated memory should be released","type":"Bug","defaultSeverity":"Blocker","description":"<p>Memory allocated dynamically with <code>calloc(...)</code>, <code>malloc(...)</code>, <code>realloc(...)</code> or <code>new</code> should be\nreleased when it's not needed anymore. Failure to do so will result in a memory leak that could bring the box to its knees.</p>\n<p>This rule raises an issue when memory is allocated and not freed in the same function. Allocated memory is ignored if a pointer to it is\n<code>return</code>ed to the caller or stored in a structure that's external to the function.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint fun() {\n  char* name = (char *) malloc (size);\n  if (!name) {\n    return 1;\n  }\n  // ...\n  return 0; // Noncompliant, memory pointed by \"name\" has not been released\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint fun() {\n  char* name = (char *) malloc (size);\n  if (!name) {\n    return 1;\n  }\n  // ...\n  free(name);\n  return 0;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://cwe.mitre.org/data/definitions/401.html\">MITRE, CWE-401</a> - Improper Release of Memory Before Removing Last Reference\n  ('Memory Leak') </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/twE\">MEM00-C.</a> - Allocate and free memory in the same module, at the same level of\n  abstraction </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIEyAQ\">CERT, MEM11-CPP.</a> - Allocate and free memory in the same module, at the same\n  level of abstraction </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/vQE\">CERT, MEM31-C.</a> - Free dynamically allocated memory when no longer needed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/rgCuAQ\">CERT, MEM12-CPP.</a> - Do not assume infinite heap space </li>\n</ul>","debt":"20min"},{"summary":"\"sizeof(sizeof(...))\" should not be used","type":"Bug","defaultSeverity":"Major","description":"<p>A call to <code>sizeof(sizeof(...))</code> is equivalent to <code>sizeof(size_t)</code>, and indicates a misuse or misunderstanding of the\n<code>sizeof</code> construct.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;string.h&gt;\n\nint main(int argc, char* argv[])\n{\n  char buffer[42];\n  char buffer2[sizeof(sizeof(buffer))]; /* Noncompliant - a single sizeof() was intended */\n\n  memcpy(buffer, \"Hello, world!\", strlen(\"Hello, world!\")+1);\n  memcpy(buffer2, buffer, sizeof(buffer)); /* Buffer overflow */\n\n  return 0;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include &lt;string.h&gt;\n\nint main(int argc, char* argv[])\n{\n  char buffer[42];\n  char buffer2[sizeof(buffer)]; /* Compliant */\n\n  memcpy(buffer, \"Hello, world!\", strlen(\"Hello, world!\")+1);\n  memcpy(buffer2, buffer, sizeof(buffer));\n\n  return 0;\n}\n</pre>","debt":"20min"},{"summary":"\"this\" should not be compared with null","type":"Code Smell","defaultSeverity":"Major","description":"<p>According to the C++ standard, <code>this</code> can never be null, so comparisons of the two are pointless at best. At worst, because of compiler\noptimizations, such comparisons could lead to null pointer dereferences or obscure, difficult-to-diagnose errors in production.</p>\n<p>This rule raises an issue when <code>this</code> is compared to <code>nullptr</code> or 0 or anything <code>#defined</code> as <code>nullptr</code>\nor 0, such as <code>NULL</code> in most environments.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass MyClass {\n  string name;\n\n  string GetName() {\n    if (this != 0) {  // Noncompliant\n      return name;\n    }\n    return 0;\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass {\n  string name;\n\n  string GetName() {\n    return name;\n  }\n}\n</pre>","debt":"5min"},{"summary":"\"const\" references to numbers should not be made","type":"Bug","defaultSeverity":"Major","description":"<p>There is no point in creating a <code>const</code> reference to a literal numeric value. Most likely the intent was not to create a reference, but\na constant value.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst int &amp; weekdayCount = 7;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst int weekdayCount = 7;\n</pre>","debt":"5min"},{"summary":"The unary \"&\" operator should not be overloaded","type":"Bug","defaultSeverity":"Major","description":"<p>Taking the address of an object of incomplete type, where the complete type contains a user declared <code>operator &amp;</code> leads to undefined\nbehavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// A.h\nclass A\n{\npublic:\n  A * operator &amp; ( );      // Noncompliant\n};\n\n// f1.cc\nclass A;\nvoid f ( A &amp; a )\n{\n  &amp;a;\t// uses built-in operator &amp;\n}\n\n// f2.cc\n#include \"A.h\"\nvoid f2 ( A &amp; a )\n{\n  &amp;a;\t// use user-defined operator &amp;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 5-3-3 - The unary &amp; operator shall not be overloaded. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/Bg0\">CERT, DCL10-CPP.</a> - Do not overload the ampersand, comma, logical AND or\n  logical OR operators </li>\n</ul>","debt":"1h"},{"summary":"Members should be initialized in the order they are declared","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Class members are initialized in the order in which they are declared in the class, not the order in which they appear in the class initializer\nlist. To avoid errors caused by order-dependent initialization, the order of members in the initialization list should match the order in which\nmembers are declared in a class.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;iostream&gt;\n\nclass C {\npublic:\n  int x;\n  int y;\n\n  C(int i) : y(i), x(y + 1) { }  // Noncompliant\n};\n\nint main() {\n  C c(1);\n  std::cout &lt;&lt; c.x &lt;&lt; \" \" &lt;&lt; c.y &lt;&lt; std::endl;  // prints 1 1\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/VADiAQ\">CERT, OOP53-CPP.</a> - Write constructor member initializers in the canonical\n  order </li>\n</ul>","debt":"5min"},{"summary":"Function names should be used either as a call with a parameter list or with the \"&\" operator","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Using a \"bald\" function name is likely a bug. Rather than testing the return value of a function with a <code>void</code> parameter list, it\nimplicitly retrieves the address of that function in memory. If that's truly what's intended, then it should be made explicit with the use of the\n<code>&amp;</code> (address-of) operator. If it's not, then a parameter list (even an empty one) should be added after the function name.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint func(void) {\n  // ...\n}\n\nvoid f2(int a, int b) {\n  // ...\n  if (func) {  // Noncompliant - tests that the memory address of func() is non-null\n    //...\n  }\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid f2(int a, int b) {\n  // ...\n  if (func()) {  // tests that the return value of func() &gt; 0\n    //...\n  }\n  // ...\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Callback functions are a common occurrence and are usually not passed with a preceding &amp;. There is however little ambiguity so this rule\nignores function identifiers when used as a parameter of a function call.</p>\n<pre>\nvoid foo() {\n  // ...\n}\n\nregisterEvent(AnEvent, foo);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.9 - A function identifier shall only be used with either a preceding &amp;, or with a parenthesized parameter list, which may\n  be empty. </li>\n  <li> MISRA C++:2008, 8-4-4 - A function identifier shall only be used to call the function or it shall be preceded by &amp;. </li>\n</ul>","debt":"10min"},{"summary":"Bit fields should be declared with appropriate types","type":"Code Smell","defaultSeverity":"Major","description":"<p>The use of any type other than <code>signed short</code>, <code>unsigned short</code>, <code>signed char</code>, <code>unsigned char</code>,\n<code>signed int</code>, <code>unsigned int</code> or <code>_Bool</code> for a bit field is implementation-defined, and therefore not portable.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint b:3; // Noncompliant - may have the range of values 0..7 or -4..3\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nunsigned int b:3;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 6.4 - Bit fields shall only be defined to be of type <em>unsigned int</em> or <em>signed int</em>. </li>\n  <li> MISRA C++:2008, 9-6-2 - Bit-fields shall be either <em>bool</em> type or an explicitly <em>unsigned</em> or <em>signed</em> integral type.\n  </li>\n  <li> MISRA C:2012, 6.1 - Bit-fields shall only be declared with an appropriate type </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/RAE\">CERT, INT12-C.</a> - Do not make assumptions about the type of a plain int\n  bit-field when used in an expression </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/uYAyAQ\">CERT, INT12-CPP.</a> - Do not make assumptions about the type of a plain int\n  bit-field when used in an expression </li>\n</ul>","debt":"2min"},{"summary":"Function exit paths should have appropriate return values","type":"Bug","defaultSeverity":"Critical","description":"<p>Every call to a function with a non-void return type is expected to return some value. Including a return path in a non-void function that does not\nexplicitly return a value results in undefined behavior. </p>\n<p>Conversely, every call to a function with a void return type is expected to not return any value. Returning a value from a void function probably\nindicates a programming error.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint my_func (int a)\n{\n  if (a &gt; 100)\n  {\n    return; // Noncompliant\n  }\n\n  if (a &gt; 80)\n  {\n    throw new Exception(); // Compliant\n  }\n\n  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint my_func (int a)\n{\n  if (a &gt; 100)\n  {\n    return 12;\n  }\n\n  if (a &gt; 80)\n  {\n    throw new Exception();\n  }\n\n  return a;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 16.8 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression </li>\n  <li> MISRA C++:2008, 8-4-3 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression\n  </li>\n  <li> MISRA C:2012, 17.4 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/394.html\">MITRE, CWE-394</a> - Unexpected Status Code or Return Value </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/goCGAg\">CERT, MSC37-C.</a> - Ensure that control never reaches the end of a non-void\n  function </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ZoCKC\">CERT, MSC52-CPP.</a> - Value-returning functions must return a value from all\n  exit paths </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/dICKC\">CERT, MSC53-CPP.</a> - Do not return from a function declared [[noreturn]] </li>\n</ul>","debt":"5min"},{"summary":"\"using\" directives should not be used","type":"Bug","defaultSeverity":"Minor","description":"<p>Using-directives add additional scopes to the set of scopes searched during name lookup. All identifiers in these scopes become visible,\nincreasing the possibility that the identifier found by the compiler does not meet developer expectations. Using-declarations or fully-qualified\nnames restricts the set of names considered to only the name explicitly specified, and so these are safer options.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnamespace NS1 {\n  int i1;\n  int j1;\n}\n\nusing namespace NS1; // Noncompliant\n\nnamespace NS2 {\n  int i2;\n  int j2;\n}\n\nusing NS2::j2; // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li>MISRA C++:2008, 7-3-4 - using-directives shall not be used.</li>\n</ul>","debt":"30min"},{"summary":"Binary operators should be overloaded as \"friend\" functions","type":"Code Smell","defaultSeverity":"Major","description":"<p>Member functions can only be used with an instance of a class. But <code>friend</code> functions can be used with an implicitly converted type. So\nloosening access privileges to <code>friend</code> on overloaded binary operators makes them more flexible. Specifically, with a <code>friend</code>\nfunction, the class instance can be on either the right or the left of the operator, but with a member function, it can only be on the left.</p>\n<p>This rule raises an issue for all non-<code>friend</code> overloaded binary operators except <code>=</code>, <code>[ ]</code>, and\n<code>-&gt;</code>, which cannot be overloaded as <code>friend</code> functions.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nbool operator==(const MyClass &amp;RHS);  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfriend bool operator==(const MyClass &amp;LHS, const MyClass &amp;RHS);\n</pre>","debt":"15min"},{"summary":"The \"delete\" operator should only be used for pointers","type":"Bug","defaultSeverity":"Major","description":"<p>The <code>delete</code> operator expects a pointer argument. Passing it an object may compile and seem to run (with an implicit cast to pointer\ntype) but it can result in unexpected behavior at runtime.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass CString {\npublic:\n  operator const char*();\n  // ...\n};\n\nvoid fun() {\n  CString str;\n  // ...\n  delete str;  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid fun() {\n  CString *pstr = new CString;\n  // ...\n  delete pstr;\n}\n</pre>","debt":"10min"},{"summary":"Functions/methods should not have too many lines","type":"Code Smell","defaultSeverity":"Major","description":"<p>A function that grows too large tends to aggregate too many responsibilities.</p>\n<p>Such functions inevitably become harder to understand and therefore harder to maintain. </p>\n<p>Above a specific threshold, it is strongly advised to refactor into smaller functions which focus on well-defined tasks.</p>\n<p>Those smaller functions will not only be easier to understand, but also probably easier to test.</p>","debt":"20min"},{"summary":"Comments should not be located at the end of lines of code","type":"Code Smell","defaultSeverity":"Minor","description":"<p>This rule verifies that single-line comments are not located at the ends of lines of code. The main idea behind this rule is that in order to be\nreally readable, trailing comments would have to be properly written and formatted (correct alignment, no interference with the visual structure of\nthe code, not too long to be visible) but most often, automatic code formatters would not handle this correctly: the code would end up less readable.\nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\na = b + c;   // This is a trailing comment that could be very very long\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// This very long comment is better placed before the line of code\na = b + c;\n</pre>","debt":"1min"},{"summary":"Appropriate char types should be used for character and integer values","type":"Code Smell","defaultSeverity":"Minor","description":"<p>There are three distinct <code>char</code> types, (plain) <code>char</code>, <code>signed char</code> and <code>unsigned char</code>. <code>signed\nchar</code> and <code>unsigned char</code> should only be used for numeric data, and plain <code>char</code> should only be used for character data.\nSince it is implementation-defined, the signedness of the plain <code>char</code> type should not be assumed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nsigned char a = 'a'; // Noncompliant, explicitly signed\nunsigned char b = '\\r'; // Noncompliant, explicitly unsigned\nchar c = 10; // Noncompliant\n\nunsigned char d = c; // Noncompliant, d is explicitly signed while c is not\nchar e = a; // Noncompliant, a is explicitly signed while e is not\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nchar a = 'a'; // Compliant, explicitly signed\nchar b = '\\r'; // Compliant, explicitly unsigned\nunsigned char c = 10; // Compliant, or\nsigned char c = 10; // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 6.1 - The plain char type shall be used only for the storage and use of character values </li>\n  <li> MISRA C:2004, 6.2 - signed and unsigned char type shall be used only for the storage and use of number values </li>\n  <li> MISRA C++:2008, 5-0-11 - The plain char type shall only be used for the storage and use of character values </li>\n  <li> MISRA C++:2008, 5-0-12 - signed char and unsigned char type shall only be used for the storage and use of numeric values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/-As\">CERT, INT07-C.</a> - Use only explicitly signed or unsigned char type for numeric\n  values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/rYAyAQ\">CERT, INT07-CPP.</a> - Use only explicitly signed or unsigned char type for\n  numeric values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/5AD7\">CERT, STR00-C.</a> - Represent characters using an appropriate type </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/IoEyAQ\">CERT, STR04-CPP.</a> - Use plain char for characters in the basic character set\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/JABi\">CERT, STR04-C.</a> - Use plain char for characters in the basic character set\n  </li>\n</ul>","debt":"10min"},{"summary":"typedefs that indicate size and signedness should be used in place of the basic types","type":"Code Smell","defaultSeverity":"Minor","description":"<p>The basic numeric types <code>char</code>, <code>int</code>, <code>short</code>, <code>long</code>, <code>float</code>, <code>double</code>, and\n<code>long double</code> should not be used. Instead, specific-length typedefs should be. This rule helps to clarify the size of the storage, but does\nnot guarantee portability because of the asymmetric behavior of integral promotion. </p>\n<p>Note that it is still important to understand the integer size of the implementation, and developers should be aware of the actual implementation\nof the typedefs under these definitions.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint function(unsigned short a) // Noncompliant\n{\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include &lt;stdint.h&gt;\nint32_t function(uint16_t a) // Compliant\n{\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 6.3 - typedefs that indicate size and signedness should be used in place of the basic types </li>\n  <li> MISRA C++:2008, 3-9-2 - typedefs that indicate size and signedness should be used in place of the basic numerical types </li>\n</ul>\n<h3>See Also</h3>\n<ul>\n  <li> MISRA C++ 2008 Section 6.5.0 on integral promotion </li>\n</ul>","debt":"10min"},{"summary":"The first operand of a conditional operator should have type bool","type":"Code Smell","defaultSeverity":"Minor","description":"<p>If an expression with type other than bool is used as the first operand of a conditional-operator, then its result will be implicitly converted to\nbool. The first operand shall contain an explicit test (yielding a result of type bool) in order to clarify the intentions of the developer.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fun(int *a, int *b) {\n  int *ptr = a ? a : b; // Noncompliant\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid fun(int *a, int *b) {\n  int *ptr = a != NULL ? a : b;\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 5-0-14 - The first operand of a conditional-operator shall have type bool. </li>\n</ul>","debt":"5min"},{"summary":"The ternary operator should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>While the ternary operator is pleasingly compact, its use can make code more difficult to read. It should therefore be avoided in favor of the more\nverbose <code>if</code>/<code>else</code> structure.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nprintf(\"%s\", (i&gt;10?\"yes\":\"no\"));\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (i &gt; 10) {\n  printf(\"yes\");\n} else {\n  printf(\"no\");\n}\n</pre>","debt":"5min"},{"summary":"\"public\", \"protected\" and \"private\" sections of a class should be declared in that order","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Coding conventions allow teams to work efficiently together. This rule checks that the <code>public</code> section of a class is declared first,\nfollowed by the <code>protected</code> section, and ending with the <code>private</code> section.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Point\n{\n  private:\n    String _color;\n    ...\n\n  protected:\n    ...\n\n  public:\n    String getColor();\n    String setColor();\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Point\n{\n  public:\n    String getColor();\n    String setColor();\n\n  protected:\n    ...\n\n  private:\n    String _color;\n    ...\n};\n</pre>","debt":"10min"},{"summary":"Constants should come first in equality tests","type":"Code Smell","defaultSeverity":"Minor","description":"<p>The result of the comparison is the same, regardless of whether the constant is on the left or right-hand side. But following this convention will\nhelp pinpoint the occasional error where <code>=</code> (assignment) is substituted for <code>==</code> (comparison). </p>\n<p>If the constant is on the right-hand side of the expression in such cases, the code will still compile and run - just not as expected. If the\nconstant is on the left-hand side, the error will be caught at the first attempt to compile.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ( var == constant )\nif ( pointer == NULL )\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif ( constant == var )\nif ( NULL == pointer )\n</pre>","debt":"10min"},{"summary":"Inheritance tree of classes should not be too deep","type":"Code Smell","defaultSeverity":"Major","description":"<p>Inheritance is certainly one of the most valuable concepts in object-oriented programming. It's a way to compartmentalize and reuse code by\ncreating collections of attributes and behaviors called classes which can be based on previously created classes. But abusing this concept by creating\na deep inheritance tree can lead to very complex and unmaintainable source code. Most of the time a too deep inheritance tree is due to bad object\noriented design which has led to systematically use 'inheritance' when for instance 'composition' would suit better.</p>","debt":"4h"},{"summary":"A \"struct\" should not have member functions","type":"Code Smell","defaultSeverity":"Major","description":"<p>While it is possible to define a struct with member functions in C++, the general expectation is that structs contain only data, and classes are\nused for data and methods. Thus, including a member function in a struct is likely to lead to confusion at best and should be avoided.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct S\n{\n  int x;\n  int y;\n  public:\n    int fun(); // Noncompliant\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct S\n{\n  int x;\n  int y;\n};\n</pre>","debt":"20min"},{"summary":"Condition-specific \"catch\" handlers should not be used after the ellipsis (catch-all) handler","type":"Bug","defaultSeverity":"Major","description":"<p>The catch-all handler should come last in a chain of <code>catch</code> or <code>@catch</code> statements because it catches everything, and any\nmore-specific <code>catch</code>/<code>@catch</code> that comes after it will never be used, even when the relevant condition occurs. </p>\n<p>This C++ code sample also applies to Objective-C.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid f1()\n{\n  try\n  {\n    // ...\n  }\n  catch (...)\n  {\n    // Handle all exception types\n  }\n  catch (int32_t i)  // Noncompliant - handler will never be called\n  {\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid f1()\n{\n  try\n  {\n    // ...\n  }\n  catch (int32_t i)  // Compliant - int handler\n  {\n    // Handle int exceptions\n  }\n  catch (...)        // Compliant - catch-all handler\n  {\n    // Handle all other exception types\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 15-3-7 - Where multiple handlers are provided in a single try-catch statement or function-try-block, any ellipsis (catch-all)\n  handler shall occur last. </li>\n</ul>","debt":"30min"},{"summary":"Generic exceptions should never be thrown","type":"Code Smell","defaultSeverity":"Major","description":"<p>If you throw a general exception type, such as <code>std::exception</code>, <code>std::logic_error</code> or <code>std::runtime_error</code>, it\nforces consumers to catch all exceptions, including unknown exceptions they don't necessarily know how to handle.</p>\n<p>Instead, either throw a subtype that already exists ( for example in <code>&lt;stdexcept&gt;</code> ), or create your own type that derives from a\nstandard one.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nthrow std::logic_error(\"Unexpected null 'user_id' argument.\"); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nthrow std::invalid_argument(\"Unexpected null 'user_id' argument.\");\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/397.html\">MITRE, CWE-397</a> - Declaration of Throws for Generic Exception </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/BoB3AQ\">CERT, ERR07-J.</a> - Do not throw RuntimeException, Exception, or Throwable\n  </li>\n</ul>","debt":"20min"},{"summary":"C libraries should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The use of C headers and therefore C functions in a C++ program, is sometimes necessary, but should be avoided in favor of C++ headers and\nfunctions.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;string.h&gt;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include &lt;cstring&gt;\n#include &lt;string&gt;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 18-0-1 - The C library shall not be used. </li>\n</ul>","debt":"20min"},{"summary":"Virtual functions should not have default arguments","type":"Code Smell","defaultSeverity":"Critical","description":"<p>It's best to avoid giving default argument initializers to virtual functions. While doing so is legal, the code is unlikely to be correctly\nmaintained over time and will lead to incorrect polymorphic code and unnecessary complexity in a class hierarchy.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Base {\npublic:\n  virtual void fun(int p = 42) { // Noncompliant\n    // ...\n  }\n};\n\nclass Derived : public Base {\npublic:\n  void fun(int p = 13) override { // Noncompliant\n    // ...\n  }\n};\n\nclass Derived2 : public Base {\npublic:\n  void fun(int p) override {\n    // ...\n  }\n};\n\nint main() {\n  Derived *d = new Derived;\n  Base *b = d;\n  b-&gt;fun(); // uses default argument 42\n  d-&gt;fun(); // uses default argument 13; was that expected?\n\n  Base *b2 = new Base;\n  Derived2 *d2 = new Derived2;\n  b2-&gt;fun(); // uses default argument 42\n  d2-&gt;fun(); // compile time error; was that expected?\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Base {\npublic:\n  void fun(int p = 42) { // non-virtual forwarding function\n    fun_impl(p);\n  }\nprotected:\n  virtual void fun_impl(int p) {\n    // ...\n  }\n};\n\nclass Derived : public Base {\nprotected:\n  void fun_impl(int p) override {\n    // ...\n  }\n};\n\nclass Derived2 : public Base {\nprotected:\n  void fun_impl(int p) override {\n    // ...\n  }\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/-YBS\">CERT, OOP04-CPP.</a> - Prefer not to give virtual functions default argument\n  initializers </li>\n</ul>\n<h3>See also</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=cpp%3AS1712'>S1712</a> </li>\n</ul>","debt":"20min"},{"summary":"Identifiers should not be longer than 31 characters","type":"Code Smell","defaultSeverity":"Major","description":"<p>In addition to being difficult to use, too-long variable names can limit code portability. The ISO standard requires that variable, type, function\nand label names be no more than 31 characters long. </p>\n<p>Note that 31 characters is an upper bound, rather than a length recommendation. Shorter names are better, as long as they're still\ncommunicative.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint this_is_a_very_long_identifier_that_definitely_should_be_renamed = 0;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint reasonable_identifier = 0;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 5.1 - Identifiers (internal and external) shall not rely on the significance of more than 31 character. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/QAU\">CERT, DCL23-C.</a> - Guarantee that mutually visible identifiers are unique </li>\n</ul>","debt":"10min"},{"summary":"Track parsing failures","type":"Code Smell","defaultSeverity":"Major","description":"<p>When the parser fails, it is possible to record the failure as an issue on the file. This way, not only is it possible to track the number of files\nthat do not parse but also to easily find out why they do not parse.</p>","debt":"0min"},{"summary":"Lines should not be too long","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.</p>","debt":"1min"},{"summary":"GNU extensions should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Proprietary compiler extensions can be handy, but they commit you to always using that compiler. This rule raises an issue when the following GNU\nextensions are used:</p>\n<ul>\n  <li> A array initializer without <code>=</code>, which has been obsolete since GCC 2.5 </li>\n  <li> A structure member initializer with a colon, which has been obsolete since GCC 2.5. </li>\n  <li> Case ranges </li>\n  <li> Ternary operator with omitted second operand </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct S {\n  int f;\n};\n\nstruct S s[] = {\n  [0] { // Noncompliant\n    f : 0 // Noncompliant\n  }\n};\n\nint fun(int p) {\n  switch (p) {\n    case 0 ... 1: // Noncompliant\n      do_the_thing();\n      break;\n    case 2:\n      //...\n  }\n\n  return p ?: 0; // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct S {\n  int f;\n};\n\nstruct S s[] = {\n  [0] = {\n    .f = 0\n  }\n};\n\nint fun(int p) {\n  switch (p) {\n    case 0:\n    case 1:\n      do_the_thing();\n      break;\n    case 2:\n      //...\n  }\n\n  return p ? p: 0;\n}\n</pre>","debt":"5min"},{"summary":"Variables should not be self-assigned","type":"Bug","defaultSeverity":"Major","description":"<p>There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid setValue(int value) {\n  value = value;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid setValue(int value) {\n  this-&gt;value = value;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"3min"},{"summary":"Non-empty statements should change control flow or have at least one side-effect","type":"Bug","defaultSeverity":"Major","description":"<p>Any statement (other than a null statement, which means a statement containing only a semicolon <code>;</code>) which has no side effect and does\nnot result in a change of control flow will normally indicate a programming error, and therefore should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint func(int a, int b) {\n  int result = 0;\n  a + b; // Noncompliant, no side effect.\n  return result;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint func(int a, int b) {\n  int result = a + b; // Compliant\n  return result;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/482\">MITRE, CWE-482</a> - Comparing instead of Assigning </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n  <li> MISRA C:2004, 14.2 - All non-null statements shall either have at least one side-effect however executed, or cause control flow to change.\n  </li>\n</ul>","debt":"10min"},{"summary":"The comma operator, \"&&\", and \"||\" should not be overloaded","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Overloaded versions of the comma and logical conjunction operators have the semantics of function calls whose sequence point and ordering semantics\nare different from those of the built- in versions. It may not be clear at the point of use that these operators are overloaded, and so developers may\nbe unaware which semantics apply.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include \"util.h\"\nclass A\n{\npublic:\n  UtilType getValue ( );\n  UtilType setValue ( UtilType const &amp; );\n};\nvoid f1 ( A &amp; a1, A &amp; a2 )\n{\n  a1.getValue ( ) &amp;&amp; a2.setValue ( 0 );\t// Short circuiting may occur\n}\nbool operator &amp;&amp; ( UtilType const &amp;,\n             UtilType const &amp; );                       // Noncompliant\nvoid f2 ( A &amp; a1, A &amp; a2 )\n{\na1.getValue ( ) &amp;&amp; a2.setValue ( 0 );     // Both operands evaluated if type returned has overloaded operator&amp;&amp;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 5-2-11 - The comma operator, &amp;&amp; operator and the || operator shall not be overloaded. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/Bg0\">CERT DCL10-CPP.</a> - Do not overload the ampersand, comma, logical AND or logical\n  OR operators </li>\n</ul>","debt":"2h"},{"summary":"Functions should not have too many parameters","type":"Code Smell","defaultSeverity":"Major","description":"<p>A long parameter list can indicate that a new structure should be created to wrap the numerous parameters or that the function is doing too many\nthings.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With a maximum number of 4 parameters:</p>\n<pre>\nvoid doSomething(int param1, int param2, int param3, int param4, int param5) {\n  ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doSomething(int param1, int param2, int param3, int param4) {\n  ...\n}\n</pre>","debt":"20min"},{"summary":"Header files should not contain unnamed namespaces","type":"Bug","defaultSeverity":"Major","description":"<p>An unnamed namespace will be unique within each translation unit. Any declarations appearing in an unnamed namespace in a header will refer to a\ndifferent entity in each translation unit, which is probably not the expected behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// Header.hpp\nnamespace                  // Noncompliant\n{\n  extern int32_t x;\n}\n</pre>\n<pre>\n// File1.cpp\n#include \"Header.cpp\"\n\nnamespace\n{\n  int32_t x;\n}\n\nvoid fn_a(void)\n{\n  x = 42;\n}\n</pre>\n<pre>\n// File2.cpp\n#include \"Header.cpp\"\n\nnamespace\n{\n  int32_t x;  // this is a different x than in File1.cpp\n}\n\nvoid fn_b(void)\n{\n  fn_a();                  // Is expected to initialize \"x\" to 42\n  if (x == 42)             // But does not, as there are 2 distinct \"x\" variables\n  {\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 7-3-3 - There shall be no unnamed namespaces in header files. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/7gB9CQ\">CERT, DCL59-CPP.</a> - Do not define an unnamed namespace in a header file\n  </li>\n</ul>","debt":"1h"},{"summary":"Standard outputs should not be used directly to log anything","type":"Code Smell","defaultSeverity":"Major","description":"<p>When logging a message there are several important requirements which must be fulfilled:</p>\n<ul>\n  <li> The user must be able to easily retrieve the logs </li>\n  <li> The format of all logged message must be uniform to allow the user to easily read the log </li>\n  <li> Logged data must actually be recorded </li>\n  <li> Sensitive data must only be logged securely </li>\n</ul>\n<p>If a program directly writes to the standard outputs, there is absolutely no way to comply with those requirements. That's why defining and using a\ndedicated logger is highly recommended.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstd::cout &lt;&lt; \"My Message\";                // Noncompliant\nstd::cerr &lt;&lt; \"My Message\";                // Noncompliant\nprintf(\"My Message\");                     // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nLog().Get(logINFO) &lt;&lt; \"My Message\";\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/RoElAQ\">CERT, ERR02-J.</a> - Prevent exceptions while logging data </li>\n</ul>","debt":"10min"},{"summary":"Magic numbers should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>A magic number is a number that comes out of nowhere, and is directly used in a statement. Magic numbers are often used, for instance to limit the\nnumber of iterations of a loops, to test the value of a property, etc.</p>\n<p>Using magic numbers may seem obvious and straightforward when you're writing a piece of code, but they are much less obvious and straightforward at\ndebugging time.</p>\n<p>That is why magic numbers must be demystified by first being assigned to clearly named variables before being used.</p>\n<p>-1, 0 and 1 are not considered magic numbers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid doSomething() {\n  for(int i = 0; i &lt; 42; i++) {               // Noncompliant - 42 is a magic number\n    // ...\n  }\n\n  if (var == 42) {                            // Noncompliant - magic number\n    // ...\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#define STATUS_OK 42\n\nvoid doSomething() {\n  int maxIterations = 42;                     // Compliant - in a declaration\n  for(int i = 0; i &lt; maxIterations ; i++){    // Compliant\n    // ...\n  }\n\n  if (var == 0) {                             // Compliant - 0 is excluded\n    // ...\n  }\n\n  if (var == STATUS_OK) {                     // Compliant - number comes from a macro\n    // ...\n  }\n}\n</pre>","debt":"5min"},{"summary":"Values of different \"enum\" types should not be compared","type":"Bug","defaultSeverity":"Minor","description":"<p>Just as comparing apples and oranges is seen as a classic folly, comparing values from different enumerations against each other is nonsensical.\nTrue, at root <code>enum</code>s are simply named numbers, and it's certainly valid to compare numbers. But an added layer of meaning is created by an\n<code>enum</code>, one that goes beyond simple numerical values.</p>\n<p>Ignoring that extra layer of meaning is at best a trap for maintainers, who are likely to be hopelessly confused by the code. At worst, it is a\nbug, which will lead to unexpected results.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nenum apple {BRAEBURN, FUJI, GRANNY_SMITH, RED_DELICIOUS};\nenum orange {BLOOD, NAVEL, BITTER, BERGAMOT, MANDARIN};\n\nbool fun(apple v1, orange v2) {\n  return v1 != v2;  // Noncompliant\n}\n</pre>","debt":"15min"},{"summary":"Declarations should not be empty","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Empty declarations are cruft; they (may) compile, but they violate the language standards, don't contribute anything of value, and clutter up the\nprogram. Like cobwebs, they should be swept away.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint;  // Noncompliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> ISO/IEC 9899:2011, 6.7p2 </li>\n  <li> ISO/IEC 14882:2011, 7p3. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"2min"},{"summary":"\"switch\" statements should have at least 3 \"case\" clauses","type":"Code Smell","defaultSeverity":"Minor","description":"<p><code>switch</code> statements are useful when there are many different cases depending on the value of the same expression.</p>\n<p>For just one or two cases however, the code will be more readable with <code>if</code> statements.</p>\n<p>Moreover, <code>if</code> statements are obviously more suitable when the condition of the <code>switch</code> is boolean.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (variable == 0) {\n  doSomething();\n} else {\n  doSomethingElse();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.5 - Every switch statement shall have at least one case clause. </li>\n  <li> MISRA C++:2008, 6-4-8 - Every switch statement shall have at least one case-clause. </li>\n  <li> MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses </li>\n</ul>","debt":"5min"},{"summary":"The right-hand operands of && and || should not contain side effects","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>There are some situations in C++ where certain parts of expressions may not be evaluated. If these sub-expressions contain side effects then those\nside effects may or may not occur, depending on the values of other sub expressions. The operators which can lead to this problem are\n<code>&amp;&amp;</code> and <code>||</code>, where the evaluation of the right-hand operand is conditional on the value of the left-hand operand. The\nconditional evaluation of the right-hand operand of one of the logical operators can easily cause problems if the developer relies on a side effect\noccurring.</p>\n<p>Operations that cause side effects are: </p>\n<ul>\n  <li> accessing a volatile object </li>\n  <li> modifying an object </li>\n  <li> modifying a file </li>\n  <li> calling a function that performs any operations that cause changes in the state of the execution environment of the calling function. </li>\n</ul>\n<p>This rule raises an issue when there is assignment or the use of the increment/decrement operators in right-hand operands.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ( ishigh &amp;&amp; ( x == i++ ) ) // Noncompliant\n...\nif ( ishigh &amp;&amp; ( x ==  getX() ) ) // Only acceptable if getX() is known to have no side effects\n</pre>\n<p>The operations that cause side effects are accessing a volatile object, modifying an object, modifying a file, or calling a function</p>\n<p>that does any of those operations, which cause changes in the state of the execution environment of the calling function.</p>\n<p>For the time being, this rule only check that there is no assignment or no use of increment/decrement operators made in right hand operands.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.4 - The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>\n  <li> MISRA C++:2008, 5-14-1 - The right hand operand of a logical &amp;&amp; or || operator shall not contain side effects. </li>\n  <li> MISRA C:2012, 13.5 - The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/loAD\">CERT, EXP02-C.</a> - Be aware of the short-circuit behavior of the logical AND\n  and OR operators </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/XIAyAQ\">CERT, EXP02-CPP.</a> - Be aware of the short-circuit behavior of the logical\n  AND and OR operators </li>\n</ul>","debt":"15min"},{"summary":"Control structures should use curly braces","type":"Code Smell","defaultSeverity":"Critical","description":"<p>While not technically incorrect, the omission of curly braces can be misleading, and may lead to the introduction of errors during maintenance.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition)  // Noncompliant\n  executeSomething();\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition) {\n  executeSomething();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.8 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement </li>\n  <li> MISRA C:2004, 14.9 - An if (expression) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement </li>\n  <li> MISRA C++:2008, 6-3-1 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement </li>\n  <li> MISRA C++:2008, 6-4-1 - An if (condition) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement </li>\n  <li> MISRA C:2012, 15.6 - The body of an iteration-statement or a selection-statement shall be a compound-statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/1QGMAg\">CERT, EXP19-C.</a> - Use braces for the body of an if, for, or while statement\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/3wHEAw\">CERT, EXP52-J.</a> - Use braces for the body of an if, for, or while statement\n  </li>\n</ul>","debt":"2min"},{"summary":"Class names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate.</p>\n<p>This rule allows to check that all class names (along with Objective-C interface, protocol and implementation names) match a provided regular\nexpression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With default provided regular expression <code>[A-Z][a-zA-Z0-9]++</code>:</p>\n<pre>\n// C++\nclass foo // Noncompliant\n{\n};\n\n// Objective-C\n@interface nonCompliant : NSObject\n@end\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// C++\nclass Foo // Compliant\n{\n};\n\n// Objective-C\n@interface Compliant : NSObject\n@end\n</pre>","debt":"5min"},{"summary":"\"#undef\" should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p><code>#undef</code> should not normally be needed. Its use can lead to confusion with respect to the existence or meaning of a macro when it is\nused in the code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#ifndef MY_HDR\n#define MY_HDR\n#endif\n...\n#undef MY_HDR    /* Noncompliant */\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.6 - #undef shall not be used. </li>\n  <li> MISRA C++:2008, 16-0-3 - #undef shall not be used. </li>\n  <li> MISRA C:2012, 20.5 - #undef should not be used </li>\n</ul>","debt":"2h"},{"summary":"Default capture should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Lambdas can use variables from their enclosing scope (called \"capture\") either by reference or by value. Since lambdas may run asynchronously,\nreference capture should be used with caution because by the time the lambda runs, the referenced variable may be out of scope, resulting in an access\nviolation at run time.</p>\n<p>You can specify default capture by reference (<code>[&amp;]</code>), or by value (<code>[=]</code>). Clearly default reference capture can cause\nscope issues, but default value capture can also lead to problems. That's because both forms of default capture implicitly also capture\n<code>*this</code>, which would automatically be used if for example you referenced a method from the enclosing scope.</p>\n<p>This rule raises an issue when default capture is used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fun() {\n  Foo foo;\n  ...\n  executor-&gt;Schedule([&amp;] {  // Noncompliant\n    maybeMember(foo);  // implicit use of *this reference if maybeMember is a member function. foo and maybeMember may both be gone by the time this is invoked\n  });\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid fun() {\n  Foo foo;\n  ...\n  executor-&gt;Schedule([&amp;foo] { // it is clear that foo is captured by reference and compilation is going to fail if maybeMember is a member function\n    maybeMember(foo);\n  });\n}\n</pre>","debt":"5min"},{"summary":"Array indices should be placed between brackets","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>While C syntax considers array subscripts (<code>[]</code>) as symmetrical, meaning that <code>a[i]</code> and <code>i[a]</code> are equivalent,\nthe convention is to put the index in the brackets rather than the array name. Inverting the index and array name serves no purpose, and is very\nconfusing.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n10[P1] = 0; // Noncompliant\ndostuff(i[arr]); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nP1[10] = 0;\ndostuff(arr[i]);\n</pre>","debt":"5min"},{"summary":"\"static\" should not be used in unnamed namespaces","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Since C++11, declaring a variable, class, or function in an unnamed <code>namespace</code> gives it internal linkage. Similarly, marking a\ndeclaration <code>static</code> also gives it internal linkage. Because both mechanisms have the same effect (although <code>static</code> has a\nnarrower application) using them together is clearly redundant.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnamespace {\n  static int i = 3;  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nnamespace {\n  int i = 3;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> ISO/IEC 14882:2011 3.5 paragraph 4 </li>\n</ul>","debt":"2min"},{"summary":"String literals should not be concatenated implicitly","type":"Code Smell","defaultSeverity":"Minor","description":"<p>While in C, and derived languages, it is legal to concatenate two literals by putting them next to each other, this is only justified in a few\ncases. For instance if one is a macro or if the layout makes it clearer.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n  const char * v1 = \"a\"\"b\";      // Noncompliant; same as \"ab\"\n  const char * v2 = \"a\\n\" \"b\\n\"; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n  const char * v1 = \"ab\"\n  const char * v2 = \"a\\n\"\n                    \"b\\n\";\n</pre>\n<h2>Exceptions</h2>\n<pre>\n  const char * v3 = \"a\" /* comment */ \"b\";\n\n  #define _s \"b\"\n  const char * v4 = \"a\" _s; // concatenation with macro ignored\n</pre>","debt":"5min"},{"summary":"\"=+\" should not be used instead of \"+=\"","type":"Bug","defaultSeverity":"Major","description":"<p>The use of operators pairs (<code>=+</code>) where the reversed, single operator was meant (<code>+=</code>) will compile and run, but not produce\nthe expected results.</p>\n<p>This rule raises an issue when <code>=+</code>, <code>=-</code>, <code>=!</code>, <code>=&amp;</code>, <code>=*</code>, <code>+=+</code>, and\n<code>-=-</code> are used without any space between the two operators and when there is at least one whitespace after.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint target = -5;\nint num = 3;\n\ntarget =- num;  // Noncompliant; target = -3. Is that really what's meant?\ntarget =+ num; // Noncompliant; target = 3\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint target = -5;\nint num = 3;\n\ntarget = -num;  // Compliant; intent to assign inverse value of num is clear\ntarget += num;\n</pre>","debt":"2min"},{"summary":"\"nonnull\" pointers should not be set to null","type":"Bug","defaultSeverity":"Minor","description":"<p>Functions return values and parameters values marked <code>nonnull</code> are assumed to have non-null values and are not typically null-checked\nbefore use. Therefore setting one of these values to <code>null</code>, could cause null pointer dereferences at runtime.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n__attribute__((returns_nonnull))\nint* nonnull(__attribute__((nonnull)) int* parameter) {\n  parameter = 0; // Noncompliant - \"parameter\" is marked \"nonnull\" but is set to null.\n  nonnull(0); // Noncompliant - Parameter \"parameter\" to this call is marked \"nonnull\" but null is passed.\n  return 0; // Noncompliant - This function's return value is marked \"nonnull\" but null is returned.\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/476.html\">MITRE CWE-476</a> - NULL Pointer Dereference </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ZwDOAQ\">CERT, EXP01-J.</a> - Do not use a null in a case where an object is required\n  </li>\n</ul>","debt":"15min"},{"summary":"\"extern\" shouldn't be used on member definitions","type":"Bug","defaultSeverity":"Major","description":"<p>Data members and member functions cannot be defined as external, although entire objects can. When a member is declared as <code>extern</code>, the\ncompiler simply ignores the keyword, making it both extraneous and confusing.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass C {\n  void fun();\n};\n\nextern void C::fun() { // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass C {\n  void fun();\n};\n\nvoid C::fun() {\n}\n</pre>","debt":"1min"},{"summary":"Switch labels should not be nested inside non-switch blocks","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>A switch-label can be placed anywhere within the statements that form the body of a switch statement, potentially leading to unstructured code. To\nprevent this from happening, the scope of a case-label or default-label shall be the statement forming the body of a switch statement. All\ncase-clauses and the default-clause shall be at the same scope.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (x) {\n  case 1: // Compliant\n    if (foo) {\n      case 2: // Noncompliant\n        break;\n      default: // Noncompliant\n        break;\n    }\n    break;\n  default: // Compliant\n    break;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.1 - A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.\n  </li>\n  <li> MISRA C++:2008, 6-4-4 - A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.\n  </li>\n  <li> MISRA C:2012, 16.2 - A switch label shall only be used when the most closely-enclsoing compound statement is the body of a switch statement\n  </li>\n</ul>","debt":"20min"},{"summary":"Classes should not be too complex","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The cyclomatic complexity of a class should not exceed a defined threshold. Complex code can perform poorly and will in any case be difficult to\nunderstand and therefore to maintain.</p>\n<h2>Deprecated</h2>\n<p>This rule is deprecated, and will eventually be removed.</p>","debt":"10min"},{"summary":"Files should contain an empty newline at the end","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Some tools work better when files end with an empty line.</p>\n<p>This rule simply generates an issue if it is missing.</p>\n<p>For example, a Git diff looks like this if the empty line is missing at the end of the file:</p>\n<pre>\n+class Test {\n+}\n\\ No newline at end of file\n</pre>","debt":"1min"},{"summary":"\"enum\" members other than the first one should not be explicitly initialized unless all members are explicitly initialized","type":"Code Smell","defaultSeverity":"Major","description":"<p>If an enumerator list is given with no explicit initialization of members, then C/C++ allocates a sequence of integers starting at zero for the\nfirst element and increasing by one for each subsequent element.</p>\n<p>An explicit initialization of the first element, as permitted by this rule, forces the allocation of integers to start at the given value. When\nadopting this approach it is essential to ensure that the initialization value used is small enough that no subsequent value in the list will exceed\nthe <code>int</code> storage used by enumeration constants.</p>\n<p>Explicit initialization of all items in the list, which is also permissible, prevents the mixing of automatic and manual allocation, which is error\nprone.</p>\n<p>However, it is then the responsibility of the developer to ensure that all values are in the required range, and that values are not\nunintentionally duplicated.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nenum color { red = 3, blue, green, yellow = 5 }; // Noncompliant; both green and yellow = 5\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nenum color { red = 3, blue = 4, green = 5, yellow = 5 }; // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 9.3 - In an enumerator list, the \"=\" construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. </li>\n  <li> MISRA C++:2008, 8-5-3 - In an enumerator list, the = construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. </li>\n</ul>","debt":"20min"},{"summary":"\"for\" loop counters should not have essentially floating type","type":"Bug","defaultSeverity":"Minor","description":"<p>When using a floating-point <code>for</code> loop counter, an accumulation of rounding errors may result in a mismatch between the expected and\nactual number of iterations.</p>\n<p>Even if floating-point loop counters appears to behave correctly on one implementation, it may give a different number of iterations on another\nimplementation.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (float counter = 0.0f; counter &lt; 1.0f; counter += 0.001f) {\n  ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfor (int counter = 0; counter &lt; 1000; ++counter) {\n  ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.4 - The controlling expression of a for statement shall not contain any objects of floating type. </li>\n  <li> MISRA C++:2008, 6-5-1 - A <em>for</em> loop shall contain a single <em>loop-counter</em> which shall not have floating type. </li>\n  <li> MISRA C:2012, 14.1 - A <em>loop counter</em> shall not have essentially <em>floating type</em>. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/uYIyAQ\">CERT, NUM09-J.</a> - Do not use floating-point variables as loop counters </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/AoG_/\">CERT, FLP30-C.</a> - Do not use floating-point variables as loop counters </li>\n</ul>","debt":"5min"},{"summary":"Field names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that field\nnames match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>^[a-z][a-zA-Z0-9]*$</code>:</p>\n<pre>\nclass MyClass {\n  int my_field;\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass {\n  int myField;\n};\n</pre>","debt":"2min"},{"summary":"Local variable and function parameter names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared naming conventions allow teams to collaborate effectively. This rule raises an issue when a local variable or function parameter name does\nnot match the provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>^[a-z][a-zA-Z0-9]*$</code>:</p>\n<pre>\nvoid doSomething(int my_param) {\n  int LOCAL;\n  ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doSomething(int myParam) {\n  int local;\n  ...\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Loop counters and <code>const</code> variables are ignored by this rule.</p>","debt":"2min"},{"summary":"Code annotated as deprecated should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Code annotated as deprecated should not be used since it will be removed sooner or later.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// C++14 attribute\n[[deprecated]]\nvoid fun();\n\n// GNU attribute\n__attribute__((deprecated))\nvoid fun();\n\n// Microsoft attribute\n__declspec(deprecated)\nvoid fun();\n\nvoid example() {\n  fun(); // Noncompliant\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/477.html\">MITRE, CWE-477</a> - Use of Obsolete Functions </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KgAVAg\">CERT, MET02-J.</a> - Do not use deprecated or obsolete classes or methods </li>\n</ul>","debt":"15min"},{"summary":"Jump statements should not be used unconditionally","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having an unconditional <code>break</code>, <code>return</code>, <code>(@)throw</code> or <code>goto</code> in a loop renders it useless; the loop\nwill only execute once and the loop structure itself is simply wasted keystrokes.</p>\n<p>Having an unconditional <code>continue</code> in a loop can render the loop meaningless, or is itself wasted keystrokes, depending on where in the\nloop it occurs.</p>\n<p>Having an unconditional <code>return</code> anywhere other than at the end of a function or method simply renders all the rest of the code in the\nmethod useless.</p>\n<p>For these reasons, unconditional jump statements should never be used except for the final <code>return</code> in a function or method.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint i;\nfor (i = 0; i &lt; 10; ++i)\n{\n    printf(\"i is %d\", i);\n    break;  // loop only executes once\n}\n\nfor (i = 0; i &lt; 10; ++i)\n{\n    continue;\n    printf(\"i is %d\", i);  // this is never executed\n}\n\nfor (i = 0; i &lt; 10; ++i)\n{\n    printf(\"i is %d\", i);\n    continue;  // this is meaningless; the loop would continue anyway\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint i;\nfor (i = 0; i &lt; 10; ++i)\n{\n    printf(\"i is %d\", i);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.1 - There shall be no unreachable code. </li>\n  <li> MISRA C++:2008, 0-1-1 - A <em>project</em> shall not contain <em>unreachable code</em>. </li>\n  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code. </li>\n  <li> MISRA C:2012, 2.2 - There shall be no dead code </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"5min"},{"summary":"Lambdas should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Lambdas are a concise way of creating anonymous functions - when those functions are themselves concise. However, the use of lambdas for sizable\nfunctions can make the code difficult to read. More importantly, following variable capture in lambdas can be difficult, potentially leading to\ndangling pointers. Therefore lambdas should be avoided.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint main()\n{\n    auto func = [] () { cout &lt;&lt; \"Hello world\"; };\n    func();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint main()\n{\n    func();\n}\nvoid func ()\n{\n    cout &lt;&lt; \"Hello world\";\n}\n</pre>","debt":"15min"},{"summary":"Two branches in a conditional structure should not have exactly the same implementation","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having two <code>cases</code> in a <code>switch</code> statement or two branches in an <code>if</code> chain with the same implementation is at\nbest duplicate code, and at worst a coding error. If the same logic is truly needed for both instances, then in an <code>if</code> chain they should\nbe combined, or for a <code>switch</code>, one should fall through to the other. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (i) {\n  case 1:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  case 3:  // Noncompliant; duplicates case 1's implementation\n    doFirstThing();\n    doSomething();\n    break;\n  default:\n    doTheRest();\n}\n\nif (a &gt;= 0 &amp;&amp; a &lt; 10) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20) {\n  doTheOtherThing();\n}\nelse if (a &gt;= 20 &amp;&amp; a &lt; 50) {\n  doFirstThing();\n  doTheThing();  // Noncompliant; duplicates first condition\n}\nelse {\n  doTheRest();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch (i) {\n  case 1:\n  case 3:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  default:\n    doTheRest();\n}\n\nif ((a &gt;= 0 &amp;&amp; a &lt; 10) || (a &gt;= 20 &amp;&amp; a &lt; 50)) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20) {\n  doTheOtherThing();\n}\nelse {\n  doTheRest();\n}\n</pre>\n<p>or </p>\n<pre>\nswitch (i) {\n  case 1:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  case 3:\n    doFirstThing();\n    doThirdThing();\n    break;\n  default:\n    doTheRest();\n}\n\nif (a &gt;= 0 &amp;&amp; a &lt; 10) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20) {\n  doTheOtherThing();\n}\nelse if (a &gt;= 20 &amp;&amp; a &lt; 50) {\n  doFirstThing();\n  doTheThirdThing();\n}\nelse {\n  doTheRest();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Blocks in an <code>if</code> chain that contain a single line of code are ignored, as are blocks in a <code>switch</code> statement that contain a\nsingle line of code with or without a following <code>break</code>.</p>","debt":"10min"},{"summary":"\"scanf()\" and \"fscanf()\" format strings should specify a field width for the \"%s\" string placeholder","type":"Vulnerability","defaultSeverity":"Critical","description":"<p>The <code>%s</code> placeholder is used to read a word into a string.</p>\n<p>By default, there is no restriction on the length of that word, and the developer is required to pass a sufficiently large buffer for storing\nit.</p>\n<p>No matter how large the buffer is, there will always be a longer word.</p>\n<p>Therefore, programs relying on <code>%s</code> are vulnerable to buffer overflows.</p>\n<p>A field width specifier can be used together with the <code>%s</code> placeholder to limit the number of bytes which will by written to the\nbuffer.</p>\n<p>Note that an additional byte is required to store the null terminator.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nchar buffer[10];\nscanf(\"%s\", buffer);      // Noncompliant - will overflow when a word longer than 9 characters is entered\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nchar buffer[10];\nscanf(\"%9s\", buffer);     // Compliant - will not overflow\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/120\">MITRE, CWE-120</a> - Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n  </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/676\">MITRE, CWE-676</a> - Use of Potentially Dangerous Function </li>\n  <li> <a href=\"http://www.sans.org/top25-software-errors/\">SANS Top 25</a> - Risky Resource Management </li>\n</ul>","debt":"10min"},{"summary":"Nested code blocks should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Nested code blocks can be used to create a new scope and restrict the visibility of the variables defined inside it. Using this feature in a method\ntypically indicates that the method has too many responsibilities, and should be refactored into smaller methods.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void evaluate(int operator) {\n  switch (operator) {\n    /* ... */\n    case ADD: {                                // Noncompliant - nested code block '{' ... '}'\n        int a = stack.pop();\n        int b = stack.pop();\n        int result = a + b;\n        stack.push(result);\n        break;\n      }\n    /* ... */\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic void evaluate(int operator) {\n  switch (operator) {\n    /* ... */\n    case ADD:                                  // Compliant\n      evaluateAdd();\n      break;\n    /* ... */\n  }\n}\n\nprivate void evaluateAdd() {\n  int a = stack.pop();\n  int b = stack.pop();\n  int result = a + b;\n  stack.push(result);\n}\n</pre>","debt":"10min"},{"summary":"\"final\" should not be used redundantly","type":"Code Smell","defaultSeverity":"Minor","description":"<p>There is no need to use the <code>final</code> specifier inside a <code>final</code> class. Everything in it is <code>final</code> by default.</p>\n<p>Similarly, there is no need to use the <code>final</code> specifier for <code>union</code>, because <code>union</code>s can neither extend other\nclasses nor be extended.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Base {\n  virtual void fun();\n};\n\nclass Derived final : Base {\n  void fun() final;  // Noncompliant\n};\n\nunion MyUnion final { // Noncompliant\n  // ...\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Base {\n  virtual void fun();\n};\n\nclass Derived final : Base {\n  void fun() override;\n};\n\nunion MyUnion {\n  // ...\n};\n</pre>","debt":"2min"},{"summary":"\"case\" ranges should cover multiple values","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>The GNU compiler extension that allows <code>case</code>s to be specified with ranges should only be used when a range is actually needed. Use it\nwith the same number on both ends of the range, and you've either made a mistake because an actual range was intended, or you've used the syntax\ninappropriately in a way that is highly likely to confuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 3: // Noncompliant\n    //...\n    break;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3:\n    //...\n    break;\n}\n</pre>\n<p>or</p>\n<pre>\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 5:\n    //...\n    break;\n}\n</pre>","debt":"10min"},{"summary":"Destructors should not throw exceptions","type":"Bug","defaultSeverity":"Critical","description":"<p>When an exception is thrown, the call stack is unwound up to the point where the exception is to be handled. The destructors for all automatic\nobjects declared between the point where the exception is thrown and where it is to be handled will be invoked. If one of these destructors exits with\nan exception, then the program will terminate in an implementation-defined manner, potentially yielding unexpected results. </p>\n<p>Note that it is acceptable for a destructor to throw an exception that is handled within the destructor, for example within a try-catch block.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass C1 {\n  public: ~C1() {\n    throw(42);   // Noncompliant - destructor exits with an exception\n  }\n};\n\nvoid foo() {\n  C1 c; // program terminates when c is destroyed\n  throw(10);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass C1 {\n  public: ~C1() {\n    try {\n      throw(42);   // Compliant - exception will not leave destructor\n    } catch (int i) {  // int handler\n      // Handle int exception throw by destructor\n    }\n  }\n};\n\nvoid foo() {\n  C1 c;\n  throw(10);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 15-5-1 - A class destructor shall not exit with an exception. </li>\n</ul>","debt":"30min"},{"summary":"Init-declarator-lists and member-declarator-lists should consist of single init-declarators and member-declarators respectively","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Where multiple declarators appear in the same declaration the type of an identifier may not meet developer expectations.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint i1; int j1; // Compliant, but not preferred\nint i2, *j2; // Noncompliant\nint *i3,\n&amp;j3 = i2; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint i1;\nint j1;\nint i2;\nint *j2;\nint *i3;\nint &amp;j3 = i2;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator\n  respectively </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/7wHEAw\">CERT, DCL52-J.</a> - Do not declare more than one variable per declaration\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/VgU\">CERT, DCL04-C.</a> - Do not declare more than one variable per declaration </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/fAAhAQ\">CERT, DCL04-CPP.</a> - Do not declare more than one variable per declaration\n  </li>\n</ul>","debt":"5min"},{"summary":"\"union\" names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all <code>union</code> names match a provided\nregular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>Using the default regular expression <code>[A-Z][a-zA-Z0-9]*+</code>:</p>\n<pre>\nunion my_union {\n    int one;\n    int two;\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nunion MyUnion {\n    int one;\n    int two;\n};\n</pre>","debt":"10min"},{"summary":"\"case\" ranges should not be empty","type":"Bug","defaultSeverity":"Major","description":"<p>The GNU compiler extension that allows <code>case</code>s to be specified with ranges will only recognize ranges specified from a smaller value to\na larger value. Flip the order and the range will evaluate as empty.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 5 ... 3: // Noncompliant\n    //...\n    break;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 5\n    //...\n    break;\n</pre>","debt":"2min"},{"summary":"\"static\" base class members should not be accessed via derived types","type":"Code Smell","defaultSeverity":"Critical","description":"<p>In the interest of code clarity, <code>static</code> members of a <code>base</code> class should never be accessed using a derived type's name.\nDoing so is confusing and could create the illusion that two different static members exist.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Parent {\n  public:\n    static int count;\n};\n\nclass Child : public Parent {\n  public:\n    Child() {\n      Child::count++;  // Noncompliant\n    }\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Parent {\n  public:\n    static int count;\n};\n\nclass Child : public Parent {\n  public:\n    Child() {\n      Parent::count++;\n    }\n};\n</pre>","debt":"5min"},{"summary":"\"default\" should be used for special member functions","type":"Code Smell","defaultSeverity":"Critical","description":"<p>C++11 adds the ability to explicitly reinstate the default generation of special member functions that were suppressed by the definition of others.\nUsing <code>= default</code> instead of manually rewriting the default implementation has two advantages:</p>\n<ul>\n  <li> The new syntax is clearer to maintainers. </li>\n  <li> It's more efficient for POD (Plain Old Data) types. POD types can contain explicitly defaulted functions; they are still considered as trivial\n  by the compiler. But providing an implementation makes the types non-trivial, and prevents them from being true POD types. </li>\n</ul>\n<p>This rule raises an issue when any of the following provides the default implementation:</p>\n<ul>\n  <li> default constructor </li>\n  <li> destructor </li>\n  <li> move constructor </li>\n  <li> move-assignment operator </li>\n  <li> copy constructor </li>\n  <li> copy-assignment operator </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct Book {\n  string Name;\n  int    Reference;\n\n  Book() { } // Noncompliant\n  Book(const Book &amp;Other) : Name(Other.Name), Reference(Other.Reference) { } // Noncompliant\n  Book &amp;operator=(const Book &amp;);\n};\n\nBook &amp;Book::operator=(const Book &amp;Other) { // Noncompliant\n  Name      = Other.Name;\n  Reference = Other.Reference;\n  return *this;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct Book {\n  string Name;\n  int    Reference;\n\n  Book() = default; // restores generation of default\n  Book(const Book &amp;Other) = default;\n  Book &amp;operator=(const Book &amp;);\n};\n\nBook &amp;Book::operator=(const Book &amp;Other) = default;\n</pre>","debt":"2min"},{"summary":"Identical expressions should not be used on both sides of a binary operator","type":"Bug","defaultSeverity":"Major","description":"<p>Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste\nerror and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical\noperators, having the same value on both sides of an operator yields predictable results, and should be simplified.</p>\n<p>This rule ignores <code>*</code>, <code>+</code>, and <code>=</code>. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ( a == a ) { // always true\n  do_z();\n}\nif ( a != a ) { // always false\n  do_y();\n}\nif ( a == b &amp;&amp; a == b ) { // if the first one is true, the second one is too\n  do_x();\n}\nif (a == b || a == b ) { // if the first one is true, the second one is too\n  do_w();\n}\n\nif (5 / 5) { // always 1\n  do_v();\n}\nif (5 - 5) { // always 0\n  do_u();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>The following are ignored:</p>\n<ul>\n  <li> The expression <code>1 &lt;&lt; 1</code> </li>\n  <li> When an increment or decrement operator is used, ex: <code>*p++ == *p++</code> </li>\n  <li> Bitwise operators <code>|, &amp;, ^</code> </li>\n</ul>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n  <li> <a href='/coding_rules#rule_key=cpp%3AS1656'>S1656</a> - Implements a check on <code>=</code>. </li>\n</ul>","debt":"2min"},{"summary":"\"struct\" names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all <code>struct</code> names match a provided\nregular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>Using the default regular expression <code>[A-Z][a-zA-Z0-9]*+</code>:</p>\n<pre>\nstruct myStruct {\n  int one;\n  int two;\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct MyStruct {\n  int one;\n  int two;\n};\n</pre>","debt":"10min"},{"summary":"Methods should not contain unreachable code","type":"Bug","defaultSeverity":"Major","description":"<p>Jump statements (<code>return</code>, <code>break</code>, <code>continue</code>, and <code>goto</code>) and <code>throw</code> expressions move\ncontrol flow out of the current code block. Typically, any statements in a block that come after a jump or <code>throw</code> are simply wasted\nkeystrokes lying in wait to confuse the unwary. </p>\n<p>Rarely, as illustrated below, code after a jump or <code>throw</code> is reachable. However, such code is difficult to understand, and should be\nrefactored. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint fun(int a) {\n  int i = 10;\n  return i + a;       // Noncompliant\n  i++;             // this is never executed\n}\n\nvoid foo(int a) {\n  if (a == 5) {\n    goto error;\n  } else {\n    // do the job\n  }\n  return;\n\n  error:\n    printf(\"don't use 5\"); // this is reachable but unreadable\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint fun(int a) {\n  int i = 10;\n  return i + a;\n}\n\nvoid foo(int a) {\n  if (a == 5) {\n    handleError();\n  } else {\n    // do the job\n  }\n  return;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.1 - There shall be no unreachable code </li>\n  <li> MISRA C++:2008, 0-1-1 - A project shall not contain unreachable code </li>\n  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code </li>\n  <li> MISRA C:2012, 2.1 - A project shall not contain unreachable code </li>\n  <li> MISRA C:2012, 2.2 - There shall be no dead code </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/561.html\">MITRE, CWE-561</a> - Dead Code </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/uQCSBg\">CERT, MSC56-J.</a> - Detect and remove superfluous code and values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/OYIyAQ\">CERT, MSC07-CPP.</a> - Detect and remove dead code </li>\n</ul>","debt":"5min"},{"summary":"Preprocessor operators \"#\" and \"##\" should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>The evaluation order of both the <code>#</code> and <code>##</code> preprocessor operators is unspecified. Compilers have been known to implement\nthese operators inconsistently, therefore, to avoid these problems, do not use them.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#define A(Y)   #Y    /* Noncompliant */\n#define A(X,Y) X##Y  /* Noncompliant */\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.13 - The # and ## preprocessor operators should not be used. </li>\n  <li> MISRA C++:2008, 16-3-2 - The # and ## operators should not be used. </li>\n  <li> MISRA C:2012, 20.10 - The # and ## preprocessor operators should not be used </li>\n</ul>","debt":"30min"},{"summary":"\"#pragma warning (default: ...)\" should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Using \"#pragma warning (default: ...)\" resets the warning in question to its default settings, which may not be what the compiler was initially\ninvoked with. Typically, this usage is seen after a warning is turned off, in preparation for code that is known to cause warnings. Instead, the\nwarning's current state should be saved, and then restored after the code in question.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#pragma warning (disable: TheWarning)\n#include problem_code.h\n#pragma warning (default: TheWarning)\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#pragma warning (push)\n#include problem_code.h\n#pragma warning (pop)\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KwI\">CERT, MSC00-C.</a> - Compile cleanly at high warning levels </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/I4IyAQ\">CERT, MSC00-CPP.</a> - Compile cleanly at high warning levels </li>\n</ul>","debt":"5min"},{"summary":"Pre-defined macros should not be defined, redefined or undefined","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The standard, predefined macros, such as <code>__FILE__</code> and <code>__LINE__</code>, are primarily intended for use by the implementation, and\nchanging them could result in undefined behavior.</p>\n<p>This rule checks that the following predefined macros are not defined, undefined, or redefined: <code>assert</code>, <code>errno</code>,\n<code>__FILE__</code>, <code>__LINE__</code>, <code>__TIME__</code>, <code>__DATE__</code>, <code>__TIMESTAMP__</code>, <code>__COUNTER__</code>,\n<code>__INCLUDE_LEVEL__</code>, <code>__BASE_FILE__</code>, and <code>_Pragma</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#undef __LINE__\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined </li>\n  <li> MISRA C++:2008, 17-0-1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined </li>\n  <li> MISRA C:2012, 21.1 - #define and #undef shall not be used on a reserved identifier or reserved macro name </li>\n</ul>","debt":"10min"},{"summary":"Keywords introduced in later specifications should not be used as identifiers","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>While keywords introduced in later standards can legally be used as identifiers in code compiled to earlier standards, doing so will eventually\ncause problems. Such code will cause compile errors if (when) the compiler is upgraded, and fixing those errors could be difficult and painful. </p>\n<p>Additionally, such misuse of keywords has the potential to thoroughly confuse people who are unfamiliar with the code base, possibly leading them\nto introduce additional errors. </p>\n<p>For these reasons, the earlier this practice is stopped, the better.</p>\n<p>This rule flags instances of the following keywords used as identifiers:</p>\n<p><strong>C99</strong></p>\n<p><code>inline</code>, <code>restrict</code>, <code>_Bool</code>, <code>_Complex</code>, <code>_Noreturn</code>, <code>_Static_assert</code>,\n<code>_Thread_local</code></p>\n<p><strong>C11</strong></p>\n<p><code>_Alignas</code>, <code>_Alignof</code>, <code>_Atomic</code>, <code>_Generic</code>, <code>_Imaginary</code></p>\n<p><strong>C++11</strong></p>\n<p><code>alignas</code>, <code>alignof</code>, <code>char16_t</code>, <code>char32_t</code>, <code>constexpr</code>, <code>decltype</code>,\n<code>noexcept</code>, <code>nullptr</code>, <code>static_assert</code>, <code>thread_local</code></p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint inline = 0;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint inline_count = 0;\n</pre>","debt":"5min"},{"summary":"Files should not be too complex","type":"Code Smell","defaultSeverity":"Major","description":"<p>Most of the time, a very complex file breaks the Single Responsibility Principle and should be re-factored into several different files.</p>\n<h2>Deprecated</h2>\n<p>This rule is deprecated, and will eventually be removed.</p>","debt":"30min"},{"summary":"Function names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared naming conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With default provided regular expression: <code>[a-z][a-zA-Z0-9]*</code>:</p>\n<pre>\nvoid DoSomething (void);\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doSomething (void);\n</pre>","debt":"5min"},{"summary":"Reference types should not be qualified with \"const\" or \"volatile\"","type":"Code Smell","defaultSeverity":"Minor","description":"<p>The C++ specification forbids the qualification of reference types with <code>const</code> or <code>volatile</code> unless it happens via a\n<code>typedef</code>, in which case it's ignored. Most compilers treat such direct qualifications as errors, but the Microsoft compiler allows them.\n</p>\n<p>This rule raises an issue on both types of <code>const</code> qualification.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid example(char c) {\n  char &amp; const direct = c; // Noncompliant\n\n  typedef char &amp; T;\n  const T indirect = c; // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid example(char c) {\n  char &amp; direct = c; // or: const char &amp; direct = c;\n\n  typedef char &amp; T;\n  T indirect = c;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/display/cplusplus/DCL52-CPP.+Never+qualify+a+reference+type+with+const+or+volatile\">CERT,\n  DCL52-CPP.</a> - Never qualify a reference type with const or volatile </li>\n</ul>","debt":"2min"},{"summary":"\"catch\" clauses should do more than rethrow","type":"Code Smell","defaultSeverity":"Minor","description":"<p>A <code>catch</code> clause that only rethrows the caught exception has the same effect as omitting the <code>catch</code> altogether and letting\nit bubble up automatically, but with more code and the additional detrement of leaving maintainers scratching their heads. </p>\n<p>Such clauses should either be eliminated or populated with the appropriate logic.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntry {\n  saveDocument();\n} catch (const std::exception&amp; e) { // Noncompliant\n  throw;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntry {\n  saveDocument();\n} catch (const std::exception&amp; e) { // Compliant\n  log &lt;&lt; e.what();\n  throw;\n}\n</pre>\n<p>or</p>\n<pre>\nsaveDocument();\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"5min"},{"summary":"General \"catch\" clauses should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>A general <code>catch</code> block seems like an efficient way to handle multiple possible exceptions. Unfortunately, it traps all exception types,\ncasting too broad a net, and perhaps mishandling extraordinary cases. Instead, specific exception sub-types should be caught.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntry {\n  file.open(\"test.txt\");\n} catch (...) {  // Noncompliant\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntry {\n  file.open(\"test.txt\");\n} catch (std::ifstream::failure e) {\n  // ...\n}\n</pre>","debt":"20min"},{"summary":"The sign of an unsigned variable should not be tested","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Because the value in a variable of an unsigned type can never be less than zero, testing to see if it is negative is a useless operation which can\nonly confuse future readers of the code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nunsigned int i = 0; // the lowest value this var can have\n...\nif (i &gt;= 0) { // Noncompliant\n  do_x(i);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nunsigned int i = 0;\n...\ndo_x(i);\n</pre>","debt":"5min"},{"summary":"Pointers should not be cast to integral types","type":"Bug","defaultSeverity":"Critical","description":"<p>The size of integer required to hold a memory address is implementation-dependent. Therefore, casting a pointer (i.e. a memory address) to any\nintegral data type may result in data loss because the integral type is too small to hold the full address value.</p>\n<p>When treating a memory address as integer type is absolutely required, you should be sure to use a large enough type to hold all the data.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint *p;\nint addr = ( int ) &amp;p;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 11.3 - A cast should not be performed between a pointer type and an integral type. </li>\n  <li> MISRA C++:2008, 5-2-9 - A cast should not convert a pointer type to an integral type. </li>\n  <li> MISRA C:2012, 11.4 - A conversion should not be performed between a pointer to object and an integer type </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/XAAV\">CERT, INT36-C.</a> - Converting a pointer to integer or integer to pointer </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/toAyAQ\">CERT, INT11-CPP.</a> - Take care when converting from pointer to integer or\n  integer to pointer </li>\n</ul>","debt":"5min"},{"summary":"\"<stdio.h>\" should not be used in production code","type":"Bug","defaultSeverity":"Critical","description":"<p>This includes file and I/O functions <code>fgetpos</code>, <code>fopen</code>, <code>ftell</code>, <code>gets</code>, <code>perror</code>,\n<code>remove</code>, <code>rename</code> and <code>ungetc</code>.</p>\n<p>Streams and file I/O have a large number of unspecified, undefined and implementation-defined behaviors associated with them. It is assumed within\nMISRA C that they will not normally be needed in production code in embedded systems.</p>\n<p>If any of the features of <code>stdio.h</code> need to be used in production code, then the issues associated with the features need to be\nunderstood.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;stdio.h&gt; /* Noncompliant */\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 20.9 - The input/output library &lt;stdio.h&gt; shall not be used in production code. </li>\n  <li> MISRA C++:2008, 27-0-1 - The stream input/output library &lt;cstdio&gt; shall not be used. </li>\n  <li> MISRA C:2012, 21.6 - The Standard Library input/output functions shall not be used </li>\n</ul>","debt":"4h"},{"summary":"Tabulation characters should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Developers should not need to configure the tab width of their text editors in order to be able to read source code.</p>\n<p>So the use of the tabulation character must be banned.</p>","debt":"2min"},{"summary":"Namespaces should not be empty","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Namespaces with no lines of code clutter a project and should be removed. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnamespace MyEmptyNamespace // Noncompliant\n{\n\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/OYIyAQ\">CERT, MSC07-CPP.</a> - Detect and remove dead code </li>\n</ul>","debt":"2min"},{"summary":"Insecure functions \"strcpy\", \"strcat\" and \"sprintf\" should not be used","type":"Vulnerability","defaultSeverity":"Critical","description":"<p>When using legacy C functions such as <code>strcpy</code>, it's up to the developer to make sure the size of the buffer to be written to is large\nenough to avoid buffer overruns. If this is not done properly, it can result in a buffer overflow, causing the program to crash at a minimum. At\nworst, a carefully crafted overflow can cause malicious code to be executed.</p>\n<p>In such cases, it's better to use an alternate, secure, function, such as <code>strlcpy()</code>, <code>strlcat()</code> and\n<code>snprintf()</code>, which allows you to define the maximum number of characters to be written to the buffer. However, since\n<code>strlcpy()</code> and <code>strlcat()</code> are part of the BSD library, they might not be available, in which case <code>strncpy()</code> and\n<code>strncat()</code> should be used instead, but be aware that they don't guarantee the string will be null-terminated.</p>\n<p>This rule logs an issue when encountering the following insecure functions: <code>strcpy()</code>, <code>strcat()</code> and\n<code>sprintf()</code></p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nsprintf(str, \"%s\", message);   // Noncompliant\nstrcpy(str, message); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nsnprintf(str, sizeof(str), \"%s\", message);\nstrlcpy(str, message, sizeof(str));\n\nstrncpy(str, message, sizeof(str) -1); // Leave room for null\nstr[sizeof(str) - 1] = '\\0'; // Make sure the string is null-terminated\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/120\">MITRE, CWE-120</a> - Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')\n  </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/676\">MITRE, CWE-676</a> - Use of Potentially Dangerous Function </li>\n  <li> <a href=\"http://www.sans.org/top25-software-errors/\">SANS Top 25</a> - Risky Resource Management </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/QwY\">CERT, STR07-C.</a> - Use the bounds-checking interfaces for string manipulation\n  </li>\n</ul>","debt":"20min"},{"summary":"The 'sizeof' and 'alignof' operators should not be used with operands of a 'void' type","type":"Bug","defaultSeverity":"Minor","description":"<p>Although some compilers will allow it, the use of <code>sizeof</code> and <code>alignof</code> with arguments that have a <code>void</code>\ntype is forbidden by both the C and C++ standards.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fun() {\n  void* p;\n  sizeof(*p);  // Noncompliant\n  sizeof(void);  // Noncompliant\n}\n</pre>","debt":"5min"},{"summary":"\"reinterpret_cast\" should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>Because <code>reinterpret_cast</code> does not perform any type safety validations, it is capable of performing dangerous conversions between\nunrelated types.</p>\n<p>This rule raises an issue when <code>reinterpret_cast</code> is used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n  class A { public: virtual ~A(){} };\n  class B : public A { public: void doSomething(){} };\n\n  void func(A *a) {\n    if (B* b = reinterpret_cast&lt;B*&gt;(a)) { // Noncompliant\n      b-&gt;doSomething();\n    }\n  }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n  class A { public: virtual ~A(){} };\n  class B : public A { public: void doSomething(){} };\n\n  void func(A *a) {\n    if (B* b = dynamic_cast&lt;B*&gt;(a)) {\n      b-&gt;doSomething();\n    }\n  }\n</pre>\n<h2>See</h2>\n<ul>\n  <li> CppCoreGuidelines, Type safety profile - Type.1: Don't use reinterpret_cast. </li>\n</ul>","debt":"20min"},{"summary":"Track lack of copyright and license headers","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Each source file should start with a header stating file ownership and the license which must be used to distribute the application. </p>\n<p>This rule must be fed with the header text that is expected at the beginning of every file.</p>\n<h2>Compliant Solution</h2>\n<pre>\n/*\n * SonarQube, open source software quality management tool.\n * Copyright (C) 2008-2013 SonarSource\n * mailto:contact AT sonarsource DOT com\n *\n * SonarQube is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * SonarQube is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n</pre>","debt":"5min"},{"summary":"All uses of the #pragma directive should be documented","type":"Code Smell","defaultSeverity":"Major","description":"<p>The <code>#pragma</code> directive is implementation-defined, hence it is important both to demonstrate that all uses are correct, and to minimize,\nlocalize and encapsulate any use of pragmas within dedicated functions whenever possible.</p>\n<p>The meaning of each pragma shall be documented.</p>\n<p>There shall be sufficient supporting description to demonstrate that the behavior of the pragma and its implications for the application, have been\nfully understood.</p>\n<p>This rule flags all instances of <code>#pragma</code> directives, and leaves it to the user to determine whether they have been properly\ndocumented.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 3.4 - All uses of the #pragma directive shall be documented and explained </li>\n  <li> MISRA C++:2008, 16-6-1 - All uses of the #pragma directive shall be documented </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KwI\">CERT, MSC00-C</a> - Compile cleanly at high warning levels </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/I4IyAQ\">CERT, MSC00-CPP</a> - Compile cleanly at high warning levels </li>\n</ul>","debt":"10min"},{"summary":"Zero should not be a possible denominator","type":"Bug","defaultSeverity":"Critical","description":"<p>If the denominator to a division or modulo operation is zero it would result in a fatal error.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid test_divide() {\n  int z = 0;\n  if (unknown()) {\n    // ..\n    z = 3;\n  } else {\n    // ..\n  }\n  z = 1 / z; // Noncompliant, possible division by zero\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid test_divide() {\n  int z = 0;\n  if (unknown()) {\n    // ..\n    z = 3;\n  } else {\n    // ..\n    z = 1;\n  }\n  z = 1 / z;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://cwe.mitre.org/data/definitions/369.html\">MITRE, CWE-369</a> - Divide by zero </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KAGyAw\">CERT, NUM02-J.</a> - Ensure that division and remainder operations do not\n  result in divide-by-zero errors </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/cAI\">CERT, INT33-C.</a> - Ensure that division and remainder operations do not result\n  in divide-by-zero errors </li>\n</ul>","debt":"5min"},{"summary":"Memory access should be explicitly bounded to prevent buffer overflows","type":"Bug","defaultSeverity":"Blocker","description":"<p>Array overruns and buffer overflows happen when memory access accidentally goes beyond the boundary of the allocated array or buffer. These\noverreaching accesses cause some of the most damaging, and hard to track defects.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint array[10];\narray[10] = 0; // Noncompliant: index should be between 0 &amp; 9\n\nchar *buffer1 = (char *) malloc(100);\nchar *buffer2 = (char *) malloc(50);\nmemcpy(buffer2, buffer1, 100); // Noncompliant: buffer2 will overflow.\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint array[10];\narray[9] = 0;\n\nchar *buffer1 = (char *) malloc(100);\nchar *buffer2 = (char *) malloc(50);\nmemcpy(buffer2, buffer1, 50);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://cwe.mitre.org/data/definitions/119.html\">MITRE, CWE-119</a> - Improper Restriction of Operations within the Bounds of a Memory\n  Buffer </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/P4EyAQ\">CERT, STR50-CPP.</a> - Guarantee that storage for strings has sufficient space\n  for character data and the null terminator </li>\n</ul>","debt":"5min"},{"summary":"\"switch\" statements should not contain non-case labels","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Even if it is legal, mixing case and non-case labels in the body of a switch statement is very confusing and can even be the result of a typing\nerror.</p>\n<h2>Noncompliant Code Example</h2>\n<p>Case 1, the code is syntactically correct but the behavior is not the expected one</p>\n<pre>\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  WEDNESDAY:   // instead of \"case WEDNESDAY\"\n    doSomething();\n    break;\n  ...\n}\n</pre>\n<p>Case 2, the code is correct and behaves as expected but is hardly readable </p>\n<pre>\nswitch (day) {\n  case MONDAY:\n    break;\n  case TUESDAY:\n    foo:for(int i = 0 ; i &lt; X ; i++) {\n         /* ... */\n        break foo;  // this break statement doesn't relate to the nesting case TUESDAY\n         /* ... */\n    }\n    break;\n    /* ... */\n}\n</pre>\n<h2>Compliant Solution</h2>\n<p>Case 1</p>\n<pre>\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  case WEDNESDAY:\n    doSomething();\n    break;\n  ...\n}\n</pre>\n<p>Case 2</p>\n<pre>\nswitch (day) {\n  case MONDAY:\n    break;\n  case TUESDAY:\n    compute(args); // put the content of the labelled \"for\" statement in a dedicated method\n    break;\n\n    /* ... */\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.0 - The MISRA C <em>switch</em> syntax shall be used. </li>\n  <li> MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. </li>\n  <li> MISRA C:2012, 16.1 - All switch statements shall be well-formed </li>\n</ul>","debt":"10min"},{"summary":"Methods returns should not be invariant","type":"Code Smell","defaultSeverity":"Major","description":"<p>When a method is designed to return an invariant value, it may be poor design, but it shouldn't adversely affect the outcome of your program.\nHowever, when it happens on all paths through the logic, it is surely a bug.</p>\n<p>This rule raises an issue when a method contains several <code>return</code> statements that all return the same value.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint foo(int a) {\n  int b = 12;\n  if (a == 1) {\n    return b;\n  }\n  return b;  // Noncompliant\n}\n</pre>"},{"summary":"Increment should not be used to set boolean variables to 'true'","type":"Code Smell","defaultSeverity":"Major","description":"<p>It is possible to use the increment operator <code>++</code>, to set the value of a <code>bool</code>(C++) or <code>_Bool</code>(C) variable to\n<code>true</code>. But this feature has been deprecated in C++ since the 1998 version of the standard, and even where allowed, is simply confusing.\n</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nbool alive;\n...\nalive++;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nbool alive;\n...\nalive = true;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> ISO/IEC 14882:1998, 5.3.2 </li>\n</ul>","debt":"1min"},{"summary":"Constructors and destructors should only call non-overridable methods","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Calling an overridable member function from a constructor or destructor could result in unexpected behavior when instantiating a subclass which\noverrides the member function.</p>\n<p>For example:</p>\n<ul>\n  <li> By contract, the subclass class constructor starts by calling the parent class constructor. </li>\n  <li> The parent class constructor calls the parent member function and not the one overridden in the child class, which is confusing for child\n  class' developer. </li>\n  <li> It can produce an undefined behavior if the member function is pure <code>virtual</code> in the parent class. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Parent {\n  public:\n    Parent() {\n      method1();\n      method2(); // Noncompliant; confusing because Parent::method2() will always been called even if the method is overridden\n    }\n    virtual ~Parent() {\n      method3(); // Noncompliant; undefined behavior (ex: throws a \"pure virtual method called\" exception)\n    }\n  protected:\n    void         method1() { /*...*/ }\n    virtual void method2() { /*...*/ }\n    virtual void method3() = 0; // pure virtual\n};\n\nclass Child : public Parent {\n  public:\n    Child() { // leads to a call to Parent::method2(), not Child::method2()\n    }\n    virtual ~Child() {\n      method3(); // Noncompliant; Child::method3() will always be called even if a child class overrides method3\n    }\n  protected:\n    void method2() override { /*...*/ }\n    void method3() override { /*...*/ }\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Parent {\n  public:\n    Parent() {\n      method1();\n      Parent::method2(); // acceptable but poor design\n    }\n    virtual ~Parent() {\n      // call to pure virtual function removed\n    }\n  protected:\n    void         method1() { /*...*/ }\n    virtual void method2() { /*...*/ }\n    virtual void method3() = 0;\n};\n\nclass Child : public Parent {\n  public:\n    Child() {\n    }\n    virtual ~Child() {\n      method3(); // method3() is now final so this is okay\n    }\n  protected:\n    void method2() override { /*...*/ }\n    void method3() final    { /*...*/ } // this virtual function is \"final\"\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/MYYbAQ\">CERT, MET05-J.</a> - Ensure that constructors do not call overridable methods\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/TQBi\">CERT, OOP50-CPP.</a> - Do not invoke virtual functions from constructors or\n  destructors </li>\n</ul>","debt":"10min"},{"summary":"File names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate effectively. For that reason, file names should conform to a defined standard. This rule\nraises an issue when the names of analyzed files don't match the provided regular expression.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/P4IyAQ\">CERT, MSC09-CPP.</a> - Character encoding: Use subset of ASCII for safety </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/lQAl\">CERT, MSC09-C.</a> - Character encoding: Use subset of ASCII for safety </li>\n</ul>","debt":"10min"},{"summary":"\"const\" and \"volatile\" should not be used in \"enum\" declarations","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Since C++11, it's possible to declare the underlying type of an <code>enum</code>, and like any type declration, <code>enum</code> declarations can\ncontain the <code>const</code> or <code>volatile</code> specifier. But because <code>enum</code> values are named constants and cannot be re-assigned,\nthose specifiers are ignored by the compiler, and are therefore useless.</p>\n<p>This rule raises an issue if <code>const</code> or <code>volatile</code> is present in the declaration of the underlying type of an\n<code>enum</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nenum class Color : const long int {  // Noncompliant; Remove this \"const\" specifier.\n  Red   = 0xff0000,\n  Green = 0x00ff00,\n  Blue  = 0x0000ff\n};\n\nenum class Size : volatile char {  // Noncompliant; Remove this \"volatile\" specifier.\n  Small   = 's',\n  Big     = 'b'\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nenum class Color : long int {\n  Red   = 0xff0000,\n  Green = 0x00ff00,\n  Blue  = 0x0000ff\n};\n\nenum class Size : char {\n  Small   = 's',\n  Big     = 'b'\n};\n</pre>","debt":"2min"},{"summary":"Exception specifications should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Specifying which exceptions can be thrown by a function seems like a good idea. It can enable the compiler to verify that no other exception is\nbeing thrown, and generate more optimal code based on this knowledge.</p>\n<p>However, C++ defers those verifications to runtime instead of doing them at compile time. When the verification fails,\n<code>std::unexpected()</code> is called and the program is likely to be terminated. Furthermore, since C++11, dynamic exception specifications\n<code>throw(typeid, typeid, ...)</code> are deprecated.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;iostream&gt;\n\nvoid f() throw();  // Noncompliant. Promises that nothing will be thrown. Implementation breaks promise.\nvoid f() noexcept; // Compliant\n\nvoid g() throw(char *); // Noncompliant. Promises that only char * will be thrown, but implementation breaks promise.\n\nvoid f() throw()  // Noncompliant\n{\n  throw 0;  // Implementation actually does throw something, yet the code compiles\n}\n\nvoid g() throw(char *); // Noncompliant\n{\n  throw 0; // Implementation actually does throw an int, yet the code compiles\n}\n\nvoid h(); // Compliant, can implicitly throw anything\nvoid i() noexcept(false); // Compliant, can explicitly throw anything\n\nint main()\n{\n  try {\n    f();  // At runtime, the throw is detected, and the program is terminated, even though a handler was defined\n  } catch(...) {\n    // Unreachable code\n    // ...\n  }\n\n  // Unreachable code\n  std::cout &lt;&lt; \"Hello, world!\" &lt;&lt; std::endl;\n\n  return 0;\n}\n</pre>\n<h2>Exceptions</h2>\n<p>If a derived class overrides a function with a dynamic exception specification, then the derived function is forced to add a compatible exception\nspecification. Such exception specifications are ignored.</p>\n<pre>\nclass A {\n  virtual void func() throw(X, Y); // Noncompliant\n};\nclass B : public A {\n  void func() throw(X, Y) override; // Compliant, without \"throw(X, Y)\" it does not compile\n};\n</pre>","debt":"20min"},{"summary":"Assembly language should be encapsulated and isolated","type":"Code Smell","defaultSeverity":"Major","description":"<p>Ensuring that assembly language code is encapsulated and isolated aids portability. Where assembly language instructions are needed, they shall be\nencapsulated and isolated in either assembler functions or C++ functions.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid fn ( void )\n{\n  DoSomething ( );\n  asm ( \"NOP\" ); // Noncompliant, asm mixed with C/C++ statements\n  DoSomething ( );\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid Delay ( void )\n{\n  asm ( \"NOP\" ); // Compliant, asm not mixed with C/C++ statements\n}\n\nvoid fn ( void )\n{\n  DoSomething ( );\n  Delay ( ); // Compliant, Assembler is encapsulated\n  DoSomething ( );\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 2.1 - Assembly language shall be encapsulated and isolated. </li>\n  <li> MISRA C++:2008, 7-4-3 - Assembly language shall be encapsulated and isolated. </li>\n</ul>","debt":"20min"},{"summary":"Obsolete POSIX functions should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>To ensure future code portability, obsolete POSIX functions should be removed. Those functions, with their replacements are listed below:</p>\n<table>\n  <tbody>\n    <tr>\n      <th>Obsolete</th>\n      <th>Use Instead</th>\n    </tr>\n    <tr>\n      <td>asctime</td>\n      <td>strftime</td>\n    </tr>\n    <tr>\n      <td>asctime_r</td>\n      <td>strftime</td>\n    </tr>\n    <tr>\n      <td>bcmp</td>\n      <td>memcmp</td>\n    </tr>\n    <tr>\n      <td>bcopy</td>\n      <td>memmove memcpy</td>\n    </tr>\n    <tr>\n      <td>bsd_signal</td>\n      <td>sigaction</td>\n    </tr>\n    <tr>\n      <td>bzero</td>\n      <td>memset</td>\n    </tr>\n    <tr>\n      <td>ctime</td>\n      <td>strftime</td>\n    </tr>\n    <tr>\n      <td>ecvt</td>\n      <td>sprintf</td>\n    </tr>\n    <tr>\n      <td>fcvt</td>\n      <td>sprintf</td>\n    </tr>\n    <tr>\n      <td>ftime</td>\n      <td>no replacement function</td>\n    </tr>\n    <tr>\n      <td>gcvt</td>\n      <td>sprintf</td>\n    </tr>\n    <tr>\n      <td>getcontext</td>\n      <td>Rewrite to use POSIX threads.</td>\n    </tr>\n    <tr>\n      <td>gethostbyaddr</td>\n      <td>getnameinfo</td>\n    </tr>\n    <tr>\n      <td>gethostbyname</td>\n      <td>getaddrinfo</td>\n    </tr>\n    <tr>\n      <td>getwd</td>\n      <td>getcwd</td>\n    </tr>\n    <tr>\n      <td>index</td>\n      <td>strchr</td>\n    </tr>\n    <tr>\n      <td>makecontext</td>\n      <td>Rewrite to use POSIX threads.</td>\n    </tr>\n    <tr>\n      <td>pthread_attr_getstackaddr</td>\n      <td>pthread_attr_getstack</td>\n    </tr>\n    <tr>\n      <td>pthread_attr_setstackaddr</td>\n      <td>pthread_attr_setstack</td>\n    </tr>\n    <tr>\n      <td>rand_r</td>\n      <td>rand</td>\n    </tr>\n    <tr>\n      <td>rindex</td>\n      <td>strrchr</td>\n    </tr>\n    <tr>\n      <td>scalb</td>\n      <td>scalbln', 'scalblnf' or 'scalblnl' instead of this function</td>\n    </tr>\n    <tr>\n      <td>swapcontext</td>\n      <td>Rewrite to use POSIX threads.</td>\n    </tr>\n    <tr>\n      <td>tmpnam</td>\n      <td>'tmpfile', 'mkstemp', or 'mkdtemp' instead for this function</td>\n    </tr>\n    <tr>\n      <td>tmpnam_r</td>\n      <td>tmpfile', 'mkstemp', or 'mkdtemp' instead for this function</td>\n    </tr>\n    <tr>\n      <td>ualarm</td>\n      <td>'timer_create', 'timer_delete', 'timer_getoverrun', 'timer_gettime', or 'timer_settime' instead of this function</td>\n    </tr>\n    <tr>\n      <td>usleep</td>\n      <td>'nanosleep' or 'setitimer' function</td>\n    </tr>\n    <tr>\n      <td>utime</td>\n      <td>utimensat</td>\n    </tr>\n    <tr>\n      <td>vfork</td>\n      <td>fork</td>\n    </tr>\n    <tr>\n      <td>wcswcs</td>\n      <td>wcsstr</td>\n    </tr>\n  </tbody>\n</table>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/EgAa\">CERT, POS33-C.</a> - Do not use vfork() </li>\n</ul>","debt":"30min"},{"summary":"Source code should only use /* ... */ style comments","type":"Code Smell","defaultSeverity":"Minor","description":"<p>This excludes the use of <code>//</code> C99 style comments and C++ style comments, since these are not permitted in C90. Many compilers support\nthe <code>//</code> style of comments as an extension to C90. The use of <code>//</code> in preprocessor directives (e.g. <code>#define</code>) can\nvary. Also the mixing of <code>/* ... */</code> and <code>//</code> is not consistent. This is more than a style issue, since different (pre C99)\ncompilers may behave differently.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint main(int argc, char* argv[])\n{\n  // Do nothing - Noncompliant\n  return 0;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint main(int argc, char* argv[])\n{\n  /* Do nothing - Compliant */\n  return 0;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 2.2 - Source code shall only use /* ... */ style comments. </li>\n</ul>","debt":"5min"},{"summary":"\"/*\" and \"//\" should not be used within comments","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Defining a nested single-line comment within a multi-line comment invites errors. It may lead a developer to wrongly think that the lines located\nafter the single-line comment are not part of the comment.</p>\n<p>If a comment starting sequence, <code>/*</code> or <code>//</code>, occurs within a <code>/*</code> comment, is it quite likely to be caused by a\nmissing <code>*/</code> comment ending sequence.</p>\n<p>If a comment starting sequence occurs within a <code>//</code> comment, it is probably because a region of code has been commented-out using\n<code>//</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n/* some comment, end comment marker accidentally omitted\n// Make sure this function is called in a thread safe context\nPerform_Critical_Safety_Function(X);\n...\n/* this comment is non-compliant */\n</pre>\n<h2>Exceptions</h2>\n<p>The sequence // is permitted within a // comment.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 2.3 - The character sequence /* shall not be used within a comment. </li>\n  <li> MISRA C++:2008, 2-7-1 - The character sequence /* shall not be used within a C-style comment. </li>\n  <li> MISRA C:2012, 3.1 - The character sequences /* and // shall not be used within a comment </li>\n</ul>","debt":"2min"},{"summary":"Scoped enumerations should be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>There are two kinds of enumeration:</p>\n<ul>\n  <li> The unscoped <code>enum</code> inherited from C </li>\n  <li> The scoped enumeration <code>enum class</code> or <code>enum struct</code> added in C++ 11 </li>\n</ul>\n<p>Unscoped enumerations have two major drawbacks that are fixed by scoped enumerations:</p>\n<ul>\n  <li> <code>enum</code> elements are visible from their enclosing scope, instead of requiring the scope resolution operator (ex: <code>Red</code>\n  instead of <code>Color::Red</code>) </li>\n  <li> <code>enum</code> elements convert implicitly to <code>int</code>, so that heterogeneous comparisons such as <code>Red == Big</code> don't\n  result in compile errors. </li>\n</ul>\n<p>This rule raises an issue when an unscoped enumeration is used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nenum Color { // Noncompliant; replace this \"enum\" with \"enum class\".\n  Red   = 0xff0000,\n  Green = 0x00ff00,\n  Blue  = 0x0000ff\n};\n\nenum ProductType { // Noncompliant; replace this \"enum\" with \"enum class\".\n  Small   = 1,\n  Big     = 2\n};\n\nvoid printColor(int color);\nvoid printInt(int value);\n\nvoid report() {\n  printColor(Red); // correct\n  printColor(Big); // clearly buggy\n  printInt(Red);   // conversion is implicit\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nenum class Color { // declared using \"enum class\"\n  Red   = 0xff0000,\n  Green = 0x00ff00,\n  Blue  = 0x0000ff\n};\n\nenum class ProductType { // declared using \"enum class\"\n  Small   = 1,\n  Big     = 2\n};\n\nvoid printColor(Color color); // requires \"Color\" instead of \"int\"\nvoid printInt(int value);\n\nvoid report() {\n  printColor(Color::Red);       // correct\n  // printColor(ProductType::Big); =&gt; Compilation error, no known conversion from 'ProductType' to 'Color'\n  printInt(static_cast&lt;int&gt;(Color::Red)); // conversion never occurs implicitly and must be explicit\n}\n</pre>","debt":"20min"},{"summary":"Methods should not return constants","type":"Code Smell","defaultSeverity":"Minor","description":"<p>There's no point in forcing the overhead of a method call for a method that always returns the same constant value. Even worse, the fact that a\nmethod call must be made will likely mislead developers who call the method thinking that something more is done. Declare a constant instead. </p>\n<p>This rule raises an issue if on methods that contain only one statement: the <code>return</code> of a constant value. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint getBestNumber() {\n  return 12;  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstatic int bestNumber = 12;\n</pre>\n<h2>Exceptions</h2>\n<p><code>override</code>, <code>final</code>, <code>virtual</code> and overriding functions are ignored.</p>","debt":"5min"},{"summary":"The \"register\" storage class specifier should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>According to ISO/IEC 14882 (third edition 2011-09-01) : C++11</p>\n<blockquote>\n  <p>The register specifier shall be applied only to names of variables declared in a block or to function parameters. It specifies that the named\n  variable has automatic storage duration. A variable declared without a storage-class-specifier at block scope or declared as a function parameter\n  has automatic storage duration by default.</p>\n  <p>A register specifier is a hint to the implementation that the variable so declared will be heavily used.[ Note: The hint can be ignored and in\n  most implementations it will be ignored if the address of the variable is taken. This use is <strong>deprecated</strong> - end note ]</p>\n</blockquote>\n<p>In upcoming versions of C/C++ we can expect this deprecated specifier to not be supported anymore. </p>","debt":"5min"},{"summary":"Memory locations should not be released more than once","type":"Bug","defaultSeverity":"Blocker","description":"<p>Using <code>free(...)</code> or <code>delete</code> releases the reservation on a memory location, making it immediately available for another\npurpose. So releasing the same memory location twice can lead to corrupting the program's memory. </p>\n<p>A best practice to avoid this bug calls for setting just-freed pointers to <code>NULL</code>, and always null-testing before a <code>free</code> or\n<code>delete</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid doSomething(int size) {\n  char *cp = (char *)malloc(sizeof(char)*size);\n\n  // ...\n  if(condition) {\n    free(cp);\n  }\n\n  free(cp);  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doSomething(int size) {\n  char *cp = (char *)malloc(sizeof(char)*size);\n\n  // ...\n  if(condition) {\n    if (cp != NULL) {\n      free(cp);\n      cp = NULL;\n    }\n  }\n\n  if (cp) {  // This is a common, short-hand null test\n    free(cp);\n    cp = NULL;\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://cwe.mitre.org/data/definitions/415.html\">MITRE, CWE-415</a> - Double Free </li>\n  <li> <a href=\"https://www.owasp.org/index.php/Double_Free\">OWASP, Double Free</a> </li>\n</ul>","debt":"5min"},{"summary":"Statements should be on separate lines","type":"Code Smell","defaultSeverity":"Major","description":"<p>For better readability, do not put more than one statement on a single line.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo(); bar(); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfoo();\nbar();\n</pre>\n<h2>Exceptions</h2>\n<p>Control flow statements with a single nested statement are ignored.</p>\n<pre>\nif (condition) doSomething();       // Compliant\nwhile (condition) doSomething();    // Compliant\n</pre>\n<p><code>case</code> or <code>default</code> statements containing a single statement and followed by <code>break</code> are ignored.</p>\n<pre>\nswitch (foo) {\n  case  0: doSomething(); break;    // Compliant\n  default: doSomething(); break;    // Compliant\n}\n</pre>\n<p>Statements enclosed in curly braces on the same line are ignored.</p>\n<pre>\nauto lambda = [](int x) { doSomething(x); return x; }; // Compliant\n</pre>","debt":"1min"},{"summary":"Types and variables should be declared in separate statements","type":"Code Smell","defaultSeverity":"Minor","description":"<p>It is possible in the same statement, to declare a user-defined type (<code>class</code>, <code>struct</code>, <code>union</code> or\n<code>enum</code>) followed by variable declarations of this type. But mixing more than one concern in a single statement is confusing for\nmaintainers.</p>\n<p>This rule raises an issue when a variable is declared at the end of a user-defined type declaration statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct Container { int size; } container; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct Container { int size; };\nContainer container;\n</pre>","debt":"2min"},{"summary":"break statements should not be used except for switch cases","type":"Code Smell","defaultSeverity":"Minor","description":"<p><code>break;</code> is an unstructured control flow statement which makes code harder to read.</p>\n<p>Ideally, every loop should have a single termination condition.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (element = list.first; element != null; element = element-&gt;next) { // First termination condition\n  if (!matches(element-&gt;value)) {                                      // Second termination condition\n    break; // Noncompliant\n  }\n\n  /* ... */\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// Compliant\nfor (element = list.first; element != null &amp;&amp; matches(element-&gt;value); element = element-&gt;next) {\n  /* ... */\n}\n</pre>","debt":"10min"},{"summary":"\"#include\" directives should be followed by either <filename> or \"filename\" sequences","type":"Bug","defaultSeverity":"Major","description":"<p>These are the only forms for the <code>#include</code> directive permitted by the standard. The behavior is undefined when other forms are\nused.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include filename.h        // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include \"filename.h\"        // Compliant\n#include &lt;filename.h&gt;\n\n#define HEADER \"filename.h\"\n#include HEADER\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.3 - The #include directive shall be followed by either a &lt;filename&gt; or \"filename\" sequence. </li>\n  <li> MISRA C++:2008, 16-2-6 - The #include directive shall be followed by either a &lt;filename&gt; or \"filename\" sequence. </li>\n  <li> MISRA C:2012, 20.3 - The #include directive shall be followed by either a &lt;filename&gt; or \"filename\" sequence </li>\n</ul>","debt":"10min"},{"summary":"Unions should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The use of unions to access an object in different ways may result in the data being misinterpreted. Therefore, this rule prohibits the use of\nunions for any purpose.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nunion U1 { // Noncompliant\n    float j;\n    int i;\n};\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 18.4 - Unions shall not be used. </li>\n  <li> MISRA C++:2008, 9-5-1 - Unions shall not be used. </li>\n  <li> MISRA C:2012, 19.2 - The union keyword should not be used </li>\n</ul>","debt":"15min"},{"summary":"The global namespace should only contain \"main\", namespace declarations, and \"extern\" C declarations","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Declaring names in appropriate namespaces reduces the number of names found during lookup, helping ensure that the names found meet developer\nexceptions. </p>\n<p>This rule has been tuned to raise an issue when a name part of the global namespace has for sure an external linkage and so exists beyond a\nparticular translation unit. In other words, an issue is raised when a name that is part of the global namespace is for sure accessible through the\nwhole program. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint      a;         // Noncompliant\nint      b = 1;     // Noncompliant\nMyStruct c;         // Noncompliant\nMyStruct d = {1,2}; // Noncompliant\n\nextern int      a = 1;        // Noncompliant\nextern MyStruct b = {1,2};    // Noncompliant and not excluded as the structure is initialized\n\nextern const int      a = 1;     // Noncompliant\nextern const MyStruct b = {1,2}; // Noncompliant and not excluded as the structure is initialized\n\nvoid            m1() { } // Noncompliant\nextern void     m2() { } // Noncompliant\n\nclass A { // Noncompliant\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nnamespace MY_API { // Compliant\n  int  a;\n  int  b = 1;\n  extern const int c = 3;\n  void m1() {\n  }\n\n  class A {\n  };\n}\n\nnamespace {        // Compliant\n  int  b = 1;\n  void m2() {\n  }\n}\n\nint32_t main() {   // Compliant\n\n}\n\nstatic int            a;         // Compliant\nstatic MyStruct       b;         // Compliant\nstatic int            c = 1;     // Compliant\nstatic MyStruct       d = {1,2}; // Compliant\nstatic const int      e = 1;     // Compliant\nstatic const MyStruct f = {1,2}; // Compliant\n\nstatic void                       m1();        // Compliant\nstatic void                       m2()     { } // Compliant\ntemplate &lt;typename T&gt; static void m3(T&amp; a) { } // Compliant\n\nconst int      a = 1;     // Compliant\nconst MyStruct b = {1,2}; // Compliant\n\nextern \"C\" int       a = 1;   // Compliant\nextern \"C\" const int b = 1;   // Compliant\nextern \"C\" void      m1() { } // Compliant\n\ntypedef int      a; // Compliant\ntypedef MyStruct b; // Compliant\n\nbool operator==(const X::Y&amp; p1, const X::Y&amp; p2) { return p1.x == p2.x; }                   // Compliant\nvoid *operator new(size_t bytes, const X::Y&amp; context) { return X::malloc(bytes,context); } // Compliant\nvoid operator delete(void* ptr,  const X::Y&amp; context) { X::free(bytes,context); }          // Compliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 7-3-1 - The global namespace shall only contain main, namespace declarations and extern \"C\" declarations. </li>\n</ul>","debt":"30min"},{"summary":"Files should not have too many lines of code","type":"Code Smell","defaultSeverity":"Major","description":"<p>A source file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to\nmaintain. Above a specific threshold, it is strongly advised to refactor it into smaller pieces of code which focus on well defined tasks. Those\nsmaller files will not only be easier to understand but also probably easier to test.</p>","debt":"1h"},{"summary":"'extern \"C\"' should not be used with namespaces","type":"Code Smell","defaultSeverity":"Minor","description":"<p>The C linkage declaration <code>extern \"C\"</code> can not be combined with a namespace. In practical terms only one function with that name can be\ndeclared as <code>extern \"C\"</code> because the <code>namespace</code> is functionally ignored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nnamespace ns1 {\n    extern \"C\" void doSomething();  // Noncompliant\n    // ...\n}\n\nextern \"C\" {\n  namespace ns2 {  // Noncompliant\n    // ...\n  }\n  // ...\n}\n\nns1::doSomething();\ndoSomething(); // Works too, same as above\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nextern \"C\" void doSomething();\n\nnamespace ns1 {\n  // ...\n}\n\nextern \"C\" {\n  // ...\n}\n\nnamespace ns2 {  // Noncompliant\n  // ...\n}\n\ndoSomething();\n</pre>\n<h2>Exceptions</h2>\n<p><code>extern \"C\"</code> can prefix <code>typedef</code>.</p>\n<pre>\nnamespace ns1 {\n    extern \"C\" typedef void c_function();  // Compliant, type named 'c_function' exists only in 'ns1' and not in the global namespace\n    // ...\n}\n</pre>","debt":"5min"},{"summary":"Conditionals should start on new lines","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Code is clearest when each statement has its own line. Nonetheless, it is a common pattern to combine on the same line an <code>if</code> and its\nresulting <em>then</em> statement. However, when an <code>if</code> is placed on the same line as the closing <code>} </code> from a preceding\n<code>else</code> or <code>else if</code>, it is either an error - <code>else</code> is missing - or the invitation to a future error as maintainers\nfail to understand that the two statements are unconnected.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition1) {\n  // ...\n} if (condition2) {  // Noncompliant\n  //...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition1) {\n  // ...\n} else if (condition2) {\n  //...\n}\n</pre>\n<p>Or</p>\n<pre>\nif (condition1) {\n  // ...\n}\n\nif (condition2) {\n  //...\n}\n</pre>","debt":"10min"},{"summary":"\"#include_next\" should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p><code>#include_next</code> is a gcc-specific language extension that alters the search path for the specified header file by starting the search\nfrom the header file directory <em>after</em> the one in which the directive was encountered. It also ignores the distinction between\n<code>\"file\"</code> and <code>&lt;file&gt;</code>. It is typically used when you have two (probably related) header files with the same name, although\nthere is nothing in the extension to enforce or limit the use to same-name files.</p>\n<p>Use of this extension can be tricky to get right, and is almost never justified. Instead, you should use an absolute path in the\n<code>#include</code> statement or rename one of the files.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include_next \"foo.h\" // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include \"/usr/local/include/foo.h\"\n</pre>","debt":"10min"},{"summary":"Conditionally executed code should be denoted by either indentation or curly braces","type":"Code Smell","defaultSeverity":"Critical","description":"<p>In the absence of enclosing curly braces, the line immediately after a conditional is the one that is conditionally executed. By both convention\nand good practice, such lines are indented. In the absence of both curly braces and indentation the intent of the original programmer is entirely\nunclear and perhaps not actually what is executed. Additionally, such code is highly likely to be confusing to maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition)  // Noncompliant\ndoTheThing();\ndoTheOtherThing();\nsomethingElseEntirely();\n\nfoo();\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition) {\n  doTheThing();\n  doTheOtherThing();\n  somethingElseEntirely();\n}\n\nfoo();\n</pre>\n<p>Or</p>\n<pre>\nif (condition)\n  doTheThing();\ndoTheOtherThing();\nsomethingElseEntirely();\n\nfoo();\n</pre>","debt":"10min"},{"summary":"\"continue\" should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p><code>continue</code> is an unstructured control flow statement. It makes code less testable, less readable and less maintainable. Structured\ncontrol flow statements such as <code>if</code> should be used instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint i;\nfor (i = 0; i &lt; 10; i++) {\n  if (i == 5) {\n    continue;  /* Noncompliant */\n  }\n  printf(\"i = %d\\n\", i);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint i;\nfor (i = 0; i &lt; 10; i++) {\n  if (i != 5) {\n    printf(\"i = %d\\n\", i);\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.5 - The continue statement shall not be used. </li>\n</ul>","debt":"1h"},{"summary":"\"auto\" should not be used as a storage class specifier","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Before C++11, <code>auto</code> was used as a storage class specifier that indicated automatic duration. Since that's the default, the use of\n<code>auto</code> in that context was wholly redundant.</p>\n<p>Because the keyword was redundant and therefore rarely used, C++11 repurposes it. <code>auto</code> is now used to specify that the type of the\nvariable or function should be deduced from its context.</p>\n<p>Since it is redundant under older standards and problematic under C++11, <code>auto</code>'s use as a storage-class identifier should be\nremoved.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nauto int x; // Noncompliant: redundant before C++11, error as of C++11\n\nauto int y;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint x;\n\nauto y = 1 + 2; // C++11: type of 'y' will be inferred\n</pre>","debt":"5min"},{"summary":"Non-standard characters should not occur in header file names in \"#include\" directives","type":"Bug","defaultSeverity":"Major","description":"<p>If the <code>'</code>, <code>\\</code>, <code>\"</code> or <code>/*</code> characters are used between <code>&lt;</code> and <code>&gt;</code>\ndelimiters or the <code>'</code>, <code>\\</code> or <code>/*</code> characters are used between the <code>\"</code> delimiters in a header name\npreprocessing token, then the behavior is undefined.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;\"foo\"&gt;     // Noncompliant\n#include \"dir\\foo.h\" // Noncompliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.2 - Non-standard characters should not occur in header file names in #include directives. </li>\n  <li> MISRA C++:2008, 16-2-4 - The ', \", /* or // characters shall not occur in a header file name. </li>\n  <li> MISRA C++:2008, 16-2-5 - The \\ character should not occur in a header file name. </li>\n  <li> MISRA C:2012, 20.2 - The ', \" or \\ characters and the /* or // character sequences shall not occur in a header file name </li>\n</ul>","debt":"10min"},{"summary":"Unary prefix operators should not be repeated","type":"Bug","defaultSeverity":"Major","description":"<p>The needless repetition of an operator is usually a typo. After all, why write <code>!!!i</code> when <code>!i</code> will do?</p>\n<p>On the other hand, the repetition of increment and decrement operators may have been done on purpose, but doing so obfuscates the meaning, and\nshould be simplified.</p>\n<p>This rule raises an issue for sequences of: <code>!</code>, <code>~</code>, <code>-</code>, and <code>+</code>, and in C++ for repetitions of the\nincrement and decrement operators.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint i = 1;\n\nint j = - - -i;  // Noncompliant; just use -i\nint k = ~~i;     // Noncompliant; same as i\nint m = + +i;    // Noncompliant; operators are useless here\n\nbool b = false;\nbool c = !!!b;   // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint i =  1;\n\nint j = -i;\nint k =  i;\nint m =  i;\n\nbool b = false;\nbool c = !b;\n</pre>\n<h2>Exceptions</h2>\n<p>Boolean normalization <code>!!</code> is ignored.</p>","debt":"5min"},{"summary":"Methods should not have identical implementations","type":"Code Smell","defaultSeverity":"Major","description":"<p>When two methods have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but may\nbe confusing to maintainers. In the latter case, one implementation should invoke the other.</p>\n<p>This rule raises an exception when two methods implemented inside the class definition share the same implementation.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Point {\n  int x;\n  int y;\n\n// .....\n\npublic:\n  void setX(int v) {\n    if (v &gt;= 0 &amp;&amp; v &lt; MAX_X) {\n      x = v;\n      return;\n    }\n    error();\n  }\n\n  void setY(int v) {  // Noncompliant\n    if (v &gt;= 0 &amp;&amp; v &lt; MAX_X) {\n      x = v;\n      return;\n    }\n    error();\n  }\n};\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Point {\n  int x;\n  int y;\n\n// .....\n\npublic:\n void setX(int v) {\n    if (v &gt;= 0 &amp;&amp; v &lt; MAX_X) {\n      x = v;\n      return;\n    }\n    error();\n  }\n\n  void setY(int v) {\n    if (v &gt;= 0 &amp;&amp; v &lt; MAX_X) {\n      y = v;\n      return;\n    }\n    error();\n  }\n};\n</pre>\n<h2>Exceptions</h2>\n<p>Empty methods, methods with the same name (overload) and methods with only one statement are ignored.</p>","debt":"15min"},{"summary":"A function should have a single point of exit at the end of the function","type":"Code Smell","defaultSeverity":"Minor","description":"<p>This is required by IEC 61508, under good programming style.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint function1()\n{\n  return 3;\n}\n\nvoid function2()\n{\n  function1();\n}\n\nint function3(char* ptr) /* Noncompliant; two explicit returns */\n{\n  if (ptr == NULL) return -1;\n\n  return 7;\n}\n\nvoid function4(char *ptr) /* Noncompliant; two returns, one explicit and one implicit */\n{\n  if (1) return;\n\n  printf(\"hello world!\\n\");\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.7 - A function shall have a single point of exit at the end of the function. </li>\n  <li> MISRA C++:2008, 6-6-5 - A function shall have a single point of exit at the end of the function </li>\n  <li> MISRA C:2012, 15.5 - A function should have a single point of exit at the end </li>\n</ul>","debt":"20min"},{"summary":"\"switch\" statements should end with \"default\" clauses","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The requirement for a final <code>default</code> clause is defensive programming. The clause should either take appropriate action, or contain a\nsuitable comment as to why no action is taken. When the <code>switch</code> covers all current values of an <code>enum</code> - and especially when it\ndoesn't - a <code>default</code> case should still be used because there is no guarantee that the <code>enum</code> won't be extended.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (param) { // Noncompliant - default clause is missing\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n  default:\n    doDefault();\n    break;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.0 - The MISRA C <em>switch</em> syntax shall be used. </li>\n  <li> MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause </li>\n  <li> MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. </li>\n  <li> MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause </li>\n  <li> MISRA C:2012, 16.1 - All switch statements shall be well-formed </li>\n  <li> MISRA C:2012, 16.4 - Every <em>switch</em> statement shall have a <em>default</em> label </li>\n  <li> MISRA C:2012, 16.5 - A <em>default</em> label shall appear as either the first or the last <em>switch label</em> of a <em>switch</em> statement\n  </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/478.html\">MITRE, CWE-478</a> - Missing Default Case in Switch Statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/YgE\">CERT, MSC01-C.</a> - Strive for logical completeness </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/JoIyAQ\">CERT, MSC01-CPP.</a> - Strive for logical completeness </li>\n</ul>\n<h3>See also</h3>\n<ul>\n  <li> <a href='/coding_rules#rule_key=cpp%3AS3562'>S3562</a> </li>\n</ul>","debt":"5min"},{"summary":"The original exception object should be rethrown","type":"Bug","defaultSeverity":"Major","description":"<p>Rethrowing an unmodified copy of the caught exception is a waste of resources. Additionally, doing so may lead to a loss of precision in the object\ntype and its data, since the copy will be an instance of the base class, rather than of the potentially more specific exception class originally\ncaught.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntry {\n  throw std::invalid_argument(\"x\");\n} catch (const std::exception&amp; ex) {\n  /* ... */\n  throw ex; // Noncompliant; the received \"std::invalid_argument\" is copied into a less specialized class \"std::exception\"\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntry {\n  throw std::invalid_argument(\"x\");\n} catch (const std::exception&amp; ex) {\n  /* ... */\n  throw; // rethrows the initial \"std::invalid_argument\"\n}\n</pre>","debt":"5min"},{"summary":"#include directives in a file should only be preceded by other preprocessor directives or comments","type":"Code Smell","defaultSeverity":"Major","description":"<p>To aid code readability, all the <code>#include</code> directives in a particular code file should be grouped together near the top of the file.\nThe only items which may precede an <code>#include</code> in a file are other preprocessor directives or comments.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#include &lt;h1.h&gt; /* Compliant */\nint32_t i;\n#include &lt;f2.h&gt; /* Noncompliant */\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#include &lt;h1.h&gt;\n#include &lt;f2.h&gt;\n\nint32_t i;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. </li>\n  <li> MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. </li>\n  <li> MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments </li>\n</ul>","debt":"10min"},{"summary":"\"if ... else if\" constructs should end with \"else\" clauses","type":"Code Smell","defaultSeverity":"Critical","description":"<p>This rule applies whenever an <code>if</code> statement is followed by one or more <code>else if</code> statements; the final <code>else if</code>\nshould be followed by an <code>else</code> statement.</p>\n<p>The requirement for a final <code>else</code> statement is defensive programming.</p>\n<p>The <code>else</code> statement should either take appropriate action or contain a suitable comment as to why no action is taken. This is\nconsistent with the requirement to have a final <code>default</code> clause in a <code>switch</code> statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (x == 0) {\n  doSomething();\n} else if (x == 1) {\n  doSomethingElse();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (x == 0) {\n  doSomething();\n} else if (x == 1) {\n  doSomethingElse();\n} else {\n  error();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.10 - All if...else if constructs shall be terminated with an else clause. </li>\n  <li> MISRA C++:2008, 6-4-2 - All if...else if constructs shall be terminated with an else clause. </li>\n  <li> MISRA C:2012, 15.7 - All if...else if constructs shall be terminated with an else statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/YgE\">CERT, MSC01-C.</a> - Strive for logical completeness </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/JoIyAQ\">CERT, MSC01-CPP.</a> - Strive for logical completeness </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/PQHRAw\">CERT, MSC57-J.</a> - Strive for logical completeness </li>\n</ul>","debt":"5min"},{"summary":"Switch cases should end with an unconditional \"break\" statement","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>When the execution is not explicitly terminated at the end of a switch case, it continues to execute the statements of the following case. While\nthis is sometimes intentional, it often is a mistake which leads to unexpected behavior. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:  // Both 'doSomething()' and 'doSomethingElse()' will be executed. Is it on purpose ?\n    doSomething();\n  default:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule is relaxed in the following cases:</p>\n<pre>\nswitch (myVariable) {\n  case 0:                                // Empty case used to specify the same behavior for a group of cases.\n  case 1:\n    doSomething();\n    break;\n  case 2:                                // Use of return statement\n    return;\n  case 3:                                // Use of throw statement\n    throw 1;\n  case 4:                                // Use of continue statement\n    continue;\n  default:                               // For the last case, use of break statement is optional\n    doSomethingElse();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.0 - The MISRA C <em>switch</em> syntax shall be used. </li>\n  <li> MISRA C:2004, 15.2 - An unconditional break statement shall terminate every non-empty switch clause </li>\n  <li> MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. </li>\n  <li> MISRA C++:2008, 6-4-5 - An unconditional throw or break statement shall terminate every non-empty switch-clause </li>\n  <li> MISRA C:2012, 16.1 - All switch statements shall be well-formed </li>\n  <li> MISRA C:2012, 16.3 - An unconditional break statement shall terminate every switch-clause </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/484.html\">MITRE, CWE-484</a> - Omitted Break Statement in Switch </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/YIFLAQ\">CERT, MSC17-C.</a> - Finish every set of statements associated with a case\n  label with a break statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ZoFLAQ\">CERT, MSC18-CPP.</a> - Finish every set of statements associated with a case\n  label with a break statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ewHAAQ\">CERT, MSC52-J.</a> - Finish every set of statements associated with a case\n  label with a break statement </li>\n</ul>","debt":"10min"},{"summary":"Array values should not be replaced unconditionally","type":"Bug","defaultSeverity":"Major","description":"<p>It is highly suspicious when a value is saved for a key or index and then unconditionally overwritten. Such replacements are likely in error.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ntowns[i] = \"London\";\ntowns[i] = \"Chicago\";  // Noncompliant\n</pre>","debt":"5min"},{"summary":"Include directives should not rely on non-portable search strategy","type":"Code Smell","defaultSeverity":"Major","description":"<p>Microsoft's MSVC has a search strategy which differs from other compilers when resolving quoted include directives <code>#include \"file.h\"</code>.\nRelying on such a strategy is not portable and may lead to compilation failure when trying to build with a different compiler.</p>\n<p>This rule raises an issue whenever the file specified in a <code>#include</code> directive can only be found using the MSVC search strategy.</p>\n<h2>See</h2>\n<p><a href=\"https://docs.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp\">MSVC documentation</a></p>","debt":"5min"},{"summary":"\"goto\" should jump to labels declared later in the same function","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Unconstrained use of <code>goto</code> can lead to programs that are extremely difficult to comprehend and analyse. For C++, it can also lead to\nthe program exhibiting unspecified behavior.</p>\n<p>However, in many cases a total ban on <code>goto</code> requires the introduction of flags to ensure correct control flow, and it is possible that\nthese flags may themselves be less transparent than the <code>goto</code> they replace.</p>\n<p>Therefore, the restricted use of <code>goto</code> is allowed where that use will not lead to semantics contrary to developer expectations. \"Back\"\njumps are prohibited, since they can be used to create iterations without using the well-defined iteration statements supplied by the core\nlanguage.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint f() {\n  int j = 0;\nL1:\n  ++j;\n  if (10 == j) {\n    goto L2;         // forward jump ignored\n  }\n  // ...\n  goto L1;           // Noncompliant\nL2:\n  return ++j;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint f() {\n  for (int j = 0; j &lt; 11; j++) {\n    // ...\n  }\n  return ++j;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 6-6-2 - The goto statement shall jump to a label declared later in the same function body </li>\n  <li> MISRA C:2012, 15.2 - The goto statement shall jump to a label declared later in the same function </li>\n</ul>","debt":"1h"},{"summary":"Exceptions should not be thrown in \"noexcept\" functions","type":"Code Smell","defaultSeverity":"Critical","description":"<p>If you declare a function with <code>noexcept</code> or <code>throw()</code>, it's unexpected and confusing from a maintainer point of view to find\na <code>throw</code> clause in the definition of the function.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint divide(int numerator, int denominator) noexcept { // Promises that nothing will be thrown\n  if (denominator == 0) {\n    throw std::invalid_argument(\"invalid denominator\"); // Noncompliant; implementation breaks promise\n  }\n  return numerator / denominator;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint divide(int numerator, int denominator) noexcept {\n  if (denominator == 0) {\n    return numerator &lt; 0 ? INT_MIN : INT_MAX; // throw clause has been removed\n  }\n  return numerator / denominator;\n}\n</pre>","debt":"20min"},{"summary":"Increment (++) and decrement (--) operators should not be used in a method call or mixed with other operators in an expression","type":"Code Smell","defaultSeverity":"Major","description":"<p>The use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:</p>\n<ul>\n  <li> It can significantly impair the readability of the code. </li>\n  <li> It introduces additional side effects into a statement, with the potential for undefined behavior. </li>\n  <li> It is safer to use these operators in isolation from any other arithmetic operators. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nu8a = ++u8b + u8c--;\nfoo = bar++ / 4;\n</pre>\n<h2>Compliant Solution</h2>\n<p>The following sequence is clearer and therefore safer:</p>\n<pre>\n++u8b;\nu8a = u8b + u8c;\nu8c--;\nfoo = bar / 4;\nbar++;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.1 - Limited dependence should be placed on the C operator precedence rules in expressions. </li>\n  <li> MISRA C:2004, 12.13 - The increment (++) and decrement (--) operators should not be mixed with other operators in an expression. </li>\n  <li> MISRA C++:2008, 5-2-10 - The increment (++) and decrement (--) operator should not be mixed with other operators in an expression. </li>\n  <li> MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit </li>\n  <li> MISRA C:2012, 13.3 - A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects\n  other than that cause by the increment or decrement operator </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ZwE\">CERT, EXP30-C.</a> - Do not depend on the order of evaluation for side effects\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/fYAyAQ\">CERT, EXP50-CPP.</a> - Do not depend on the order of evaluation for side\n  effects </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/yQC7AQ\">CERT, EXP05-J.</a> - Do not follow a write by a subsequent write or read of the\n  same object within an expression </li>\n</ul>","debt":"5min"},{"summary":"Macros should not be redefined","type":"Code Smell","defaultSeverity":"Minor","description":"<p>A macro definition should not be redefined without marking that intent specifically by un-defining it first.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#define A 1\n#define A 2\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n#define A 1\n#undef A\n#define A 2\n</pre>\n<h2>Exceptions</h2>\n<p>If the redefinition has the same value as the original one. This is consistent with most C compilers warnings.</p>\n<pre>\n#define A 1\n#define A 1\n</pre>","debt":"5min"},{"summary":"Raw string literals should be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Since C++11, raw string literals can be used to avoid the need to escape characters in a string. Such character string literals are easier to\nread.</p>\n<p>This rule raises an issue when a non-raw string contains one of the following escaped characters: <code>\\'</code> <code>\\\\</code> <code>\\\"</code>\n<code>\\?</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst char* Path = \"C:\\\\Program Files\\\\Microsoft Office\\\\Office16\\\\\";  // Noncompliant, contains \\\\\nconst char* RegEx = \"\\\\\\\\(\\\\\\\\.\\\\\\\\)\"; // Noncompliant, contains \\\\\nconst char* QuestionMark = \"a\\?b\"; // Noncompliant, contains \\?\nconst char* TwoLines = \"one\\r\\ntwo\"; // Compliant, contains \\r \\n\nconst char* OneChar = \"\\\\\"; // Compliant, only one character\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst char* Path = R\"(C:\\Program Files\\Microsoft Office\\Office16\\)\";\nconst char* RegEx = R\"(\\(\\.\\))\";\nconst char* QuestionMark = R\"(a?b)\";\nconst char* TwoLines = \"one\\r\\ntwo\";\nconst char* OneChar = \"\\\\\";\n</pre>\n<h2>Exceptions</h2>\n<p>To preserve readability, this rule ignores strings containing only one character and strings with escaped whitespace or non-printable\ncharacters:</p>\n<ul>\n  <li> Non-printable characters: <code>\\a</code> <code>\\b</code> <code>\\f</code> <code>\\v</code> <code>\\nnn</code> <code>\\xnn</code>\n  <code>\\unnnn</code> <code>\\Unnnnnnnn</code> </li>\n  <li> Tab: <code>\\t</code> </li>\n  <li> New line: <code>\\r</code> <code>\\n</code> </li>\n</ul>","debt":"2min"},{"summary":"Jump statements should not be redundant","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Jump statements, such as <code>return</code>, <code>break</code>, <code>goto</code>, and <code>continue</code> let you change the default flow of\nprogram execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid Foo()\n{\n  goto A; // Noncompliant\n  A:\n  while (condition1)\n  {\n    if (condition2)\n    {\n      continue; // Noncompliant\n    }\n    else\n    {\n      DoTheThing();\n    }\n  }\n  return; // Noncompliant; this is a void method\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid Foo()\n{\n  while (condition1)\n  {\n    if (!condition2)\n    {\n      DoTheThing();\n    }\n  }\n}\n</pre>","debt":"1min"},{"summary":"Classes should not have too many methods","type":"Code Smell","defaultSeverity":"Major","description":"<p>A class that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain.\nAbove a specific threshold, it is strongly advised to refactor the class into smaller ones which focus on well defined topics.</p>","debt":"1h"},{"summary":"Track instances of the \"#error\" preprocessor directive being reached","type":"Code Smell","defaultSeverity":"Info","description":"<p>This rule creates a issue whenever an <code>#error</code> preprocessor directive is reached during the project's analysis. In most cases, this\nindicates that the preprocessor was badly configured. Some predefined macros or library include paths might be required to fix the configuration.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#error This is an error\n</pre>"},{"summary":"Unused type declarations should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>If a type is declared but not used, then it is unclear to a reviewer if the type is redundant or it has been left unused by mistake.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid unusedtype()\n{\n  typedef int local_Type; // Noncompliant, unused\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 0-1-5 - A project shall not contain unused type declarations. </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/OYIyAQ\">CERT, MSC07-CPP.</a> - Detect and remove dead code </li>\n</ul>","debt":"10min"},{"summary":"Resources should be closed","type":"Bug","defaultSeverity":"Blocker","description":"<p>A call to the <code>fopen()</code> function must be matched with a call to <code>fclose()</code>. Otherwise, you run the risk of using up all the\nOS's file handles, which could lock up not just your program but potentially everything on the box.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint fun() {\n  FILE *f = fopen(\"file\", \"r\");\n  if (f == NULL) {\n    return -1;\n  }\n  // ...\n  return 0; // Noncompliant, file f has not been closed\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint fun() {\n  FILE *f = fopen(\"file\", \"r\");\n  if (f == NULL) {\n    return -1;\n  }\n  // ...\n  fclose(f);\n  return 0;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/459.html\">MITRE, CWE-459</a> - Incomplete Cleanup </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/9gFqAQ\">CERT, FIO04-J.</a> - Release resources when they are no longer needed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/GAGQBw\">CERT, FIO42-C.</a> - Close files when they are no longer needed </li>\n  <li> <a href=\"https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html\">Try With Resources</a> </li>\n</ul>","debt":"5min"}]}