{"types":{"Vulnerability":1,"Code Smell":123,"Bug":38,"Other":0},"rules":[{"summary":"Variables should be declared only once in a scope","type":"Bug","defaultSeverity":"Blocker","description":"<p>At most one declaration of a variable in a given scope is allowed in PL/SQL. The <code>PLS-00371</code> error will be raised at runtime when\nattempting to reference a variable declared more than once.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  foo VARCHAR2(42) := 'foo';\n  foo VARCHAR2(42) := 'bar'; -- Non-Compliant\nBEGIN\n  DBMS_OUTPUT.PUT_LINE(foo); -- Raises PLS-00371: at most one declaration for 'FOO' is permitted\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  foo VARCHAR2(42) := 'foo';\n  bar VARCHAR2(42) := 'bar'; -- Compliant\nBEGIN\n  DBMS_OUTPUT.PUT_LINE(foo);\nEND;\n/\n</pre>","debt":"1h"},{"summary":"\"COMMIT\" should not be used inside a loop","type":"Bug","defaultSeverity":"Critical","description":"<p>Frequent commits are widely understood to negatively impact performance. Thus, committing inside a loop (even when only executed conditionally once\nevery n iterations) is highly likely to cause unwanted performance impacts. </p>\n<p>Further, in general use <code>COMMIT</code> should only be used at the end of a transaction. Code that is not structured to have one transaction\nper loop iteration could yield unexpected results if <code>COMMIT</code> is nonetheless used inside the loop. Code that <em>is</em> structured to have\none transaction per loop iteration should probably be reconsidered.</p>\n<p>Note that when dealing with very large data sets, a <code>COMMIT</code> may be required every n iterations, but the goal should be to avoid\n<code>COMMIT</code>s inside loops.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nFOR item IN itemlist\nLOOP\n  -- ...\n  COMMIT;  -- Noncompliant\nEND LOOP;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nFOR item IN itemlist\nLOOP\n  -- ...\nEND LOOP;\nCOMMIT;\n</pre>","debt":"20min"},{"summary":"Function and procedure names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Major","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nCREATE FUNCTION my_function_ RETURN PLS_INTEGER AS -- Noncompliant\nBEGIN\n  RETURN 42;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nCREATE FUNCTION my_function RETURN PLS_INTEGER AS\nBEGIN\n  RETURN 42;\nEND;\n/\n</pre>","debt":"2h"},{"summary":"\"FETCH ... BULK COLLECT INTO\" should not be used without a \"LIMIT\" clause","type":"Bug","defaultSeverity":"Blocker","description":"<p>A <code>FETCH ... BULK COLLECT INTO</code> without a <code>LIMIT</code> clause will load all the records returned by the cursor at once. This may\nlead to memory exhaustion. Instead, it is better to process the records in chunks using the <code>LIMIT</code> clause.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\n-- Fetches all records at once, requiring lots of memory\nDECLARE\n  TYPE largeTableRowArrayType IS TABLE OF largeTable%ROWTYPE;\n  largeTableRowArray largeTableRowArrayType;\n  CURSOR myCursor IS SELECT * FROM largeTable;\nBEGIN\n  OPEN myCursor;\n\n  FETCH myCursor BULK COLLECT INTO largeTableRowArray; -- Non-compliant\n\n  DBMS_OUTPUT.PUT_LINE('Alternative 1: ' || largeTableRowArray.COUNT || ' records');\n\n  CLOSE myCursor;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\n-- fetches one chunk at a time, requiring constant memory\nDECLARE\n  TYPE largeTableRowArrayType IS TABLE OF largeTable%ROWTYPE;\n  largeTableRowArray largeTableRowArrayType;\n  CURSOR myCursor IS SELECT * FROM largeTable;\n  counter PLS_INTEGER := 0;\nBEGIN\n  OPEN myCursor;\n\n  LOOP\n    FETCH myCursor BULK COLLECT INTO largeTableRowArray LIMIT 1000; -- Compliant\n\n    counter := counter + largeTableRowArray.COUNT;\n\n    EXIT WHEN myCursor%NOTFOUND;\n  END LOOP;\n\n  DBMS_OUTPUT.PUT_LINE('Alternative 1: ' || counter || ' records');\n\n  CLOSE myCursor;\nEND;\n/\n\nDROP TABLE largeTable;\n</pre>","debt":"2h"},{"summary":"Lines should not end with trailing whitespaces","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Trailing whitespaces are simply useless and should not stay in code. They may generate noise when comparing different versions of the same\nfile.</p>\n<p>If you encounter issues from this rule, this probably means that you are not using an automated code formatter - which you should if you have the\nopportunity to do so. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  -- The following line has many trailing whitespaces\n  foo VARCHAR2(42) := 'a\nb';\nBEGIN\n  -- Will misleadingly show 3, counting only the characters 'a', 'b', and the line terminator, but none of the trailing whitespaces\n  DBMS_OUTPUT.PUT_LINE(LENGTH(foo));\nEND;\n/\n</pre>","debt":"1min"},{"summary":"\"NOT NULL\" variables should be initialized","type":"Bug","defaultSeverity":"Blocker","description":"<p>Variables and fields declared as <code>NOT NULL</code> must be immediately initialized, since they cannot be implicitly initialized to\n<code>NULL</code>. This rule prevents <code>PLS-00218</code> exceptions from being raised at runtime.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  test PLS_INTEGER; -- This variable is implicitly initialized to NULL\n\n  foo PLS_INTEGER NOT NULL; -- Noncompliant PLS-00218 a variable declared NOT NULL must have an initialization assignment\n\n  TYPE myType IS RECORD(\n    foo PLS_INTEGER NOT NULL, -- Non-Compliant PLS-00218 a variable declared NOT NULL must have an initialization assignment\n    bar PLS_INTEGER NULL\n  );\nBEGIN\n  IF test IS NULL\n    DBMS_OUTPUT.PUT_LINE('test is NULL');\n  ELSE\n    DBMS_OUTPUT.PUT_LINE('test is NOT NULL');\n  END IF;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  test PLS_INTEGER; -- This variable is implicitly initialized to NULL\n\n  foo PLS_INTEGER NOT NULL := 42; -- Compliant\n\n  TYPE myType IS RECORD(\n    foo PLS_INTEGER NOT NULL := 42, -- Compliant\n    bar PLS_INTEGER NULL\n  );\nBEGIN\n  IF test IS NULL\n    DBMS_OUTPUT.PUT_LINE('test is NULL');\n  ELSE\n    DBMS_OUTPUT.PUT_LINE('test is NOT NULL');\n  END IF;\nEND;\n/\n</pre>","debt":"15min"},{"summary":"Variables should be nullable","type":"Code Smell","defaultSeverity":"Major","description":"<p>Declaring a variable with the NOT NULL constraint incurs a small performance cost - while this constraint may not really be required. Using such a\nconstraint should be avoided.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  counter PLS_INTEGER NOT NULL := 0; -- Noncompliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  counter PLS_INTEGER := 0; -- Compliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"1h"},{"summary":"Lines should not be too long","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.</p>","debt":"1min"},{"summary":"Variables and columns should not be self-assigned","type":"Bug","defaultSeverity":"Major","description":"<p>There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nUPDATE person\nSET name = name;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nUPDATE person\nSET name = UPPER(name);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"3min"},{"summary":"SQL EXISTS subqueries should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>SQL queries that use <code>EXISTS</code> subqueries are inefficient because the subquery is re-run for every row in the outer query's table. There\nare more efficient ways to write most queries, ways that do not use the <code>EXISTS</code> condition.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSELECT e.name\nFROM employee e\nWHERE EXISTS (SELECT * FROM department d WHERE e.department_id = d.id AND d.name = 'Marketing');\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSELECT e.name\nFROM employee e INNER JOIN department d\n  ON e.department_id = d.id AND d.name = 'Marketing';\n</pre>","debt":"1h"},{"summary":"Native SQL joins should be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>SQL is an extremely powerful and hard to master language. It may be tempting to emulate SQL joins in PL/SQL using nested cursor loops, but those\nare not optimized by Oracle at all. In fact, they lead to numerous context switches between the SQL and PL/SQL engines, and those switches have a\nhighly negative impact on performance. It is therefore much better to replace nested PL/SQL cursor loops with native SQL joins.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE countriesTable(\n  countryName VARCHAR2(42)\n);\n\nCREATE TABLE citiesTable(\n  cityName VARCHAR2(42)\n);\n\nINSERT INTO countriesTable VALUES('India');\nINSERT INTO countriesTable VALUES('Switzerland');\nINSERT INTO countriesTable VALUES('United States');\n\nINSERT INTO citiesTable VALUES('Berne');\nINSERT INTO citiesTable VALUES('Delhi');\nINSERT INTO citiesTable VALUES('Bangalore');\nINSERT INTO citiesTable VALUES('New York');\n\nBEGIN\n  FOR countryRecord IN (SELECT countryName FROM countriesTable) LOOP\n    FOR cityRecord IN (SELECT cityName FROM citiesTable) LOOP -- Non-Compliant\n      DBMS_OUTPUT.PUT_LINE('Country: ' || countryRecord.countryName || ', City: ' || cityRecord.cityName);\n    END LOOP;\n  END LOOP;\nEND;\n/\n\nDROP TABLE citiesTable;\n\nDROP TABLE countriesTable;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE countriesTable(\n  countryName VARCHAR2(42)\n);\n\nCREATE TABLE citiesTable(\n  cityName VARCHAR2(42)\n);\n\nINSERT INTO countriesTable VALUES('India');\nINSERT INTO countriesTable VALUES('Switzerland');\nINSERT INTO countriesTable VALUES('United States');\n\nINSERT INTO citiesTable VALUES('Berne');\nINSERT INTO citiesTable VALUES('Delhi');\nINSERT INTO citiesTable VALUES('Bangalore');\nINSERT INTO citiesTable VALUES('New York');\n\nBEGIN\n  FOR myRecord IN (SELECT * FROM countriesTable CROSS JOIN citiesTable) LOOP -- Compliant\n    DBMS_OUTPUT.PUT_LINE('Country: ' || myRecord.countryName || ', City: ' || myRecord.cityName);\n  END LOOP;\nEND;\n/\n\nDROP TABLE citiesTable;\n\nDROP TABLE countriesTable;\n</pre>","debt":"2h"},{"summary":"Scale should not be specified for float types","type":"Bug","defaultSeverity":"Blocker","description":"<p>Float data types, such as <code>FLOAT</code>, <code>DOUBLE PRECISION</code>, and <code>REAL</code> cannot have a scale constraint. Trying to\nspecify a scale results in the exception <code>PLS-00510: Float cannot have scale being raised.</code></p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  foo FLOAT(10, 3); -- Noncompliant - raises PLS-00510\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  foo FLOAT(10); -- Compliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"5min"},{"summary":"Function and procedure parameters should comply with a naming convention","type":"Code Smell","defaultSeverity":"Major","description":"<p>Each function and procedure parameter name must match a given regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  FUNCTION myfunction2(parameter_ PLS_INTEGER) RETURN PLS_INTEGER; -- Noncompliant\n\n  PROCEDURE myprocedure2(parameter_ PLS_INTEGER); -- Noncompliant\n\n  FUNCTION myfunction2(parameter_ PLS_INTEGER) RETURN PLS_INTEGER AS -- Noncompliant\n  BEGIN\n    RETURN 42;\n  END;\n\n  PROCEDURE myprocedure2(parameter_ PLS_INTEGER) AS -- Noncompliant\n  BEGIN\n    NULL;\n  END;\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  FUNCTION myfunction1(parameter PLS_INTEGER) RETURN PLS_INTEGER; -- Compliant\n\n  PROCEDURE myprocedure1(parameter PLS_INTEGER); -- Compliant\n\n  FUNCTION myfunction1(parameter PLS_INTEGER) RETURN PLS_INTEGER AS -- Compliant\n  BEGIN\n    RETURN 42;\n  END;\n\n  PROCEDURE myprocedure1(parameter PLS_INTEGER) AS -- Compliant\n  BEGIN\n    NULL;\n  END;\n\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"30min"},{"summary":"SQL tables should be joined with the \"JOIN\" keyword","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Since ANSI SQL-92, explicit joins using the <code>JOIN</code> keyword have been possible, and are preferred. Therefore table joins should be done\nwith help of the one of the following clauses: <code>JOIN</code>, <code>INNER JOIN</code>, <code>LEFT OUTER JOIN</code>, <code>RIGHT OUTER\nJOIN</code>, and <code>FULL OUTER JOIN</code>. The old way to join tables is deprecated and should not be used anymore.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSELECT *\nFROM PARTS, PRODUCTS\nWHERE PARTS.PROD = PRODUCTS.PROD\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSELECT *\nFROM PARTS\nINNER JOIN PRODUCTS ON PARTS.PROD = PRODUCTS.PROD\n</pre>","debt":"30min"},{"summary":"\"FOR\" loop end conditions should not be hard-coded","type":"Code Smell","defaultSeverity":"Major","description":"<p>Hard-coding bounds in FOR loops is a bad practice, just as magic numbers in general are. Often, those magic bounds can be replaced by dynamic\nvalues. If that is not possible, replacing the literal number with a constant is still better.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  TYPE myCollectionType IS VARRAY(3) OF VARCHAR2(42);\n  myCollection myCollectionType := myCollectionType('David', 'John', 'Richard');\n\nBEGIN\n\n  FOR i IN 2 .. 3 -- Noncompliant; magic numbers used for the loop bounds\n  LOOP\n    DBMS_OUTPUT.PUT_LINE('name = ' || myCollection(i));\n  END LOOP;\n\n  FOR i IN 2 .. myCollection.LAST -- Noncompliant, better but still magic\n  LOOP\n    DBMS_OUTPUT.PUT_LINE('name = ' || myCollection(i));\n  END LOOP;\n\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  TYPE myCollectionType IS VARRAY(3) OF VARCHAR2(42);\n  myCollection myCollectionType := myCollectionType('David', 'John', 'Richard');\n\nBEGIN\n  FOR i IN myCollection.FIRST .. myCollection.LAST\n  LOOP\n    DBMS_OUTPUT.PUT_LINE('name = ' || myCollection(i));\n  END LOOP;\nEND;\n/\n</pre>","debt":"10min"},{"summary":"\"PLS_INTEGER\" types should be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Using a <code>NUMBER</code> to store an integer is less performant than using a <code>PLS_INTEGER</code>. <code>PLS_INTEGER</code>s require less\nstorage than <code>NUMBER</code>s, and benefit from the use of hardware math, as opposed to the library math required for <code>NUMBER</code>s. Even\nmore performant is the <code>SIMPLE_INTEGER</code> subtype of <code>PLS_INTEGER</code>. However, changing to either of these types is only appropriate\nunder certain circumstances.</p>\n<p><code>PLS_INTEGER</code> is only a candidate for <code>NUMBER</code> with a scale of up to 9.</p>\n<p><code>SIMPLE_INTEGER</code> has the same size limitation, in addition to it's <code>NOT NULL</code> constraint and lack of overflow checking.</p>\n<p>This rule raises an issue when a <code>NUMBER</code> is declared with a scale of 9 or less.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n    son NUMBER(1);      -- Noncompliant\n    rumbo NUMBER(9);  -- Noncompliant\n    conga Number(10);   -- Ignored; falls outside the PLS_INTEGER range\n    compalsa PLS_INTEGER;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n    son SIMPLE_INTEGER;\n    rumbo PLS_INTEGER;\n    conga Number(10);   -- Ignored; falls outside the PLS_INTEGER range\n    compalsa PLS_INTEGER;\n</pre>","debt":"5min"},{"summary":"\"EXIT WHEN\" should be used rather than \"IF ... THEN EXIT; END IF;\"","type":"Code Smell","defaultSeverity":"Major","description":"<p>The <code>EXIT WHEN</code> syntax can exit a loop depending on a condition. It should be preferred to the more verbose and error-prone <code>IF ...\nTHEN EXIT; END IF;</code> syntax.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  i PLS_INTEGER;\nBEGIN\n\n  i := 0;\n  LOOP\n    IF i &gt; 10 THEN -- Noncompliant\n       EXIT;\n    END IF;\n\n    DBMS_OUTPUT.PUT_LINE('i = ' || i);\n    i := i + 1;\n  END LOOP;\n\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  i PLS_INTEGER;\nBEGIN\n\n  i := 0;\n  LOOP\n    EXIT WHEN i &gt; 10;\n\n    DBMS_OUTPUT.PUT_LINE('i = ' || i);\n    i := i + 1;\n  END LOOP;\nEND;\n/\n</pre>","debt":"2min"},{"summary":"\"IF\" statement conditions should not evaluate unconditionally to \"TRUE\" or to \"FALSE\"","type":"Bug","defaultSeverity":"Major","description":"<p><code>IF</code> statements with conditions that are always false have the effect of making blocks of code non-functional. This can be useful during\ndebugging, but should not be checked in. <code>IF</code> statements with conditions that are always true are completely redundant, and make the code\nless readable. In either case, unconditional <code>IF</code> statements should be removed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nIF TRUE THEN\n  do_something;\nEND IF;\n\nIF FALSE THEN\n  do_something_else;\nEND IF;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ndo_something;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/489.html\">MITRE, CWE-489</a> - Leftover Debug Code </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/570.html\">MITRE, CWE-570</a> - Expression is Always False </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/571.html\">MITRE, CWE-571</a> - Expression is Always True </li>\n  <li> MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. </li>\n  <li> MISRA C:2012, 14.3 - Controlling expressions shall not be invariant </li>\n</ul>","debt":"10min"},{"summary":"Record fields should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all record field names match the provided regular\nrexpression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>[a-zA-Z](_?+[a-zA-Z0-9])*+</code>:</p>\n<pre>\nDECLARE\n  TYPE my_type IS RECORD(\n    foo__bar PLS_INTEGER   -- Non-Compliant\n  );\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  TYPE my_type IS RECORD(\n    foo_bar PLS_INTEGER    -- Compliant\n  );\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"30min"},{"summary":"\"END LOOP\" should be followed by a semicolon","type":"Bug","defaultSeverity":"Blocker","description":"<p>Labeled loops are useful, especially when the code is badly indented, to match the begin and end of each loop. However, those labels, if used, must\nappear on the same line as the \"END\" keyword in order to avoid any confusion. Indeed, the label might otherwise be seen as a procedure call.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  PROCEDURE foo AS\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('foo was called!');\n  END;\nBEGIN\n  LOOP\n    EXIT;\n  END LOOP -- The semicolon was forgotten\n\n  foo; -- Noncompliant, This is interpreted as a label of the previous FOR loop, not as a procedure call to foo!\n\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  PROCEDURE foo AS\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('foo was called!');\n  END;\nBEGIN\n\n  &lt;&lt;myLoopLabel&gt;&gt;\n  LOOP\n    EXIT;\n  END LOOP myLoopLabel;\n\n  foo; -- Correctly interpreted as a procedure call to foo\nEND;\n/\n</pre>","debt":"1min"},{"summary":"Large item lists should not be used with \"IN\" clauses","type":"Code Smell","defaultSeverity":"Major","description":"<p>Oracle supports at most 1000 items in a SQL query's <code>IN</code> clause. When more items are given, the exception <code>ORA-01795 maximum number\nof expressions in a list is 1000</code> is raised. Thus, <code>IN</code> clauses are not as scalable as joins.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  SELECT *\n  INTO result\n  FROM my_table\n  WHERE col1 IN (1, 2, 3, ..., 1001);       -- Noncompliant - raises ORA-01795\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  SELECT my_table.*\n  INTO result\n  FROM my_table\n  JOIN new_in_table\n  WHERE my_table.col1 = new_in_table.value; -- Compliant\nEND;\n/\n</pre>","debt":"4h"},{"summary":"\"CASE\" should be used rather than \"DECODE\"","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>DECODE</code> is an old function that has been replaced by the easier to understand and more common <code>CASE</code>. Unlike\n<code>DECODE</code>, <code>CASE</code> may also be used directly within PL/SQL.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  operand CHAR(1) := 'B';\n  l_result PLS_INTEGER;\nBEGIN\n  -- Noncompliant\n  SELECT DECODE(operand, 'A', 1\n                       , 'B', 2\n                       , 'C', 3\n                       , 'D', 4\n                       , 'E', 5\n                       , 'F', 6\n                       , 7)\n  INTO l_result\n  FROM dual;\n\n  DBMS_OUTPUT.PUT_LINE('l_result = ' || l_result); -- 2\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  operand CHAR(1) := 'B';\n  l_result PLS_INTEGER;\nBEGIN\n\n  l_result := CASE operand\n                WHEN 'A' THEN 1\n                WHEN 'B' THEN 2\n                WHEN 'C' THEN 3\n                WHEN 'D' THEN 4\n                WHEN 'E' THEN 5\n                WHEN 'F' THEN 6\n                ELSE 7\n              END;\n\n  DBMS_OUTPUT.PUT_LINE('l_result = ' || l_result); -- 2\nEND;\n/\n</pre>","debt":"30min"},{"summary":"\"IF\" statements should not be nested too deeply","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Nested <code>IF</code> statements are a key ingredient for making what's known as \"Spaghetti code\".</p>\n<p>Such code is hard to read, refactor and therefore maintain.</p>","debt":"30min"},{"summary":"Types should follow a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that type names match the provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>[a-zA-Z]([a-zA-Z0-9_]*[a-zA-Z0-9])?</code>:</p>\n<pre>\nDECLARE\n  TYPE Collection-type_ IS VARRAY(42) OF PLS_INTEGER; -- Noncompliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  TYPE collectionType IS VARRAY(42) OF PLS_INTEGER;\nBEGIN\n  NULL;\nEND;\n/ {code}\n</pre>","debt":"30min"},{"summary":"Size should be specified for string variables","type":"Bug","defaultSeverity":"Blocker","description":"<p>String data types, such as <code>VARCHAR2</code> or <code>NVARCHAR2</code> require a size constraint. Omitting the size results in the exception\n<code>PLS-00215: String length constraints must be in range (1 .. 32767)</code> being raised.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  foo VARCHAR2; -- Noncompliant - raises PLS-00215\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  foo VARCHAR2(42); -- Compliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"20min"},{"summary":"Procedures should have parameters","type":"Code Smell","defaultSeverity":"Major","description":"<p>Procedures which don't accept parameters are likely to either not be reused that often or to depend on global variables instead. Refactoring those\nprocedures to take parameters will make them both more flexible and reusable.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  name VARCHAR2(42) := 'John';\n\n  PROCEDURE print_name; -- Noncompliant\n\n  PROCEDURE print_name AS -- Noncompliant\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('Name: ' || name);\n  END;\n\nBEGIN\n  print_name;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  PROCEDURE print_name(name VARCHAR2) AS -- Compliant\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('Name: ' || name);\n  END;\nBEGIN\n  print_name('John');\nEND;\n/\n</pre>","debt":"1h"},{"summary":"Column names should be used in a SQL \"ORDER BY\" clause","type":"Code Smell","defaultSeverity":"Major","description":"<p>Even though the <code>ORDER BY</code> clause supports using column numbers, doing so makes the code difficult to read and maintain. Therefore the\nuse of column names is preferred.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  SELECT col2, col3\n  BULK COLLECT INTO result\n  FROM my_table\n  ORDER BY\n    1 ASC;           -- Noncompliant - if col1 is added to the selected fields, this may break\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  SELECT col2, col3\n  BULK COLLECT INTO result\n  FROM my_table\n  ORDER BY\n    col2 ASC;\nEND;\n/\n</pre>","debt":"10min"},{"summary":"Collections should not be iterated in \"FOR\" loops","type":"Bug","defaultSeverity":"Critical","description":"<p>The <code>FOR</code> loop at first seems like a convenient way of iterating over the elements of a collection, but doing so will raise a\n<code>VALUE_ERROR</code> exception if the collection is empty. Looping instead from 1 to <code>COUNT</code> doesn't work either if the collection is\nsparse; that leads to a <code>ORA-01403: no data found</code> error. </p>\n<p>Instead, a <code>WHILE</code> loop should be used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  TYPE fooType IS TABLE OF VARCHAR2(42);\n  foo fooType := new fooType('Strawberry', 'Apple', 'Banana');\nBEGIN\n  foo.DELETE(2);                                -- The collection is now sparse\n\n  FOR i IN 1 .. foo.COUNT                       -- Noncompliant - leads to ORA-01403: no data found\n  LOOP\n    DBMS_OUTPUT.PUT_LINE(i || ' = ' || foo(i));\n  END LOOP;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  TYPE fooType IS TABLE OF VARCHAR2(42);\n  foo fooType := new fooType('Strawberry', 'Apple', 'Banana');\n  i PLS_INTEGER;\nBEGIN\n  foo.DELETE(2);                                -- The collection is now sparse\n\n  i := foo.FIRST;\n\n  WHILE (i IS NOT NULL)                         -- Compliant - works as expected\n  LOOP\n    DBMS_OUTPUT.PUT_LINE(i || ' = ' || foo(i));\n    i := foo.NEXT(i);\n  END LOOP;\nEND;\n/\n</pre>","debt":"1h"},{"summary":"Nested blocks should be labeled","type":"Code Smell","defaultSeverity":"Major","description":"<p>Labeled blocks are useful, especially when the code is badly indented, to help maintainers match the beginning and ending of each block. When\nblocks are nested, labeling them can improve the code's readability. This rule detects nested block which do not have a start label.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN -- Compliant, this is not a nested block\n  NULL;\nEND;\n/\n\nBEGIN\n  BEGIN -- Noncompliant; this nested block has no label\n    NULL;\n  END;\nEND;\n/\n\nBEGIN\n  BEGIN -- Noncompliant; this nested block has only an end label\n    NULL;\n  END myBlockLabel1;\n\n  &lt;&lt;myBlockLabel2&gt;&gt; -- Compliant\n  BEGIN\n    NULL;\n  END;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  NULL;\nEND;\n/\n\nBEGIN\n  BEGIN myBlockLabel0\n    NULL;\n  END myBlockLabel0;\nEND;\n/\n\nBEGIN\n  BEGIN myBlockLabel1\n    NULL;\n  END myBlockLabel1;\n\n  &lt;&lt;myBlockLabel2&gt;&gt;\n  BEGIN\n    NULL;\n  END;\nEND;\n/\n</pre>","debt":"10min"},{"summary":"Files should not be too complex","type":"Code Smell","defaultSeverity":"Major","description":"<p>Most of the time, a very complex file breaks the Single Responsibility Principle and should be re-factored into several different files.</p>\n<h2>Deprecated</h2>\n<p>This rule is deprecated, and will eventually be removed.</p>","debt":"30min"},{"summary":"\"FUNCTIONS\" should not have \"OUT\" parameters","type":"Code Smell","defaultSeverity":"Major","description":"<p>Functions with <code>OUT</code> parameters are complex to understand. Indeed, it is impossible to tell, just by looking at the function call,\nwhether an argument is a input or output. Moreover, functions with <code>OUT</code> parameters cannot be called from SQL. It is better to either break\nsuch functions up into smaller ones, which each return a single value, or to return several values at once, by combining them in a collection, record,\ntype, or table row.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE employee(\n  firstName VARCHAR2(42),\n  name VARCHAR2(42),\n  phone VARCHAR2(42)\n);\n\nINSERT INTO employee VALUES ('John', 'Smith', '+1');\n\nDECLARE\n  firstName VARCHAR2(42);\n  name VARCHAR2(42);\n  phone VARCHAR2(42);\n\n  -- This DOES NOT return the employee name\n  FUNCTION getEmployeeInfos(firstName OUT VARCHAR2, phone OUT VARCHAR2) RETURN VARCHAR2 AS -- Non-Compliant, confusing\n    name VARCHAR2(42);\n  BEGIN\n    SELECT firstName, name, phone INTO firstName, name, phone FROM employee;\n    RETURN name;\n  END;\nBEGIN\n  name := getEmployeeInfos(firstName, phone);\n\n  DBMS_OUTPUT.PUT_LINE('firstName: ' || firstName);\n  DBMS_OUTPUT.PUT_LINE('name: ' || name);\n  DBMS_OUTPUT.PUT_LINE('phone: ' || phone);\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE employee(\n  firstName VARCHAR2(42),\n  name VARCHAR2(42),\n  phone VARCHAR2(42)\n);\n\nINSERT INTO employee VALUES ('John', 'Smith', '+1');\n\nDECLARE\n  emp employee%ROWTYPE;\n\n  FUNCTION getEmployeeInfos RETURN employee%ROWTYPE AS -- Compliant\n    emp employee%ROWTYPE;\n  BEGIN\n    SELECT * INTO emp FROM employee;\n    RETURN emp;\n  END;\nBEGIN\n  emp := getEmployeeInfos;\n\n  DBMS_OUTPUT.PUT_LINE('firstName: ' || emp.firstName);\n  DBMS_OUTPUT.PUT_LINE('name: ' || emp.name);\n  DBMS_OUTPUT.PUT_LINE('phone: ' || emp.phone);\nEND;\n/\n\nDROP TABLE employee;\n</pre>","debt":"1h"},{"summary":"\"GROUP BY\" should not be used in SQL \"SELECT\" statements","type":"Code Smell","defaultSeverity":"Major","description":"<p>Using <code>GROUP BY</code> in SQL <code>SELECT</code> statements should be avoided because it makes queries complex. Complex queries are generally\nnot performant and are difficult to understand and therefore to maintain.</p>","debt":"1h"},{"summary":"Positional and named arguments should not be mixed in invocations","type":"Bug","defaultSeverity":"Critical","description":"<p>For better readability, and to prevent the <code>PLS-00312: a positional parameter association may not follow a named association</code> exception\nfrom being raised, do not mix named and positional argument invocations.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  PROCEDURE sub(op1 PLS_INTEGER, op2 PLS_INTEGER) AS\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('Sub = ' || (op1 - op2));\n  END;\nBEGIN\n\n  sub(10, op2 =&gt; 2); -- Noncompliant\n  sub(op1 =&gt; 10, 2); -- Noncompliant - raises PLS-00312: a positional parameter association may not follow a named association\n\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  PROCEDURE sub(op1 PLS_INTEGER, op2 PLS_INTEGER) AS\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('Sub = ' || (op1 - op2));\n  END;\nBEGIN\n\n  sub(10, 2); -- Compliant\n  sub(op1 =&gt; 10, op2 =&gt; 2); -- Compliant\n\nEND;\n/\n</pre>","debt":"20min"},{"summary":"\"NATURAL JOIN\" queries should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>NATURAL JOIN</code> is a type of equi-join which implicitly compares all identically-named columns of the two tables. While this a feature\nwhich may seem convenient at first, it becomes hard to maintain over time.</p>\n<p>Consider an EMPLOYEE table with the columns FULL_NAME, and DEPT_ID, and a DEPARTMENT table with the columns DEPT_ID, and NAME. A natural join\nbetween those tables will join on the DEPT_ID column, which is the only identically-named column.</p>\n<p>But, if a new NAME column is later added to the EMPLOYEE table, then the join will be done on both DEPT_ID and NAME. Natural joins make simple\nchanges such as adding a column complicated and are therefore better avoided.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  SELECT *\n  INTO employeeArray\n  FROM employee\n  NATURAL JOIN departement; -- Non-Compliant, the join predicate is implicit\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  SELECT *\n  INTO employeeArray\n  FROM employee\n  JOIN departement\n  USING (dept_id);  -- Compliant, explicit join predicate\nEND;\n/\n</pre>","debt":"15min"},{"summary":"Jump statements should not be used unconditionally","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having an unconditional <code>EXIT</code>, <code>RAISE</code> or <code>GOTO</code> in a loop renders it useless; the loop will only execute once\nand the loop structure itself is simply wasted keystrokes.</p>\n<p>Having an unconditional <code>CONTINUE</code> in a loop can render the loop meaningless, or is itself wasted keystrokes, depending on where in the\nloop it occurs.</p>\n<p>Having an unconditional <code>RETURN</code> anywhere other than at the end of a function or method simply renders all the rest of the code in the\nmethod useless.</p>\n<p>For these reasons, unconditional jump statements should never be used except for the final <code>RETURN</code> in a function or method.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n  LOOP\n    foo := foo + 1;\n    EXIT; -- Noncompliant\n  END LOOP;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n  LOOP\n    foo := foo + 1;\n    IF foo &gt; 10 THEN\n      EXIT;\n    END IF;\n  END LOOP;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.1 - There shall be no unreachable code. </li>\n  <li> MISRA C++:2008, 0-1-1 - A <em>project</em> shall not contain <em>unreachable code</em>. </li>\n  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code. </li>\n  <li> MISRA C:2012, 2.2 - There shall be no dead code </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"5min"},{"summary":"Two branches in a conditional structure should not have exactly the same implementation","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having two branches in an <code>IF</code>/<code>ELSIF</code> chain with the same implementation is at best duplicate code, and at worst a coding\nerror.</p>\n<p>If the same logic is truly needed for both instances, then in an <code>IF</code> chain they should be combined.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nIF sort_order = 1 THEN\n    SELECT LastName, FirstName\n      FROM Employees\n      ORDER BY LastName\nELSIF sort_order = 2 THEN\n    SELECT LastName, FirstName\n      FROM Employees\n      ORDER BY LastName -- Noncompliant\nELSE\n    SELECT LastName, FirstName\n      FROM Employees\nEND IF;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nIF sort_order = 1 OR sort_order = 2 THEN\n    SELECT LastName, FirstName\n      FROM Employees\n      ORDER BY LastName\nELSE\n    SELECT LastName, FirstName\n      FROM Employees\nEND IF;\n\n-- ----\n--  OR\n-- ----\n\nIF sort_order = 1 THEN\n    SELECT LastName, FirstName\n      FROM Employees\n      ORDER BY LastName\nELSIF sort_order = 2 THEN\n    SELECT LastName, FirstName\n      FROM Employees\n      ORDER BY FirstName\nELSE\n    SELECT LastName, FirstName\n      FROM Employees\nEND IF;\n</pre>\n<h2>Exceptions</h2>\n<p>Branches in an <code>IF</code>/<code>ELSIF</code> chain with implementation that contains a single line of code are ignored.</p>","debt":"10min"},{"summary":"Sensitive \"SYS\" owned functions should not be used","type":"Vulnerability","defaultSeverity":"Critical","description":"<p>Some Oracle packages contain powerful SYS-owned functions that can be used to perform malicious operations. For instance,\n<code>DBMS_SYS_SQL.PARSE_AS_USER</code> can be used to execute a statement as another user.</p>\n<p>Most programs do not need those functions and this rule helps identify them in order to prevent security risks.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  c INTEGER;\n  sqltext VARCHAR2(100) := 'ALTER USER system IDENTIFIED BY hacker'; -- Might be injected by the user\nBEGIN\n  c := SYS.DBMS_SYS_SQL.OPEN_CURSOR();                               -- Noncompliant\n\n   -- Will change 'system' user's password to 'hacker'\n  SYS.DBMS_SYS_SQL.PARSE_AS_USER(c, sqltext, DBMS_SQL.NATIVE, UID);  -- Non-Compliant\n\n  SYS.DBMS_SYS_SQL.CLOSE_CURSOR(c);                                  -- Noncompliant\nEND;\n/\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://cwe.mitre.org/data/definitions/269.html\">MITRE, CWE-269</a> - Improper Privilege Management </li>\n  <li> <a href=\"https://cwe.mitre.org/data/definitions/270.html\">MITRE, CWE-270</a> - Privilege Context Switching Error </li>\n</ul>","debt":"2h"},{"summary":"Redundant pairs of parentheses should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>The use of parentheses, even those not required to enforce a desired order of operations, can clarify the intent behind a piece of code. But\nredundant pairs of parentheses could be misleading, and should be removed. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nx := (y / 2 + 1); -- Compliant even if the parentheses are ignored\nIF (x &gt; 0) AND ((x+y &gt; 0)) THEN -- Noncompliant\n  -- ...\nEND IF;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nx := (y / 2 + 1);\nIF (x &gt; 0) AND (x+y &gt; 0) THEN\n  -- ...\nEND IF;\n</pre>","debt":"1min"},{"summary":"Single line comments should start with \"--\"","type":"Code Smell","defaultSeverity":"Minor","description":"<p>The multi-line comment syntax <code>/* ... */</code> should not be used for single line comments; the <code>--</code> syntax is more\nappropriate.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n/*\n These comment lines are Compliant\n comment 1\n comment 2\n*/\n\n/*\n This comment is also Compliant\n */\n\n/* This comment is Noncompliant */\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n/*\n These comment lines are Compliant\n comment 1\n comment 2\n*/\n\n/*\n This comment is also Compliant\n */\n\n-- This comment is compliant\n</pre>","debt":"1min"},{"summary":"Pipelined functions should have at least one \"PIPE ROW\" statement and not return an expression (PLS-00633)","type":"Bug","defaultSeverity":"Blocker","description":"<p>Pipelined functions offers the ability to create programmatically generated tables.</p>\n<p>One of the benefits of such functions is that they reduce memory consumption as results are not all kept in memory before being returned.</p>\n<p>Instead of relying on <code>RETURN</code>, <code>PIPE ROW</code> must be used to return the results, one row at a time.</p>\n<p>Trying to return an expression from a pipelined function raises <code>PLS-00633: RETURN statement in a pipelined function cannot contain an\nexpression</code></p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nCREATE OR REPLACE TYPE myScalarType AS OBJECT\n(\n  dummy   VARCHAR2(42)\n)\n/\nCREATE OR REPLACE TYPE myTableType AS TABLE OF myScalarType;\n/\n\nCREATE OR REPLACE FUNCTION foo RETURN myTableType PIPELINED AS  -- Noncompliant, should contain at least one PIPE ROW\n  result myTableType := myTableType();\nBEGIN\n  FOR i IN 1 .. 3 LOOP\n    result.EXTEND;\n    result(i) := myScalarType('Dummy ' || i);\n  END LOOP;\n\n  RETURN result;  -- Noncompliant, will raise PLS-00633\nEND;\n/\n\nSELECT * FROM TABLE(foo());\n\nDROP FUNCTION foo;\nDROP TYPE myTableType;\nDROP TYPE myScalarType;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n-- ...\n\nCREATE OR REPLACE FUNCTION foo RETURN myTableType PIPELINED AS\nBEGIN\n  FOR i IN 1 .. 3 LOOP\n    PIPE ROW(myScalarType('Dummy ' || i));\n  END LOOP;\n\n  RETURN;\nEND;\n/\n\n-- ...\n</pre>","debt":"30min"},{"summary":"Object attributes should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that object attribute names match the provided regular\nexpression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>[a-zA-Z](_?+[a-zA-Z0-9])*+</code> :</p>\n<pre>\nCREATE TYPE my_type AS OBJECT(\n  foo__bar INTEGER             -- Non-Compliant\n);\n/\n\nDROP TYPE my_type;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nCREATE TYPE my_type AS OBJECT(\n  foo_bar INTEGER              -- Compliant\n);\n/\n\nDROP TYPE my_type;\n</pre>","debt":"30min"},{"summary":"Newline and control characters should not be used in string literals","type":"Code Smell","defaultSeverity":"Major","description":"<p>New lines and control characters can be injected in the source code by bad manipulations. Control characters aren't visible to maintainers, so\nwhether or not they are actually wanted should be double-checked. Note that this rule can optionally also report violations on literals containing the\ntabulation character.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nBEGIN\n  /* Non-Compliant */ DBMS_OUTPUT.PUT_LINE('Hello\nworld!');\n\n  DBMS_OUTPUT.PUT_LINE('Hello'); -- Compliant, this is preferred\n  DBMS_OUTPUT.PUT_LINE('world!');\nEND;\n/\n</pre>","debt":"10min"},{"summary":"\"GOTO\" statements should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>A <code>GOTO</code> statement is an unstructured change in the control flow. They should be avoided and replaced by structured constructs.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  i PLS_INTEGER := 42;\nBEGIN\n  IF i &lt; 0 THEN\n    GOTO negative; -- Noncompliant\n  END IF;\n\n  DBMS_OUTPUT.PUT_LINE('positive');\n  goto cleanup; -- Noncompliant\n\n  &lt;&lt;negative&gt;&gt;\n  DBMS_OUTPUT.PUT_LINE('negative!');\n\n  &lt;&lt;cleanup&gt;&gt;\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  i PLS_INTEGER := 42;\nBEGIN\n  IF i &lt; 0 THEN\n    DBMS_OUTPUT.PUT_LINE('negative!'); -- Compliant\n  ELSE\n    DBMS_OUTPUT.PUT_LINE('positive');\n  END IF;\nEND;\n/\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.4 - The goto statement shall not be used. </li>\n  <li> MISRA C:2012, 15.1 - The goto statement should not be used </li>\n</ul>","debt":"2h"},{"summary":"\"END\" statements of labeled blocks should be labeled","type":"Code Smell","defaultSeverity":"Major","description":"<p>Labeled blocks are useful, especially when the code is badly indented, to match the begin and end of each block. This check detects labeled blocks\nwhich are missing an ending label.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n&lt;&lt;myBlockLabel1&gt;&gt;\nBEGIN\n  NULL;\nEND; -- Noncompliant; this labeled loop has no ending label\n/\n\nBEGIN\n  NULL; -- Compliant; not a labeled block\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n&lt;&lt;myBlockLabel2&gt;&gt;\nBEGIN\n  NULL;\nEND myBlockLabel2;\n/\n\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"5min"},{"summary":"Block labels should appear on the same lines as \"END\"","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Labeled blocks are useful to help maintainers match-up the beginning and ending of each section of code, especially when that code is badly\nindented. However, if used, those labels must appear on the same line as the \"END\" keyword in order to avoid confusion. Otherwise, the label might be\nmisread by maintainers as a procedure call.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  PROCEDURE foo AS\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('foo was called!');\n  END;\nBEGIN\n  BEGIN\n    NULL;\n  END -- Semicolon was forgotten?\n\n  foo; -- Noncompliant; looks like a procedure call, but is actually END block label\n\n  &lt;&lt;myBlockLabel&gt;&gt;\n  BEGIN\n    NULL;\n  END\n  myBlockLabel; -- Noncompliant\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  PROCEDURE foo AS\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('foo was called!');\n  END;\nBEGIN\n  BEGIN\n    NULL;\n  END;\n\n  foo; -- The method \"foo\" was actually meant to be called\n\n  &lt;&lt;myBlockLabel&gt;&gt;\n  BEGIN\n    NULL;\n  END myBlockLabel;\nEND;\n/\n</pre>","debt":"1min"},{"summary":"\"MLSLABEL\" should not be used","type":"Bug","defaultSeverity":"Major","description":"<p>The deprecated MLSLABEL datatype is still supported only for backwards compatibility with Trusted Oracle, and since Oracle8, the only valid value\nit can hold is NULL. Thus, the usage of this type should be progressively removed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  foo MLSLABEL; -- Noncompliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"30min"},{"summary":"Predefined exceptions should not be overridden","type":"Bug","defaultSeverity":"Blocker","description":"<p>Naming custom exceptions the same as predefined ones, while technically acceptable, is not a good practice.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  no_data_found EXCEPTION; -- Noncompliant, overrides an Oracle predefined exception\n\n  d VARCHAR2(1);\nBEGIN\n  SELECT dummy INTO d FROM DUAL WHERE dummy = 'Y'; -- Will raise STANDARD.NO_DATA_FOUND\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    DBMS_OUTPUT.PUT_LINE('No data found!'); -- Won't be executed, as NO_DATA_FOUND was overriden, confusing!\n  WHEN OTHERS THEN\n    DBMS_OUTPUT.PUT_LINE('Unknown error!'); -- *Will* be executed\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  my_own_exception EXCEPTION; -- Compliant\n\n  d VARCHAR2(1);\nBEGIN\n  SELECT dummy INTO d FROM DUAL WHERE dummy = 'Y';\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    DBMS_OUTPUT.PUT_LINE('No data found!'); -- *Will* be executed\n  WHEN OTHERS THEN\n    DBMS_OUTPUT.PUT_LINE('Unknown error!');\nEND;\n/\n</pre>","debt":"1h"},{"summary":"\"CASE\" structures should not have too many \"WHEN\" clauses","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>CASE</code> structures with a large set of <code>WHEN</code> clauses are difficult to understand and maintain, and should be refactored to\ninclude fewer <code>WHEN</code> clauses.</p>","debt":"2h"},{"summary":"Track comments matching a regular expression","type":"Code Smell","defaultSeverity":"Major","description":"<p>This rule template can be used to create rules which will be triggered when a comment matches a given regular expression.</p>\n<p>For example, one can create a rule with the regular expression <code>.*REVIEW.*</code> to match all comment containing \"REVIEW\".</p>\n<p>Note that, in order to match REVIEW regardless of the case, the <code>(?i)</code> modifier should be prepended to the expression, as in\n<code>(?i).*REVIEW.*</code>.</p>"},{"summary":"GOTO should not be used to jump backwards","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Jumping back to a previous statement using <code>GOTO</code> is a way to reimplement loops, which PL/SQL already provides in much more readable\nforms.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  result PLS_INTEGER := 0;\n  counter PLS_INTEGER := 1;\nBEGIN\n  &lt;&lt;loop&gt;&gt;\n  result := result + counter;\n  counter := counter + 1;\n\n  IF counter &lt;= 9 THEN\n    GOTO loop;                    -- Noncompliant\n  END IF;\n\n  DBMS_OUTPUT.PUT_LINE('Sum from 1 to 9 is ' || result); -- Displays 1 + 2 + ... + 8 + 9 = 45\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  result PLS_INTEGER := 0;\nBEGIN\n  FOR counter IN 1 .. 9 LOOP\n    result := result + counter;\n  END LOOP;\n\n  DBMS_OUTPUT.PUT_LINE('Sum from 1 to 9 is ' || result); -- Displays 1 + 2 + ... + 8 + 9 = 45\nEND;\n/\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 6-6-2 - The goto statement shall jump to a label declared later in the same function body </li>\n  <li> MISRA C:2012, 15.2 - The goto statement shall jump to a label declared later in the same function </li>\n</ul>","debt":"1h"},{"summary":"Parameter \"IN\" mode should be specified explicitly","type":"Code Smell","defaultSeverity":"Minor","description":"<p>By default, the parameter mode is <code>IN</code>. However, specifying it explicitly makes the code easier to read.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  PROCEDURE printName(name VARCHAR2) AS -- Noncompliant; relies on default mode\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('name: ' || name);\n  END;\n\nBEGIN\n  printName('Foo');\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  PROCEDURE printName(name IN VARCHAR2) AS\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('name: ' || name);\n  END;\nBEGIN\n  printName('Foo');\nEND;\n/\n</pre>","debt":"10min"},{"summary":"Functions and procedures should not have too many parameters","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having functions and procedures which take too many parameters decreases the code's readability and usability. It is likely that such a\nfunction/procedure is not modular enough, and should be split into several smaller ones.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold of 10:</p>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE FUNCTION sumWithTooManyParameters( -- Noncompliant, too many parameters\n  a1 PLS_INTEGER,\n  a2 PLS_INTEGER,\n  a3 PLS_INTEGER,\n  a4 PLS_INTEGER,\n  a5 PLS_INTEGER,\n  a6 PLS_INTEGER,\n  a7 PLS_INTEGER,\n  a8 PLS_INTEGER,\n  a9 PLS_INTEGER,\n  a10 PLS_INTEGER,\n  a11 PLS_INTEGER\n  )\n  RETURN PLS_INTEGER AS\nBEGIN\n  RETURN a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11;\nEND;\n/\n\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('Sum is ' || sumWithTooManyParameters(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11));\nEND;\n/\n\nDROP FUNCTION sumWithTooManyParameters;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE FUNCTION sumCorrected(n PLS_INTEGER) RETURN PLS_INTEGER AS -- Compliant\nBEGIN\n  RETURN (1 + n)*(n / 2);\nEND;\n/\n\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('Sum is ' || sumCorrected(11));\nEND;\n/\n\nDROP FUNCTION sumCorrected;\n</pre>\n<pre>\n</pre>","debt":"2h"},{"summary":"Comments should not be nested","type":"Code Smell","defaultSeverity":"Minor","description":"<p>PL/SQL does not support nested C-style (<code>/* ... */</code>) comments.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n/*\n  This is a comment block, for which the ending tag was omitted\n  It may be difficult to figure out that the following line of code is actually commented\n\n\nvariable = function_call();\n/* variable contains the result, this is not allowed, as it is an attempt to create an inner comment */\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 2.3 - The character sequence /* shall not be used within a comment. </li>\n  <li> MISRA C++:2008, 2-7-1 - The character sequence /* shall not be used within a C-style comment. </li>\n  <li> MISRA C:2012, 3.1 - The character sequences /* and // shall not be used within a comment </li>\n</ul>","debt":"10min"},{"summary":"Constraints should not be applied to types that cannot be constrained","type":"Bug","defaultSeverity":"Blocker","description":"<p>Some types cannot be constrained, and attempting to do so results in the exception <code>PLS-00566: type name \"...\" cannot be constrained</code>\nbeing raised.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  foo BLOB(42); -- Noncompliant - raises PLS-00566: type name \"BLOB\" cannot be constrained\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  foo BLOB;\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"5min"},{"summary":"String literals should not be duplicated","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Duplicated string literals make the process of refactoring error-prone, since you must be sure to update all occurrences.</p>\n<p>On the other hand, constants can be referenced from many places, but only need to be updated in a single place.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold of 3:</p>\n<pre>\nBEGIN\n  prepare('action1');\n  execute('action1');\n  release('action1');\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  action CONSTANT VARCHAR2(7) := 'action1';\nBEGIN\n  prepare(action);\n  execute(action);\n  release(action);\nEND;\n/\n</pre>\n<h2>Exceptions</h2>\n<p>To prevent generating some false-positives, literals having less than 5 characters are excluded.</p>","debt":"2min"},{"summary":"\"ROWNUM\" should not be used at the same query level as \"ORDER BY\"","type":"Bug","defaultSeverity":"Major","description":"<p>Oracle's <code>ROWNUM</code> is a pseudo column that numbers the rows in a result set. Unfortunately, it numbers the rows in the set\n<em>before</em> ordering is applied. So combining the two in the same query won't get you the results you expect. Instead, you should move your\nselection and ordering into a subquery, and use <code>ROWNUM</code> only on the outer query.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSELECT fname, lname, deptId\nFROM employee\nWHERE rownum &lt;= 10\nORDER BY salary  -- Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSELECT *\nFROM ( SELECT fname, lname, deptId\n    FROM employee\n    ORDER BY salary\n  )\nWHERE rownum &lt;= 10\n</pre>","debt":"10min"},{"summary":"\"LOOP ... END LOOP;\" constructs should be avoided","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Simple loops, of the form <code>LOOP ... END LOOP</code>, behave by default as infinite ones, since they do not have a loop condition. They can\noften be replaced by other, safer, loop constructs.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  i PLS_INTEGER;\nBEGIN\n  i := 1;\n  LOOP -- Noncompliant, an infinite loop by default and therefore dangerous\n    DBMS_OUTPUT.PUT_LINE('First loop i: ' || i);\n\n    i := i + 1;\n    EXIT WHEN i &gt; 10;\n  END LOOP;\n\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  i PLS_INTEGER;\nBEGIN\n  FOR i IN 1..10 LOOP -- Compliant, much safer equivalent alternative\n    DBMS_OUTPUT.PUT_LINE('Second loop i: ' || i);\n  END LOOP;\nEND;\n/\n</pre>","debt":"1h"},{"summary":"Return of boolean expressions should not be wrapped into an \"if-then-else\" statement","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Return of boolean literal statements wrapped into <code>if-then-else</code> ones should be simplified.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nIF expression THEN\n  RETURN TRUE;\nELSE\n  RETURN FALSE;\nEND IF;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nRETURN expression;\n</pre>","debt":"2min"},{"summary":"Identical expressions should not be used on both sides of a binary operator","type":"Bug","defaultSeverity":"Major","description":"<p>Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste\nerror and therefore a bug, or it is simply wasted code, and should be simplified.</p>\n<p>This rule ignores operators <code>+</code>, <code>*</code> and <code>||</code>, and expressions: <code>1=1</code>, <code>1&lt;&gt;1</code>,\n<code>1!=1</code>, <code>1~=1</code> and <code>1^=1</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSELECT code\n  FROM Person\n  WHERE first_name IS NULL OR first_name IS NULL; -- Noncompliant\n\nSELECT * FROM Users\n  INNER JOIN Clients ON Clients.id = Clients.id; -- Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSELECT code\n  FROM Person\n  WHERE first_name IS NULL OR last_name IS NULL;\n\nSELECT * FROM Users\n  INNER JOIN Clients ON Clients.id = Users.id;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n  <li> <a href='/coding_rules#rule_key=plsql%3AS1656'>S1656</a> - Implements a check on <code>=</code>. </li>\n</ul>","debt":"2min"},{"summary":"Labels should not be reused in inner scopes","type":"Code Smell","defaultSeverity":"Major","description":"<p>Using the same name for multiple purposes reduces the understandability of the code and might eventually lead to bugs.</p>\n<p>This rule verifies that no label is reused in an inner scope.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n&lt;&lt;foo&gt;&gt;\nDECLARE\n  a CONSTANT PLS_INTEGER := 0;\nBEGIN\n  &lt;&lt;foo&gt;&gt;                                  -- Noncompliant\n  DECLARE\n    b CONSTANT PLS_INTEGER := 42;\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('x = ' || foo.b); -- Confusing\n  END;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n&lt;&lt;foo&gt;&gt;\nDECLARE\n  a CONSTANT PLS_INTEGER := 0;\nBEGIN\n  &lt;&lt;bar&gt;&gt;\n  DECLARE\n    b CONSTANT PLS_INTEGER := 42;\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('x = ' || bar.b);\n  END;\nEND;\n/\n</pre>","debt":"1h"},{"summary":"\"cursor%NOTFOUND\" should be used instead of \"NOT cursor%FOUND\"","type":"Code Smell","defaultSeverity":"Minor","description":"<p><code>cursor%NOTFOUND</code> is clearer and more readable than <code>NOT cursor%FOUND</code>, and is preferred.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  CURSOR c IS SELECT DUMMY FROM DUAL;\n  x VARCHAR2(1);\nBEGIN\n  OPEN c;\n  FETCH c INTO x;\n  IF NOT c%FOUND THEN  -- Noncompliant\n    DBMS_OUTPUT.PUT_LINE('uh?');\n  ELSE\n    DBMS_OUTPUT.PUT_LINE('all good: ' || x);\n  END IF;\n  CLOSE c;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  CURSOR c IS SELECT DUMMY FROM DUAL;\n  x VARCHAR2(1);\nBEGIN\n  OPEN c;\n  FETCH c INTO x;\n  IF c%NOTFOUND THEN\n    DBMS_OUTPUT.PUT_LINE('uh?');\n  ELSE\n    DBMS_OUTPUT.PUT_LINE('all good: ' || x);\n  END IF;\n  CLOSE c;\nEND;\n/\n</pre>","debt":"1min"},{"summary":"\"NUMBER\" variables should be declared with precision","type":"Code Smell","defaultSeverity":"Major","description":"<p>Declaring a <code>NUMBER</code> variable without any precision wastes memory because Oracle supports up to 38 decimal digits by default (or the\nmaximum supported by your system, whichever is less). If you don't need that large a value, you should specify whatever matches your needs. This will\nsave memory and provide extra integrity checking on input.</p>\n<p>This rule also applies to some <code>NUMBER</code> subtypes as well: <code>NUMERIC</code>, <code>DEC</code>, and <code>DECIMAL</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  var1 NUMBER; -- Noncompliant\n  var2 NUMERIC; -- Noncompliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  var1 NUMBER(9,2);\n  var2 NUMERIC(4,0);\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"15min"},{"summary":"Compound triggers should define at least two triggers","type":"Code Smell","defaultSeverity":"Major","description":"<p>Compound triggers were introduced to ease the implementation of multiple triggers which need to work in cooperation.</p>\n<p>Typically, a <code>FOR EACH ROW</code> trigger accumulates facts, and an <code>AFTER STATEMENT</code> trigger performs the actual changes.</p>\n<p>The compound trigger can hold a state common to all the triggers it defines, thereby removing the need to use package variables. This approach is\nsometimes the only possible one, as when avoiding a mutating table <code>ORA-04091</code> error, or it can be used to get better performance.</p>\n<p>However, there is no point in defining a compound trigger which contains only a single trigger, since there is no state to be shared. In such\ncases, a simple trigger should be used instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nCREATE OR REPLACE TRIGGER my_trigger  -- Noncompliant; defines a single trigger\nFOR INSERT ON my_table\nCOMPOUND TRIGGER\n\nAFTER EACH ROW IS\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('New row inserted!');\nEND AFTER EACH ROW;\n\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nCREATE OR REPLACE TRIGGER my_trigger\n  AFTER INSERT\n  ON my_table\n  FOR EACH ROW\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('New row inserted!');\nEND;\n/\n</pre>","debt":"30min"},{"summary":"Track parsing failures","type":"Code Smell","defaultSeverity":"Major","description":"<p>When the PL/SQL parser fails, it is possible to record the failure as an issue on the file. This way, not only it is possible to track the number\nof files that do not parse but also to easily find out why they do not parse.</p>","debt":"30min"},{"summary":"Loop start and end labels should match","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Labeled loops are useful, especially when the code is badly indented, to match the begin and end of each loop. This rule verifies that loop start\nand end labels match, when both are specified.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  LOOP\n    EXIT;\n  END LOOP; -- Compliant, this loop has no label at all\n\n  &lt;&lt;myLoopLabel1&gt;&gt;\n  LOOP\n    EXIT;\n  END LOOP; -- Compliant, this loop only has a start label\n\n  LOOP\n    EXIT;\n  END LOOP myLoopLabel2; -- Compliant, this loop only has an end label\n\n  &lt;&lt;myLoopLabel4&gt;&gt;\n  LOOP\n    EXIT;\n  END LOOP myLoopLabel5; -- Noncompliant, label mismatch\n\n  &lt;&lt;myLoopLabel6&gt;&gt;\n  &lt;&lt;myLoopLabel7&gt;&gt;\n  LOOP\n    EXIT;\n  END LOOP myLoopLabel7; -- Noncompliant, several start labels mismatch\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  LOOP\n    EXIT;\n  END LOOP;\n\n  &lt;&lt;myLoopLabel1&gt;&gt;\n  LOOP\n    EXIT;\n  END LOOP;\n\n  LOOP\n    EXIT;\n  END LOOP myLoopLabel2;\n\n  &lt;&lt;myLoopLabel4&gt;&gt;\n  LOOP\n    EXIT;\n  END LOOP myLoopLabel4;\n\n  &lt;&lt;myLoopLabel7&gt;&gt;\n  LOOP\n    EXIT;\n  END LOOP myLoopLabel7;\nEND;\n/\n</pre>","debt":"10min"},{"summary":"\"VARCHAR2\" and \"NVARCHAR2\" should be used","type":"Bug","defaultSeverity":"Major","description":"<p>For fixed-length values, a <code>CHAR</code> field occupies the same amount of disk space as a <code>VARCHAR2</code> field, but for variable-length\nvalues <code>CHAR</code> fields use more storage space and make searching more difficult by right-padding values with whitespaces. Therefore\n<code>VARCHAR2</code> fields are preferred. Similarly, <code>NCHAR</code> should be replaced by <code>NVARCHAR2</code>.</p>\n<p>Note that for 1-character fields, <code>CHAR</code> is naturally equivalent to <code>VARCHAR2</code>, but the latter is still preferred for\nconsistency.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  var1 CHAR; -- Noncompliant\n\n  var2 CHAR(42); -- Noncompliant\n\n  var3 NCHAR; -- Noncompliant\n\n  var4 NCHAR(42); -- Noncompliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>DECLARE\n  var1 VARCHAR2(42);\n\n  var2 VARCHAR2(42);\n\n  var3 NVARCHAR2(42);\n\n  var4 NVARCHAR2(42);\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"1h"},{"summary":"Columns to be read with a \"SELECT\" statement should be clearly defined","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>SELECT *</code> should be avoided because it releases control of the returned columns and could therefore lead to errors and potentially to\nperformance issues.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  myvar CHAR;\nBEGIN\n  SELECT * INTO myvar FROM DUAL; -- Noncompliant\n END;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  myvar CHAR;\nBEGIN\n  SELECT dummy INTO myvar FROM DUAL;\nEND;\n/\n</pre>\n<h2>Exceptions</h2>\n<p>Wrapper queries using <code>ROWNUM</code> are ignored.</p>\n<pre>\nSELECT *\nFROM ( SELECT fname, lname, deptId\n    FROM employee\n    ORDERBY salary\n  )\nWHERE rownum &lt;= 10\n</pre>","debt":"1h"},{"summary":"Reserved words should be written in upper case","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that reserved words are written in upper case.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  null; -- Noncompliant\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"2min"},{"summary":"Exceptions should not be ignored","type":"Code Smell","defaultSeverity":"Minor","description":"<p>When exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  d VARCHAR2(1);\nBEGIN\n  SELECT dummy INTO d FROM DUAL WHERE dummy = 'Y'; -- Will raise NO_DATA_FOUND\n  DBMS_OUTPUT.PUT_LINE('d = ' || d);\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN -- Noncompliant, did we really want to mask this exception?\n    NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  d VARCHAR2(1);\nBEGIN\n  SELECT dummy INTO d FROM DUAL WHERE dummy = 'Y'; -- Will raise NO_DATA_FOUND\n  DBMS_OUTPUT.PUT_LINE('d = ' || d);\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    DBMS_OUTPUT.PUT_LINE('Error: No data found');\nEND;\n/\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/391.html\">MITRE, CWE-391</a> - Unchecked Error Condition </li>\n</ul>","debt":"1h"},{"summary":"CASE should be used for sequences of simple tests","type":"Code Smell","defaultSeverity":"Minor","description":"<p>When a single primitive is tested against three or more values in an <code>IF</code>, <code>ELSIF</code> chain, it should be converted to a\n<code>CASE</code> instead for greater readability.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  x PLS_INTEGER := 0;\nBEGIN\n  IF x = 0 THEN                     -- Noncompliant\n    DBMS_OUTPUT.PUT_LINE('x = 0');\n  ELSIF x = 1 THEN\n    DBMS_OUTPUT.PUT_LINE('x = 1');\n  ELSE\n    DBMS_OUTPUT.PUT_LINE('x &gt; 1');\n  END IF;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  x PLS_INTEGER := 0;\nBEGIN\n  CASE x\n    WHEN 0 THEN\n      DBMS_OUTPUT.PUT_LINE('x = 0');\n    WHEN 1 THEN\n      DBMS_OUTPUT.PUT_LINE('x = 1');\n    ELSE\n      DBMS_OUTPUT.PUT_LINE('x &gt; 1');\n  END CASE;\nEND;\n/\n</pre>","debt":"5min"},{"summary":"\"UNION\" should not be used in \"SELECT\" statements","type":"Code Smell","defaultSeverity":"Major","description":"<p>Using <code>UNION</code> in SQL <code>SELECT</code> statements should be avoided because it makes queries complex. Complex queries are generally\nnot performant and are difficult to understand and therefore to maintain.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSELECT DUMMY FROM DUAL\nUNION                           -- Noncompliant\nSELECT DUMMY FROM DUAL@dblink;\n</pre>","debt":"1h"},{"summary":"Unused local variables should be removed","type":"Code Smell","defaultSeverity":"Minor","description":"<p>If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will\nnot wonder what the variable is used for.</p>","debt":"5min"},{"summary":"Tables should be aliased","type":"Code Smell","defaultSeverity":"Major","description":"<p>When multiple tables are involved in a query, using table aliases helps to make it more understandable and keeps it short. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  SELECT\n    name,\n    firstname,\n    location\n  INTO employeesArray\n  FROM employee -- Noncompliant - should be aliased\n  INNER JOIN department -- Noncompliant - should be aliased\n  ON employee.DepartmentID = department.ID;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  SELECT\n    empl.name,\n    empl.firstname,\n    dpt.location\n  INTO employeesArray\n  FROM employee empl\n  INNER JOIN department dpt\n  ON empl.DepartmentID = dpt.ID;\nEND;\n/\n</pre>","debt":"30min"},{"summary":"Statements should be on separate lines","type":"Code Smell","defaultSeverity":"Major","description":"<p>For better readability, do not put more than one statement on a single line.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('Hello!'); DBMS_OUTPUT.PUT_LINE('This is unreadable!'); -- Noncompliant\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('Hello!');\n  DBMS_OUTPUT.PUT_LINE('This is much better!');\nEND;\n/\n</pre>","debt":"1min"},{"summary":"Variables should not be shadowed","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Overriding a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of code.\nFurther, it could lead maintainers to introduce bugs because they think they're using one variable but are really using another.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  foo VARCHAR2(42) := 'foo';\nBEGIN\n  DECLARE\n    foo VARCHAR2(42) := 'bar'; -- Noncompliant - this variable hides the one above and should be renamed\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE(foo); -- Displays \"bar\", which is confusing\n  END;\n\n  DBMS_OUTPUT.PUT_LINE(foo); -- Displays \"foo\"\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  foo VARCHAR2(42) := 'foo';\nBEGIN\n  DECLARE\n    bar VARCHAR2(42) := 'bar'; -- Compliant\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE(bar); -- Displays \"bar\"\n  END;\n\n  DBMS_OUTPUT.PUT_LINE(foo); -- Displays \"foo\"\nEND;\n/\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 5.2 - Identifiers in an inner scope shall not use the same name as an identifier in an outer scope, and therefore hide that\n  identifier </li>\n  <li> MISRA C++:2008, 2-10-2 - Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope </li>\n  <li> MISRA C:2012, 5.3 - An identifier declared in an inner scope shall not hide an identifier declared in an outer scope </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/VwE\">CERT, DCL01-C.</a> - Do not reuse variable names in subscopes </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/cwAhAQ\">CERT, DCL01-CPP.</a> - Do not reuse variable names in subscopes </li>\n</ul>","debt":"30min"},{"summary":"Variables should not be initialized with \"NULL\"","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Explicit variable initializations with null values are superfluous, since unassigned variables are implicitly initialized to null.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  foo PLS_INTEGER := NULL; -- Noncompliant, the null assignation is superfluous\n  bar VARCHAR2(100) := ''; -- Noncompliant, the null assignation is superfluous\n  correctInitializedString VARCHAR2(100) := 'Hello world!';\n\nBEGIN\n  IF foo IS NULL THEN\n    DBMS_OUTPUT.PUT_LINE('foo is NULL');\n  ELSE\n    DBMS_OUTPUT.PUT_LINE('foo is NOT NULL');\n  END IF;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  foo PLS_INTEGER;\n  bar VARCHAR2(100);\n  correctInitializedString VARCHAR2(100) := 'Hello world!';\n\nBEGIN\n  IF foo IS NULL THEN\n    DBMS_OUTPUT.PUT_LINE('foo is NULL');\n  ELSE\n    DBMS_OUTPUT.PUT_LINE('foo is NOT NULL');\n  END IF;\nEND;\n/\n</pre>","debt":"1min"},{"summary":"Magic literals should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>Literals should not be hard-coded, but externalized instead. Exceptions can be parameterized using the below parameters.</p>","debt":"10min"},{"summary":"\"FULL OUTER JOINS\" should be used with caution","type":"Code Smell","defaultSeverity":"Major","description":"<p>Full outer joins aren't in common use, and as a result many developers don't really understand them. Therefore, each use of this language feature\nshould be reviewed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  SELECT *\n  BULK COLLECT INTO result\n  FROM DUAL d1\n  FULL OUTER JOIN DUAL d2 ON d1.dummy != d2.dummy; -- Noncompliant\nEND;\n/\n</pre>","debt":"30min"},{"summary":"Block start and end labels should match","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Labeled blocks are useful, especially when the code is badly indented, to match the begin and end of each block. This rule verifies that block\nstart and end labels match, when both are specified.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  NULL;\nEND; -- Compliant, no labels at all\n/\n\n&lt;&lt;myBlockLabel1&gt;&gt;\nBEGIN\n  NULL;\nEND; -- Compliant, only starting label\n/\n\nBEGIN\n  NULL;\nEND myBlockLabel2; -- Compliant, only ending label\n/\n\n&lt;&lt;myBlockLabel3&gt;&gt;\nBEGIN\n  NULL;\nEND myBlockLabel4; -- Noncompliant, labels mismatch\n/\n\n&lt;&lt;myBlockLabel6&gt;&gt;\n&lt;&lt;myBlockLabel6&gt;&gt;\nBEGIN\n  NULL;\nEND myBlockLabel6; -- Noncompliant, several starting labels\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  NULL;\nEND;\n/\n\n&lt;&lt;myBlockLabel1&gt;&gt;\nBEGIN\n  NULL;\nEND;\n/\n\nBEGIN\n  NULL;\nEND myBlockLabel2;\n/\n\n&lt;&lt;myBlockLabel3&gt;&gt;\nBEGIN\n  NULL;\nEND myBlockLabel3;\n/\n\n&lt;&lt;myBlockLabel6&gt;&gt;\nBEGIN\n  NULL;\nEND myBlockLabel6;\n/\n</pre>","debt":"10min"},{"summary":"\"DELETE\" and \"UPDATE\" statements should contain \"WHERE\" clauses","type":"Bug","defaultSeverity":"Blocker","description":"<p><code>UPDATE</code> and <code>DELETE</code> statements should contain <code>WHERE</code> clauses to keep the modification of records under control.\nOtherwise unexpected data loss could result.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  maxAge PLS_INTEGER := 60;\nBEGIN\n  UPDATE employee SET status = 'retired'; -- Noncompliant - the WHERE was forgotten\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  maxAge PLS_INTEGER := 60;\nBEGIN\n  UPDATE employee SET status = 'retired' WHERE age &gt; maxAge;\nEND;\n/\n</pre>","debt":"30min"},{"summary":"Columns should be aliased","type":"Code Smell","defaultSeverity":"Major","description":"<p>Consistently using aliases for column names is useful for several reasons. The main one is that the code is independant from potential database\nmodifications - when a column has been renamed to comply with standards for instance. Another reason is to remove ambiguity when querying several\ntables that may have equivalent column names.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  SELECT\n    emp.name, -- Noncompliant - should be aliased\n    dpt.name -- Noncompliant - should be aliased\n  INTO employeesArray\n  FROM employee emp INNER JOIN department dpt\n  ON emp.DepartmentID = dpt.ID;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  SELECT\n    emp.name employee_name, -- Compliant\n    dpt.name departement_name -- Compliant\n  INTO employeesArray\n  FROM employee emp INNER JOIN department dpt\n  ON emp.DepartmentID = dpt.ID;\nEND;\n/\n</pre>","debt":"30min"},{"summary":"\"WHERE\" clause conditions should not be contradictory","type":"Bug","defaultSeverity":"Major","description":"<p>Queries with contradictory <code>WHERE</code> clauses will always return empty result sets. This is clearly a bug.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSELECT *\nFROM fruit\nWHERE type='apple' AND type='orange'  -- Noncompliant\n</pre>","debt":"15min"},{"summary":"\"RETURN\" should not be used from within a loop","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>RETURN</code> should not be used from within a <code>FOR</code> or <code>WHILE</code> loop. Doing so can quickly turn your code into\n\"spaghetti code\". Such code is hard to read, refactor and therefore to maintain.</p>\n<h2>Deprecated</h2>\n<p>This rule is deprecated, and will eventually be removed.</p>","debt":"1h"},{"summary":"Magic numbers should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>A magic number is a number that comes out of nowhere, and is directly used in a statement. Magic numbers are often used, for instance to limit the\nnumber of iterations of a loops, to test the value of a property, etc.</p>\n<p>Using magic numbers may seem obvious and straightforward when you're writing a piece of code, but they are much less obvious and straightforward at\ndebugging time.</p>\n<p>That is why magic numbers must be demystified by first being assigned to clearly named variables before being used.</p>\n<p>By default, -1, 0 and 1 are not considered magic numbers.</p>","debt":"10min"},{"summary":"Explicitly opened cursors should be closed","type":"Bug","defaultSeverity":"Minor","description":"<p>If you do not explicitly close a cursor, it will be closed at the end of the task. But if you try to re-open this cursor to process it, you will\nget an error. That is why a cursor should be explicitly closed after it has been processed.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/459.html\">MITRE, CWE-459</a> - Incomplete Cleanup </li>\n</ul>","debt":"30min"},{"summary":"\"LIKE\" clauses should not start with wildcard characters","type":"Code Smell","defaultSeverity":"Major","description":"<p>When the value of a <code>LIKE</code> clause starts with '%' or '_', indexes on the searched column are ignored, and a full table scan is performed\ninstead. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSELECT FIRST_NAME, LAST_NAME FROM PERSONS\nWHERE LAST_NAME LIKE '%PONT'\n</pre>","debt":"3h"},{"summary":"Functions and procedures should not be too complex","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The cyclomatic complexity of functions and procedures should not exceed a defined threshold.</p>\n<p>Complex code can perform poorly and will in any case be difficult to understand and therefore to maintain.</p>","debt":"10min"},{"summary":"Constraint names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions is a key factory in efficient team collaboration. This rule checks that all constraint names match a provided\nregular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With <code>format_primary_key</code> set to \"pk_[a-z]++ \" and <code>format_foreign_key</code> to \"fk_[a-z]++ \".</p>\n<pre>\nCREATE TABLE employee(\n  first_name VARCHAR2(42),\n  last_name VARCHAR2(42)\n  department_id INTEGER CONSTRAINT department_fk REFERENCES department,\n  CONSTRAINT fullname_pk PRIMARY KEY (first_name, last_name);\n);\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nCREATE TABLE employee(\n  first_name VARCHAR2(42),\n  last_name VARCHAR2(42)\n  department_id INTEGER CONSTRAINT fk_department REFERENCES department,\n  CONSTRAINT pk_fullname PRIMARY KEY (first_name, last_name);\n);\n</pre>","debt":"30min"},{"summary":"A primary key should be specified during table creation","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Tables without primary keys are largely unusable in a relational database because they cannot be joined to. A primary key should be specified at\ntable creation to guarantee that all its records have primary key values.</p>\n<h2>Compliant Solution</h2>\n<pre>\nCREATE TABLE employee\n(\n  employee_id INTEGER PRIMARY KEY,\n  first_name VARCHAR2(42) NOT NULL,\n  last_name VARCHAR2(42) NOT NULL\n);\n</pre>","debt":"10min"},{"summary":"\"RAISE_APPLICATION_ERROR\" should only be used with error codes from -20,000 to -20,999","type":"Bug","defaultSeverity":"Blocker","description":"<p><code>RAISE_APPLICATION_ERROR</code> may only be called with an error code from <del>20,000 to </del>20,999, which is the range reserved for\napplication errors. When called with another value, Oracle raises the exception: <code>ORA-21000: error number argument to raise_application_error of\n0 is out of range.</code></p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  RAISE_APPLICATION_ERROR(0, 'This is an application error'); -- Non-Compliant - raises ORA-21000\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  RAISE_APPLICATION_ERROR(-20000, 'This is an application error'); -- Compliant\nEND;\n/\n</pre>","debt":"1h"},{"summary":"Column aliases should be defined using \"AS\"","type":"Code Smell","defaultSeverity":"Major","description":"<p>For better readability, column aliases should be used with the <code>AS</code> keyword. If it is missing, it could be misread as another column\nbeing selected.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  result DUAL.dummy%TYPE;\nBEGIN\n  SELECT\n    dummy d -- Non-Compliant - could be misread as selecting both \"dummy\" and a column \"d\"\n  INTO\n    result\n  FROM\n    DUAL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  result DUAL.dummy%TYPE;\nBEGIN\n  SELECT\n    dummy AS d -- Compliant\n  INTO\n    result\n  FROM\n    DUAL;\nEND;\n/\n</pre>","debt":"2min"},{"summary":"Exceptions should follow a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Naming conventions allow teams to collaborate effectively. This rule checks that exception names match a given regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>[a-zA-Z]([a-zA-Z0-9_]*[a-zA-Z0-9])?</code>:</p>\n<pre>\nDECLARE\n  my-Exception_ EXCEPTION; -- Noncompliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  myException EXCEPTION;\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"30min"},{"summary":"SQL statements should not join too many tables","type":"Code Smell","defaultSeverity":"Major","description":"<p>When you need access to data from multiple tables, it is more efficient, effective, and understandable to use pre-built views than to select the\ndata from a large number of tables - effectively creating in-memory views - at runtime.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With a maximum number of 3 joined tables:</p>\n<pre>\nSELECT PERSONS.NAME, COUNTRIES.NAME, GENRES.NAME, PROFESSIONS.NAME\nFROM PERSONS\n  INNER JOIN COUNTRIES ON COUNTRIES.ID = PERSON.COUNTRY_ID\n  INNER JOIN GENRES ON GENRES.ID = PERSONS.GENRE_ID\n  INNER JOIN PROFESSIONS ON PROFESSIONS.ID = PERSONS.PROFESSIONS_ID  -- Noncompliant; this is table #4\nWHERE COUNTRIES.CODE = 'US'\n\nSELECT PERSONS.NAME, COUNTRIES.NAME, GENRES.NAME, PROFESSIONS.NAME\nFROM PERSONS, COUNTRIES, GENRES, PROFESSIONS -- Noncompliant\nWHERE COUNTRIES.CODE = 'US' AND COUNTRIES.ID = PERSON.COUNTRY_ID AND GENRES.ID = PERSONS.GENRE_ID AND PROFESSIONS.ID = PERSONS.PROFESSIONS_ID\n</pre>","debt":"2h"},{"summary":"Track uses of \"NOSONAR\" comments","type":"Code Smell","defaultSeverity":"Major","description":"<p>Any issue to quality rule can be deactivated with the <code>NOSONAR</code> marker. This marker is pretty useful to exclude false-positive results\nbut it can also be used abusively to hide real quality flaws.</p>\n<p>This rule raises an issue when <code>NOSONAR</code> is used.</p>","debt":"1min"},{"summary":"\"GOTO\" should not be used within loops","type":"Code Smell","defaultSeverity":"Major","description":"<p>The use of <code>GOTO</code> in general is arguable. However, when used within loops, <code>GOTO</code> statements are even more evil, and they can\noften be replaced by other constructs.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  i PLS_INTEGER := 0;\nBEGIN\n  LOOP\n    IF i = 3 THEN\n      GOTO loopEnd; -- Noncompliant\n    END IF;\n\n    DBMS_OUTPUT.PUT_LINE('i = ' || i);\n\n    i := i + 1;\n  END LOOP;\n\n  &lt;&lt;loopEnd&gt;&gt;\n  DBMS_OUTPUT.PUT_LINE('Loop end');\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  i PLS_INTEGER := 0;\nBEGIN\n  LOOP\n    EXIT WHEN i = 3; -- Compliant\n\n    DBMS_OUTPUT.PUT_LINE('i = ' || i);\n\n    i := i + 1;\n  END LOOP;\n\n  DBMS_OUTPUT.PUT_LINE('Loop end');\nEND;\n/\n</pre>","debt":"1h"},{"summary":"\"FORALL\" should be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>The performance of DML queries in loops can be improved by placing them in a <code>FORALL</code> statement. This way, queries will be sent in bulk,\nminimizing the number of context switches between PL/SQL and SQL.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE largeTable(\n  foo VARCHAR2(42)\n);\n\nBEGIN\n  FOR i IN 1 .. 100000 LOOP\n    INSERT INTO largeTable VALUES('bar' || i); -- Non-compliant\n  END LOOP;\nEND;\n/\n\nSET TIMING ON\nDECLARE\n  TYPE largeTableRowArrayType IS TABLE OF largeTable%ROWTYPE;\n  largeTableRowArray largeTableRowArrayType;\nBEGIN\n  SELECT * BULK COLLECT INTO largeTableRowArray FROM largeTable;\n\n  EXECUTE IMMEDIATE 'TRUNCATE TABLE largeTable';\n  FOR i IN largeTableRowArray.FIRST .. largeTableRowArray.LAST LOOP\n    INSERT INTO largeTable (foo) VALUES (largeTableRowArray(i).foo); -- Non-compliant\n  END LOOP;\nEND;\n/\nSET TIMING OFF\n\nDROP TABLE largeTable;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE largeTable(\n  foo VARCHAR2(42)\n);\n\nBEGIN\n  FOR i IN 1 .. 100000 LOOP\n    INSERT INTO largeTable VALUES('bar' || i); -- Non-compliant\n  END LOOP;\nEND;\n/\n\nSET TIMING ON\nDECLARE\n  TYPE largeTableRowArrayType IS TABLE OF largeTable%ROWTYPE;\n  largeTableRowArray largeTableRowArrayType;\nBEGIN\n  SELECT * BULK COLLECT INTO largeTableRowArray FROM largeTable;\n\n  EXECUTE IMMEDIATE 'TRUNCATE TABLE largeTable';\n  FORALL i IN largeTableRowArray.FIRST .. largeTableRowArray.LAST\n    INSERT INTO largeTable (foo) VALUES (largeTableRowArray(i).foo); -- Compliant\n\n  INSERT INTO largeTable (foo) VALUES ('baz'); -- Compliant, not in a loop\nEND;\n/\nSET TIMING OFF\n\nDROP TABLE largeTable;\n</pre>","debt":"2h"},{"summary":"\"ROWID\" and \"UROWID\" data types should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>Be careful about your use of Oracle-specific data types like <code>ROWID</code> and <code>UROWID</code>. They might offer a slight improvement in\nperformance over other means of identifying a single row (primary key or unique index value), but that is by no means guaranteed.</p>\n<p>On the other hand, the use of <code>ROWID</code> or <code>UROWID</code> means that your SQL statement will not be portable to other SQL databases.\nFurther, many developers are not familiar with these data types, which can make the code harder to maintain.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  id rowid; -- Non-Compliant\n  universeId urowid; -- Non-Compliant\nBEGIN\n  SELECT rowid INTO id FROM DUAL;\n  SELECT rowid INTO universeId FROM DUAL;\n\n  DBMS_OUTPUT.PUT_LINE('id = ' || id);\n  DBMS_OUTPUT.PUT_LINE('universe id = ' || universeId);\nEND;\n/\n</pre>","debt":"1h"},{"summary":"\"NCHAR\" and \"NVARCHAR2\" size should not be specified in bytes","type":"Bug","defaultSeverity":"Blocker","description":"<p><code>NCHAR</code> and <code>NVARCHAR2</code> lengths must be given in characters, not bytes. This is partly because a single character may occupy\nmore than a single byte in memory. Specify the field length in bytes, and theoretically your value could overrun the field, but instead Oracle simply\nrefuses to run the code. Specify it in characters, and Oracle will allocate the appropriate number of bytes to store the requested number of\ncharacters. Trying to specify the length semantics in bytes will result in the <code>PLS-00639: NCHAR/NVARCHAR2 cannot be byte length semantics</code>\nexception being raised.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  foo NCHAR(42 BYTE); -- Noncompliant - raises PLS-00639\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  foo NCHAR(42);      -- Compliant\n  bar NCHAR(42 CHAR); -- Also compliant, as an alternative\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"1min"},{"summary":"Package names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all package names match a provided regular expression.</p>","debt":"2h"},{"summary":"Procedures should not contain \"RETURN\" statements","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Procedures, unlike functions, do not return values. The <code>RETURN</code> statement therefore, when used within a procedure, is used to\nprematurely end the procedure. However, having multiple exit points (i.e. more than the <code>END</code> of the procedure itself), increases the\ncomplexity of the procedure and makes it harder to understand and debug.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  PROCEDURE prcoedureWithReturn AS\n  BEGIN\n    RETURN; -- Noncompliant\n\n    DBMS_OUTPUT.PUT_LINE('prcoedureWithReturn called'); -- This is actually unreachable\n  END;\nBEGIN\n  prcoedureWithReturn;\nEND;\n/\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.7 - A function shall have a single point of exit at the end of the function. </li>\n  <li> MISRA C++:2008, 6-6-5 - A function shall have a single point of exit at the end of the function </li>\n  <li> MISRA C:2012, 15.5 - A function should have a single point of exit at the end </li>\n</ul>","debt":"1h"},{"summary":"Quoted identifiers should not be used","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Quoted identifiers are confusing to many programmers, as they look similar to string literals. Moreover, for maximum portability, identifiers\nshould be self-descriptive and should not contain accents. Quoted identifiers can contain any character, which can be confusing.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  \"x + y\" PLS_INTEGER := 0; -- Noncompliant, quoted identifiers are confusing\n  x PLS_INTEGER := 40;\n  y PLS_INTEGER := 2;\n  \"hello\" VARCHAR2(42) := 'world';  -- Noncompliant\n\nBEGIN\n  DBMS_OUTPUT.PUT_LINE(\"x + y\"); -- Noncompliant, displays 0\n  DBMS_OUTPUT.PUT_LINE(\"hello\"); -- Noncompliant, confusing, displays \"world\" and not \"hello\"\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  my_int PLS_INTEGER := 0;\n  x PLS_INTEGER := 40;\n  y PLS_INTEGER := 2;\n  greeting VARCHAR2(42) := 'hello';\nBEGIN\n  DBMS_OUTPUT.PUT_LINE(my_int);\n  DBMS_OUTPUT.PUT_LINE(x + y); -- Compliant, displays 42\n\n  DBMS_OUTPUT.PUT_LINE(greeting);\nEND;\n/\n</pre>","debt":"1h"},{"summary":"Related \"IF/ELSIF\" statements and \"WHEN\" clauses in a \"CASE\" should not have the same condition","type":"Bug","defaultSeverity":"Major","description":"<p>A <code>CASE</code> and a chain of <code>IF</code>/<code>ELSIF</code> statements is evaluated from top to bottom. At most, only one branch will be\nexecuted: the first one with a condition that evaluates to <code>true</code>. </p>\n<p>Therefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it's simply dead code and\nat worst, it's a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nIF param == 1 THEN\n  x := 'A';\nELSIF param == 2 THEN\n  x := 'B';\nELSIF param == 1 THEN -- Noncompliant, for sure this is a bug\n  x := 'C';\nEND IF;\n\nresult := CASE param\n   WHEN 1 THEN 'A'\n   WHEN 2 THEN 'B'\n   WHEN 1 THEN 'C'  -- Noncompliant\n   ELSE 'D'\nEND;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nIF param == 1 THEN\n  result := 'A';\nELSIF param == 2 THEN\n  result := 'B';\nELSIF param == 3 THEN\n  result := 'C';\nEND IF;\n\nresult := CASE param\n   WHEN 1 THEN 'A'\n   WHEN 2 THEN 'B'\n   WHEN 3 THEN 'C'\n   ELSE 'D'\nEND;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"10min"},{"summary":"Unused labels should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>If a label is declared but not used in the program, it can be considered as dead code and should therefore be removed.</p>\n<p>This will improve maintainability as developers will not wonder what this label is used for.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n&lt;&lt;foo&gt;&gt; -- Noncompliant\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('Hello, world!');\nEND;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n-- Compliant\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('Hello, world!');\nEND;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 2.6 - A function should not contain unused label declarations </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"2min"},{"summary":"\"LIKE\" clauses should not be used without wildcards","type":"Bug","defaultSeverity":"Major","description":"<p>The use of <code>LIKE</code> in a SQL query without one or more wildcards in the sought value is surely a typo. Either <code>=</code> was meant\ninstead, or the wildcard has been unintentionally omitted. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSELECT name\nFROM product\nWHERE name LIKE 'choc'\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSELECT name\nFROM product\nWHERE name LIKE 'choc%'\n</pre>\n<p>or </p>\n<pre>\nSELECT name\nFROM product\nWHERE name = 'choc'\n</pre>","debt":"5min"},{"summary":"Collapsible \"if\" statements should be merged","type":"Code Smell","defaultSeverity":"Major","description":"<p>Merging collapsible <code>if</code> statements increases the code's readability.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nIF something THEN\n  IF something_else THEN\n    -- ...\n  END IF;\nEND IF;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nIF something AND something_else THEN\n  -- ...\nEND IF;\n</pre>","debt":"5min"},{"summary":"Track breaches of an XPath rule","type":"Code Smell","defaultSeverity":"Major","description":"<p>This rule allows the definition of custom rules using XPath expressions.</p>\n<p>Issues are created depending on the return value of the XPath expression. If the XPath expression returns:</p>\n<ul>\n  <li> a single or list of AST nodes, then a line issue with the given message is created for each node </li>\n  <li> a boolean, then a file issue with the given message is created only if the boolean is true </li>\n  <li> anything else, no issue is created </li>\n</ul>\n<p>On the following code, the XPath expression <code>//IDENTIFIER[string-length(@tokenValue) &gt;= 10]</code> generates a violation on the identifier\n\"aaaaaaaaaa\":</p>\n<pre>\nDECLARE\n  aaaaaaaaaa NUMBER := 10; /* Non-Compliant, this identifier is 10 characters long */\n  aaaaaaaaa NUMBER := 9; /* Compliant, this one is only 9 */\nBEGIN\n  NULL;\nEND;\n/\n</pre>"},{"summary":"Cursors should follow a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all cursor names match the provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression, <code>[a-zA-Z]([a-zA-Z0-9_]*[a-zA-Z0-9])?</code>:</p>\n<pre>\nCREATE TABLE employee(\n  name VARCHAR2(42)\n);\n\nDECLARE\n  CURSOR myCursor_ RETURN employee%ROWTYPE; -- Noncompliant\n\n  CURSOR myCursor_ RETURN employee%ROWTYPE IS SELECT * FROM employee; -- Noncompliant\nBEGIN\n  NULL;\nEND;\n/\n\nDROP TABLE employee;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nCREATE TABLE employee(\n  name VARCHAR2(42)\n);\n\nDECLARE\n  CURSOR myCursor RETURN employee%ROWTYPE;\n\n  CURSOR myCursor RETURN employee%ROWTYPE IS SELECT * FROM employee;\nBEGIN\n  NULL;\nEND;\n/\n\nDROP TABLE employee;\n</pre>","debt":"30min"},{"summary":"\"CROSS JOIN\" queries should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>A <code>CROSS JOIN</code> query will return all records where each row from the first table is combined with each row from the second table. This\nmeans that such a query returns the Cartesian product of the sets of rows from the joined tables, which is why it is also know as \"Cartesian product\nquery\".</p>\n<p>Such a query can return a huge amount of data, and therefore should be used only with great caution and only when really needed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  -- Standard ANSI syntax\n  SELECT *\n    INTO employeeArray\n    FROM employee CROSS JOIN department; -- Noncompliant; explicit cross join\nEND;\n/\n\nBEGIN\n  -- Old syntax\n  SELECT *\n    INTO employeeArray\n    FROM employee, department; -- Noncompliant; also a cross join\nEND;\n/\n</pre>","debt":"1h"},{"summary":"All branches in a conditional structure should not have exactly the same implementation","type":"Bug","defaultSeverity":"Major","description":"<p>Having all branches in a <code>CASE</code> or <code>IF</code>/<code>ELSIF</code> chain with the same implementation is an error. Either a\ncopy-paste error was made and something different should be executed, or there shouldn't be a <code>CASE</code>/<code>IF</code>/<code>ELSIF</code>\nchain at all. Note that this rule does not apply to <code>IF</code>/<code>CASE</code> chains without <code>ELSE</code> clauses.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nIF param == 1 THEN\n  result := 'A';\nELSIF param == 2 THEN\n  result := 'A';\nELSE\n  result := 'A';\nEND IF;\n\nresult := CASE param\n   WHEN 1 THEN 'A'\n   WHEN 2 THEN 'A'\n   ELSE 'A'\nEND;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nIF param == 1 THEN\n  result := 'A';\nELSIF param == 2 THEN\n  result := 'B';\nELSE\n  result := 'C';\nEND IF;\n\nresult := CASE param\n   WHEN 1 THEN 'A'\n   WHEN 2 THEN 'B'\n   ELSE 'C'\nEND;\n</pre>","debt":"15min"},{"summary":"Procedures and functions should be encapsulated in packages","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having a bunch of standalone functions or procedures reduces maintainability because it becomes harder to find them and to see how they are\nrelated. Instead, they should be logically grouped into meaningful packages.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nCREATE PROCEDURE show_name(name VARCHAR2) AS -- Non-Compliant\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('Name: ' || name);\nEND;\n/\n\nDROP PROCEDURE show_name;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nCREATE PACKAGE employee AS\n  PROCEDURE show_name;\nEND;\n/\n\nCREATE PACKAGE BODY employee AS\n  name VARCHAR2(42);\n\n  PROCEDURE show_name AS  -- Compliant\n  BEGIN\n    DBMS_OUTPUT.PUT_LINE('Name: ' || name);\n  END;\nEND;\n/\n\nDROP PACKAGE employee;\n</pre>","debt":"1h"},{"summary":"\"SIMPLE_INTEGER\" should be used instead of \"PLS_INTEGER\"","type":"Code Smell","defaultSeverity":"Major","description":"<p>ORACLE 11g introduced the <code>SIMPLE_INTEGER</code> data type, which is a sub-type of <code>PLS_INTEGER</code>, and covers the same range. There\nare three main differences between the two types:</p>\n<ul>\n  <li> <code>SIMPLE_INTEGER</code> is always <code>NOT NULL</code>. So when the value of the declared variable is never going to be null, you can\n  declare it as <code>SIMPLE_INTEGER</code>. </li>\n  <li> You will never face a numeric overflow using <code>SIMPLE_INTEGER</code> because this data type wraps around without giving any error. </li>\n  <li> The <code>SIMPLE_INTEGER</code> data type gives a major performance boost over <code>PLS_INTEGER</code> when the code is compiled in \"NATIVE\"\n  mode, because arithmetic operations on <code>SIMPLE_INTEGER</code> type are performed directly at the hardware level. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  v1 PLS_INTEGER; -- Noncompliant\n  v2 VARCHAR2(10);\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  v1 SIMPLE_INTEGER := 42;\n  v2 VARCHAR2(10);\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"1h"},{"summary":"Queries should not \"SELECT\" too many columns","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>SELECT</code> queries that return too many columns may be complex or difficult to maintain. </p>\n<p>This rule identifies queries that <code>SELECT</code> more than the specified number of columns.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With a threshold of 6:</p>\n<pre>\nBEGIN\n  SELECT id, name, firstname, gender, height, weight, age -- Noncompliant\n    INTO peopleArray\n    FROM people\n    WHERE age &gt; 60;\nEND;\n/\n</pre>","debt":"1h"},{"summary":"\"FETCH ... BULK COLLECT INTO\" should be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>The <code>FETCH ... INTO</code> statement is inefficient when used in a loop (where many records are expected). It leads to many context-switches\nbetween the SQL and PL/SQL engines. Instead, the <code>FETCH ... BULK COLLECT INTO</code> statement will issue the SQL requests in bulk, minimizing\ncontext switches.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE largeTable AS SELECT ROWNUM AS id FROM all_objects;\n\nSET TIMING ON\nDECLARE\n  x PLS_INTEGER;\n  CURSOR largeCursor IS SELECT ROWNUM FROM largeTable;\n  largeTableRowId BINARY_INTEGER;\nBEGIN\n  OPEN largeCursor;\n\n  x := 0;\n  LOOP\n    FETCH largeCursor INTO largeTableRowId; -- Noncompliant\n    EXIT WHEN largeCursor%NOTFOUND;\n\n    x := x + largeTableRowId;\n  END LOOP;\n\n  DBMS_OUTPUT.PUT_LINE('Sum of rownums using alternative 1: ' || x);\n\n  CLOSE largeCursor;\nEND;\n/\nSET TIMING OFF\n\nDECLARE\n  r largeTable%ROWTYPE;\n  CURSOR myCursor IS SELECT * FROM largeTable;\nBEGIN\n  OPEN myCursor;\n  FETCH myCursor INTO r; -- Compliant, outside of a loop\n  CLOSE myCursor;\nEND;\n/\n\nDROP TABLE largeTable;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE largeTable AS SELECT ROWNUM AS id FROM all_objects;\n\nSET TIMING ON\nDECLARE\n  x PLS_INTEGER;\n  CURSOR largeCursor IS SELECT * FROM largeTable;\n  TYPE largeTableRowIdArrayType IS TABLE OF BINARY_INTEGER INDEX BY BINARY_INTEGER;\n  largeTableRowIdArray largeTableRowIdArrayType;\nBEGIN\n  OPEN largeCursor;\n\n  x := 0;\n  LOOP\n    FETCH largeCursor BULK COLLECT INTO largeTableRowIdArray LIMIT 1000; -- Compliant\n\n    FOR i IN largeTableRowIdArray.FIRST .. largeTableRowIdArray.LAST LOOP\n      x := x + largeTableRowIdArray(i);\n    END LOOP;\n\n    EXIT WHEN largeCursor%NOTFOUND;\n  END LOOP;\n\n  DBMS_OUTPUT.PUT_LINE('Sum of rownums using alternative 2: ' || x);\n\n  CLOSE largeCursor;\nEND;\n/\nSET TIMING OFF\n\nDECLARE\n  r largeTable%ROWTYPE;\n  CURSOR myCursor IS SELECT * FROM largeTable;\nBEGIN\n  OPEN myCursor;\n  FETCH myCursor INTO r; -- Compliant, outside of a loop\n  CLOSE myCursor;\nEND;\n/\n\nDROP TABLE largeTable;\n</pre>","debt":"1h"},{"summary":"DML events clauses should not include multiple \"OF\" clauses","type":"Bug","defaultSeverity":"Major","description":"<p>The DML events clause of a trigger is not meant to be used with multiple <code>OF</code> conditions. When it is, only the last one will actually be\ntaken into account, without any error message being produced. This can lead to counter-intuitive code.</p>\n<p>Only the <code>UPDATE</code> event should have an <code>OF</code> condition, and there should be at most one occurence of it.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nCREATE OR REPLACE TRIGGER myTrigger\n  BEFORE UPDATE OF firstName OR UPDATE OF lastName -- Noncompliant - will *only* be triggered on updates of lastName!\n  ON myTable\n  FOR EACH ROW\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nCREATE OR REPLACE TRIGGER myTrigger\n  BEFORE UPDATE OF firstName, lastName             -- Compliant - triggered on updates of firstName or/and lastName\n  ON myTable\n  FOR EACH ROW\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"1h"},{"summary":"\"EXECUTE IMMEDIATE\" should be used instead of DBMS_SQL procedure calls","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>EXECUTE IMMEDIATE</code> is easier to use and understand than the DBMS_SQL package's procedures. It should therefore be preferred, when\npossible.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE myTable(\n  foo VARCHAR2(42)\n);\n\nCREATE PROCEDURE drop_table(tableName VARCHAR2) AS\n  cursorIdentifier INTEGER;\nBEGIN\n  cursorIdentifier := DBMS_SQL.OPEN_CURSOR; -- Compliant; this is not a procedure call\n  DBMS_SQL.PARSE(cursorIdentifier, 'DROP TABLE ' || tableName, DBMS_SQL.NATIVE); -- Noncompliant\n  DBMS_SQL.CLOSE_CURSOR(cursorIdentifier); -- Noncompliant\n\n  DBMS_OUTPUT.PUT_LINE('Table ' || tableName || ' dropped.');\nEXCEPTION\n  WHEN OTHERS THEN\n    DBMS_SQL.CLOSE_CURSOR(cursorIdentifier); -- Noncompliant\nEND;\n/\n\nBEGIN\n  drop_table('myTable');\nEND;\n/\n\nDROP PROCEDURE drop_table;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE myTable(\n  foo VARCHAR2(42)\n);\n\nCREATE PROCEDURE drop_table(tableName VARCHAR2) AS\n  cursorIdentifier INTEGER;\nBEGIN\n  EXECUTE IMMEDIATE 'DROP TABLE ' || tableName;\n  DBMS_OUTPUT.PUT_LINE('Table ' || tableName || ' dropped.');\nEND;\n/\n\nBEGIN\n  drop_table('myTable');\nEND;\n/\n\nDROP PROCEDURE drop_table;\n</pre>","debt":"2h"},{"summary":"Improper constraint forms should not be used","type":"Bug","defaultSeverity":"Blocker","description":"<p>Not every data type supports the <code>RANGE</code> or scale constraints. Using these constraints on incompatible types results in an\n<code>PLS-00572: improper constraint form used</code> exception being raised.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  foo INTEGER RANGE 0 .. 42; -- Non-Compliant - raises PLS-00572 as NUMBER does not support the RANGE constraint\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  foo INTEGER; -- Compliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"30min"},{"summary":"\"NULL\" should not be compared directly","type":"Bug","defaultSeverity":"Major","description":"<p>In a Zen-like manner, \"NULL\" is never equal to anything, even itself. Therefore comparisons using equality operators will always return\n<code>False</code>, even when the value actually <code>IS NULL</code>.</p>\n<p>For that reason, comparison operators should never be used to make comparisons with <code>NULL</code>; <code>IS NULL</code> and <code>IS NOT\nNULL</code> should be used instead. This extends as well to empty string (\"\"), which is equivalent to <code>NULL</code> for some database engines.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  name VARCHAR2(42) := ''; /* This is equivalent to name := NULL; */\nBEGIN\n  IF name = '' THEN /* Noncompliant; equivalent to name = NULL &amp; therefore always FALSE*/\n    DBMS_OUTPUT.PUT_LINE('True'); /* Unreachable */\n  ELSE\n    DBMS_OUTPUT.PUT_LINE('False');\n  END IF;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  name VARCHAR2(42) := ''; /* This is equivalent to name := NULL; */\nBEGIN\n  IF name IS NULL THEN /* Compliant */\n    DBMS_OUTPUT.PUT_LINE('True');\n  ELSE\n    DBMS_OUTPUT.PUT_LINE('False');\n  END IF;\nEND;\n/\n</pre>","debt":"10min"},{"summary":"Deprecated LONG and LONG RAW datatypes should no longer be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>The <code>LONG</code> and <code>LONG RAW</code> datatypes are deprecated and Oracle recommends to migrate them to the LOB datatypes\n<code>CLOB</code>, <code>NCLOB</code> or <code>BLOB</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nCREATE TABLE images(\n  data LONG RAW\n);\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nCREATE TABLE images(\n  data BLOB\n);\n</pre>","debt":"2h"},{"summary":"Blocks containing \"EXECUTE IMMEDIATE\" should trap all exceptions","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Since the purpose of the <code>EXECUTE IMMEDIATE</code> statement is to execute dynamic SQL queries - which by definition can contain unexpected\nerrors - properly handling exceptions becomes critical. Therefore, care should be taken to trap all possible exceptions.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  result      VARCHAR2(42);\n  column      VARCHAR2(42);\nBEGIN\n  column := 'DUMMY_2';\n  EXECUTE IMMEDIATE 'SELECT ' || column || ' FROM DUAL' INTO result; -- Non-Compliant\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  result      VARCHAR2(42);\n  column      VARCHAR2(42);\nBEGIN\n  column := 'DUMMY_2';\n  EXECUTE IMMEDIATE 'SELECT ' || column || ' FROM DUAL' INTO result; -- Compliant\nEXCEPTION\n  WHEN OTHERS THEN\n    DBMS_OUTPUT.PUT_LINE ('Execute immediate error: ' || DBMS_UTILITY.FORMAT_ERROR_STACK);\nEND;\n/\n</pre>","debt":"1h"},{"summary":"The \"result_cache\" hint should be avoided","type":"Bug","defaultSeverity":"Major","description":"<p>The <code>result_cache</code> Oracle hint can vastly improve performance, but it comes at the cost of extra memory consumption, so one should\ndouble-check that the gain in performance is significant, and avoid overusing this feature in general.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSELECT /*+ result_cache */ * FROM DUAL;  -- Noncompliant\n</pre>","debt":"2h"},{"summary":"Anchored types should not be constrained","type":"Bug","defaultSeverity":"Blocker","description":"<p>Anchored types, i.e. those specified using either <code>%TYPE</code> or <code>%ROWTYPE</code>, cannot be constrained. Trying to do so results in\nthe exception <code>PLS-00573: cannot constrain scale, precision, or range of an anchored type being raised.</code></p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  foo DUAL.DUMMY%TYPE(42); -- Non-Compliant - raises PLS-00573\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  foo DUAL.DUMMY%TYPE; -- Compliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"5min"},{"summary":"An \"ORDER BY\" direction should be specified explicitly","type":"Code Smell","defaultSeverity":"Minor","description":"<p><code>ASC</code> or <code>DESC</code> should be specified for every column of an <code>ORDER BY</code> clause to improve readability.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  SELECT col1, col2, col3\n  BULK COLLECT INTO result\n  FROM my_table\n  ORDER BY\n    col1 ASC,\n    col2,            -- Noncompliant - ASC or DESC should be specified\n    col3 DESC;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  SELECT col1, col2, col3\n  BULK COLLECT INTO result\n  FROM my_table\n  ORDER BY\n    col1 ASC,\n    col2 ASC,\n    col3 DESC;\nEND;\n/\n</pre>","debt":"5min"},{"summary":"Variables should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all variable names match the provided regular expression.\n</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>[a-zA-Z]([a-zA-Z0-9_]*[a-zA-Z0-9])?</code>:</p>\n<pre>\nDECLARE\n  goodVariable PLS_INTEGER; -- Compliant\n  badVariable_ PLS_INTEGER; -- Non-Compliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"30min"},{"summary":"Cursor parameters should follow a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that cursor parameters match the provided regular\nexpression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>[a-zA-Z]([a-zA-Z0-9_]*[a-zA-Z0-9])?</code>:</p>\n<pre>\nCREATE TABLE employee(\n  name VARCHAR2(42)\n);\n\nDECLARE\n  CURSOR mycursor2(Employee-name-parameter_ VARCHAR2) RETURN employee%ROWTYPE; -- Noncompliant\n\n  CURSOR mycursor2(Employee-name-parameter_ VARCHAR2) RETURN employee%ROWTYPE IS SELECT * FROM employee WHERE name = Employee-name-parameter_; -- Noncompliant\nBEGIN\n  NULL;\nEND;\n/\n\nDROP TABLE employee;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nCREATE TABLE employee(\n  name VARCHAR2(42)\n);\n\nDECLARE\n  CURSOR mycursor2(employeeNameParameter VARCHAR2) RETURN employee%ROWTYPE;\n\n  CURSOR mycursor2(employeeNameParameter VARCHAR2) RETURN employee%ROWTYPE IS SELECT * FROM employee WHERE name = employeeNameParameter;\nBEGIN\n  NULL;\nEND;\n/\n\nDROP TABLE employee;\n</pre>","debt":"30min"},{"summary":"In labeled loops \"EXIT\" should exit the label","type":"Code Smell","defaultSeverity":"Major","description":"<p>Labeled loops are useful, especially when the code is badly indented, to match the begin and end of each loop. Within a labeled loop, the code's\nmaintainability is increased by explicitly providing the loop's label in every <code>EXIT</code> statement. Indeed, if a nested loop is added\nafterwards, it is clear which loop has to be exited.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  &lt;&lt;myLoopLabel1&gt;&gt;\n  LOOP\n    EXIT; -- Noncompliant, the loop label is missing\n  END LOOP myLoopLabel1;\n\n  LOOP\n    EXIT; -- Compliant, this EXIT is not in a labeled loop\n  END LOOP;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n &lt;&lt;myLoopLabel1&gt;&gt;\n  LOOP\n    EXIT myLoopLabel1;\n  END LOOP myLoopLabel1;\n\n  LOOP\n    EXIT;\n  END LOOP;\nEND;\n/\n</pre>","debt":"5min"},{"summary":"\"COMMIT\" and \"ROLLBACK\" should not be called from non-autonomous transaction triggers","type":"Bug","defaultSeverity":"Critical","description":"<p>Calling <code>COMMIT</code> or <code>ROLLBACK</code> from within a trigger will lead to an <code>ORA-04092</code> exception, unless the trigger has\nits own autonomous transaction.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE accounts(\n  balance NUMBER\n);\n\nINSERT INTO accounts VALUES(0);\n\nCREATE TABLE log(\n  message VARCHAR2(100)\n);\n\nCREATE TRIGGER beforeLogger\n  BEFORE UPDATE ON accounts\n  FOR EACH ROW\nBEGIN\n  INSERT INTO log VALUES('Attempt to update the value from ' || :OLD.balance || ' to ' || :NEW.balance);\n  COMMIT; -- Noncompliant, will fail with a ORA-04092\nEND;\n/\n\n-- We want to be able to log any attempt to update the \"accounts\" table\nBEGIN\n  UPDATE accounts SET balance = 100;\n  ROLLBACK; -- Ultimately, this update is rolled back, however we still want to log it\nEND;\n/\n\nSELECT * FROM log;\n\nDROP TRIGGER beforeLogger;\n\nDROP TABLE log;\n\nDROP TABLE accounts;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE accounts(\n  balance NUMBER\n);\n\nINSERT INTO accounts VALUES(0);\n\nCREATE TABLE log(\n  message VARCHAR2(100)\n);\n\nCREATE TRIGGER beforeLogger\n  BEFORE UPDATE ON accounts\n  FOR EACH ROW\nDECLARE\n  PRAGMA AUTONOMOUS_TRANSACTION;\nBEGIN\n  INSERT INTO log VALUES('Attempt to update the value from ' || :OLD.balance || ' to ' || :NEW.balance);\n  COMMIT; -- Compliant, commits the trigger's autonomous transaction, not the main one\nEND;\n/\n\n-- We want to be able to log any attempt to update the \"accounts\" table\nBEGIN\n  UPDATE accounts SET balance = 100;\n  ROLLBACK; -- Ultimately, this update is rolled back, however we still want to log it\nEND;\n/\n\nSELECT * FROM log;\n\nDROP TRIGGER beforeLogger;\n\nDROP TABLE log;\n\nDROP TABLE accounts;\n</pre>","debt":"1h"},{"summary":"Lines in a multiline comment should start with \"*\"","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Multi-line comments are more readable when each line is aligned using the \"*\" character. At most one violation is created for each comment</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n/*\nthis line is not aligned and ugly Non-Compliant\nno violation is created on this line, even though is it also bad\n */\n\n/* this is Compliant */\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n/*\n * this is much better Compliant\n */\n\n/* this is Compliant */\n</pre>","debt":"10min"},{"summary":"Constant declarations should contain initialization assignments","type":"Bug","defaultSeverity":"Blocker","description":"<p>Constants must be immediately initialized at declaration. They cannot be reassigned any value after the declaration, as they are constant. This\nrule prevents PLS-00322 exceptions from being raised at runtime.</p>\n<p>The following code snippet illustrates this rule:</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  foo CONSTANT PLS_INTEGER NULL; -- Noncompliant PLS-00322\n  bar CONSTANT PLS_INTEGER NOT NULL; -- Noncompliant PLS-00322\n  aa CONSTANT PLS_INTEGER; -- Noncompliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  foo CONSTANT PLS_INTEGER NULL :=42;\n  bar CONSTANT PLS_INTEGER NOT NULL := 42;\n  aa CONSTANT PLS_INTEGER := 42; -- Compliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"30min"},{"summary":"\"WHEN OTHERS\" clauses should be used for exception handling","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Ensure that every possible exception is caught by using a <code>WHEN OTHERS</code> clause.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  result PLS_INTEGER;\n  custom_exception EXCEPTION;\nBEGIN\n  result := 42 / 0;                            -- \"Unexpected\" division by 0\n\n  RAISE custom_exception;\nEXCEPTION                                      -- Non-Compliant\n  WHEN custom_exception THEN\n    DBMS_OUTPUT.PUT_LINE ('custom_exception: ' || DBMS_UTILITY.FORMAT_ERROR_STACK);\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  result PLS_INTEGER;\n  custom_exception EXCEPTION;\nBEGIN\n  result := 42 / 0;                            -- \"Unexpected\" division by 0\n\n  RAISE custom_exception;\nEXCEPTION                                      -- Compliant\n  WHEN custom_exception THEN\n    DBMS_OUTPUT.PUT_LINE ('custom_exception: ' || DBMS_UTILITY.FORMAT_ERROR_STACK);\n  WHEN OTHERS THEN\n    DBMS_OUTPUT.PUT_LINE ('other: ' || DBMS_UTILITY.FORMAT_ERROR_STACK);\nEND;\n/\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 15-3-2 </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/391.html\">MITRE, CWE-391</a> - Unchecked Error Condition </li>\n</ul>","debt":"10min"},{"summary":"\"RESULT_CACHE\" should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>Because <code>RESULT_CACHE</code>-enabled functions increase memory consumption, one should double-check that the gain in performances is\nsignificant, and avoid over-using this feature in general.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nCREATE FUNCTION myFastFunction RETURN PLS_INTEGER RESULT_CACHE AS -- Noncompliant\nBEGIN\n  RETURN 42;\nEND;\n/\n\nDROP FUNCTION myFastFunction;\n</pre>","debt":"4h"},{"summary":"Constant names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all constant names match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>[a-zA-Z]([a-zA-Z0-9_]*[a-zA-Z0-9])?</code>:</p>\n<pre>\nDECLARE\n  constant_ CONSTANT PLS_INTEGER := 42; -- Noncompliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  constant CONSTANT PLS_INTEGER := 42; -- Compliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"30min"},{"summary":"\"FORALL\" statements should use the \"SAVE EXCEPTIONS\" clause","type":"Bug","defaultSeverity":"Blocker","description":"<p>When the <code>FORALL</code> statement is used without the <code>SAVE EXCEPTIONS</code> clause and an exception is raised by a DML query, the whole\noperation is rolled back and the exception goes unhandled. Instead of relying on this default behavior, it is better to always use the <code>SAVE\nEXCEPTIONS</code> clause and explicitly handle exceptions in a <code>ORA-24381</code> handler.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nCREATE TABLE my_table(\n  id NUMBER(10) NOT NULL\n);\n\nDECLARE\n  TYPE my_table_id_type IS TABLE OF my_table.id%TYPE;\n  my_table_ids my_table_id_type := my_table_id_type();\nBEGIN\n  FOR i IN 1 .. 10 LOOP\n    my_table_ids.EXTEND;\n    my_table_ids(my_table_ids.LAST) := i;\n  END LOOP;\n\n  -- Cause the failure\n  my_table_ids(10) := NULL;\n\n  FORALL i IN my_table_ids.FIRST .. my_table_ids.LAST  -- Noncompliant\n    INSERT INTO my_table\n    VALUES (my_table_ids(i));\nEND;\n/\n\nSELECT COUNT(*) FROM my_table;\n\nDROP TABLE my_table;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n-- ...\n\nDECLARE\n  TYPE my_table_id_type IS TABLE OF my_table.id%TYPE;\n  my_table_ids my_table_id_type := my_table_id_type();\n\n  bulk_errors EXCEPTION;\n  PRAGMA EXCEPTION_INIT(bulk_errors, -24381);\nBEGIN\n  FOR i IN 1 .. 10 LOOP\n    my_table_ids.EXTEND;\n    my_table_ids(my_table_ids.LAST) := i;\n  END LOOP;\n\n  -- Cause the failure\n  my_table_ids(10) := NULL;\n\n  FORALL i IN my_table_ids.FIRST .. my_table_ids.LAST SAVE EXCEPTIONS\n    INSERT INTO my_table\n    VALUES (my_table_ids(i));\nEXCEPTION\n  WHEN bulk_errors THEN\n    -- Explicitly rollback the whole transaction,\n    -- or handle each exception individually by looping over SQL%BULK_EXCEPTIONS\n    ROLLBACK;\nEND;\n/\n\n-- ...\n</pre>","debt":"1h"},{"summary":"Procedures and functions should be documented","type":"Code Smell","defaultSeverity":"Major","description":"<p>Each function and procedure should be documented with a comment either just before or right after the <code>IS</code> or <code>AS</code> keyword it\nto explain its goal and how it works. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nCREATE FUNCTION my_function RETURN PLS_INTEGER AS\nBEGIN\n  RETURN 42;\nEND;\n/\n\nCREATE PACKAGE my_package AS\n\nPROCEDURE my_procedure;\n\nFUNCTION my_function RETURN PLS_INTEGER;\n\nEND my_package;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nCREATE FUNCTION my_function RETURN PLS_INTEGER AS\n-- Computes the meaning of life\nBEGIN\n  RETURN 42;\nEND;\n/\n\nCREATE PACKAGE my_package AS\n\n-- This is documentation\nPROCEDURE my_procedure;\n\n/*\n  This is documentation\n*/\nFUNCTION my_function RETURN PLS_INTEGER;\n\nEND my_package;\n/\n</pre>\n<h2>Exceptions</h2>\n<p>Functions are procedures declared in package bodies, and anonymous PL/SQL blocks do not have to be documented.</p>\n<pre>\nDECLARE\n  PROCEDURE helper_procedure AS\n  BEGIN\n    NULL;\n  END;\nBEGIN\n  helper_procedure;\nEND;\n/\n\nCREATE PACKAGE my_package AS\n\n-- This is documentation\nPROCEDURE public_procedure;\n\nEND my_package;\n/\n\nCREATE PACKAGE BODY my_package AS\n\nPROCEDURE helper_procedure AS\nBEGIN\n  NULL;\nEND;\n\nPROCEDURE public_procedure AS\nBEGIN\n  helper_procedure;\nEND;\n\nEND my_package;\n/\n</pre>","debt":"10min"},{"summary":"\"DBMS_UTILITY.FORMAT_ERROR_STACK\" and \"FORMAT_ERROR_BACKTRACE\" should be used together","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Since Oracle 10g, <code>DBMS_UTILITY.FORMAT_ERROR_BACKTRACE</code> is available to get an exception's stack trace, i.e. files and lines that lead\nup to the exception. When combined with <code>DBMS_UTILITY.FORMAT_ERROR_STACK</code>, which contains the exception error code and message, developers\nare able quickly identify defects.</p>\n<p>This rule verifies that whenever either is used in an exception handler, the other is used as well.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  RAISE_APPLICATION_ERROR(-20000, 'This is an error example');\nEXCEPTION\n  WHEN OTHERS THEN  -- Noncompliant; only FORMAT_ERROR_STACK is used\n    DBMS_OUTPUT.PUT(DBMS_UTILITY.FORMAT_ERROR_STACK);           -- \"ORA-20000: This is an error example\"\n    DBMS_OUTPUT.PUT_LINE('');\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  RAISE_APPLICATION_ERROR(-20000, 'This is an error example');\nEXCEPTION\n  WHEN OTHERS THEN\n    DBMS_OUTPUT.PUT(DBMS_UTILITY.FORMAT_ERROR_STACK);           -- \"ORA-20000: This is an error example\"\n    DBMS_OUTPUT.PUT(DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);       -- \"ORA-06512: at line 2\"\n    DBMS_OUTPUT.PUT_LINE('');\nEND;\n/\n</pre>","debt":"10min"},{"summary":"\"DBMS_OUTPUT.PUT_LINE\" should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The output of <code>DBMS_OUTPUT.PUT_LINE</code> is not always visible, for example when <code>SERVEROUTPUT</code> is set to <code>OFF</code>.\nMoreover, there is no standardized way to specify the importance of the message. It is better to use a logging mechanism instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('An error occured'); -- Noncompliant\nEND;\n/\n</pre>","debt":"5min"},{"summary":"\"PACKAGE BODY\" initialization sections should not contain \"RETURN\" statements","type":"Bug","defaultSeverity":"Major","description":"<p>In a CREATE PACKAGE BODY, the purpose of the initialization section is to set the initial values of the package's global variables. It is therefore\nsurprising to find a RETURN statement there, as all its following statements will be unreachable.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE OR REPLACE PACKAGE foo AS\n  FUNCTION getBar RETURN PLS_INTEGER;\n  bar PLS_INTEGER;\nEND;\n/\n\nCREATE OR REPLACE PACKAGE BODY foo AS\n  FUNCTION getBar RETURN PLS_INTEGER AS\n  BEGIN\n    RETURN bar; -- Compliant\n  END;\nBEGIN\n  bar := 42;\n  DBMS_OUTPUT.PUT_LINE('package loaded');\n  RETURN; -- Noncompliant\n  DBMS_OUTPUT.PUT_LINE('this is unreachable code');\nEND;\n/\n\nDROP PACKAGE BODY foo;\n\nDROP PACKAGE foo;\n</pre>","debt":"1h"},{"summary":"Oracle's join operator (+) should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Developers should use the <code>FROM ... OUTER JOIN</code> syntax rather than the Oracle join operator (<code>+</code>). The reason is that outer\njoin queries that use <code>+</code> are subject to several restrictions which do not apply to the <code>FROM ... OUTER JOIN</code> syntax. For\ninstance, a <code>WHERE</code> condition containing the <code>+</code> operator cannot be combined with another condition using the <code>OR</code>\nlogical operator.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  -- Noncompliant\n  SELECT *\n    INTO employeesArray\n    FROM employee, department\n    WHERE employee.DepartmentID = department.ID(+);\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  -- Compliant\n  SELECT *\n    INTO employeesArray\n    FROM employee LEFT OUTER JOIN department\n    ON employee.DepartmentID = department.ID;\nEND;\n/\n</pre>","debt":"1h"},{"summary":"\"WHEN OTHERS\" should not be the only exception handler","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Before trapping all possible exceptions, it is best to try to trap the specific ones and try to recover from those.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE hitCounter\n(\n  page VARCHAR2(42),\n  hits NUMBER,\n  CONSTRAINT pk PRIMARY KEY (page)\n);\n\nCREATE PROCEDURE hitPage(pageIn VARCHAR2) AS\nBEGIN\n  INSERT INTO hitCounter VALUES (pageIn, 1);\nEXCEPTION -- Noncompliant, the only exception handler is WHEN OTHERS\n  WHEN OTHERS THEN\n    IF SQLCODE = -1 THEN\n      UPDATE hitCounter SET hits = hits + 1 WHERE page = pageIn;\n    ELSE\n      DBMS_OUTPUT.PUT_LINE('An unknown error occured!');\n    END IF;\nEND;\n/\n\nBEGIN\n  hitPage('index.html');\n  hitPage('index.html');\nEND;\n/\n\nSELECT * FROM hitCounter;\n\nDROP PROCEDURE hitPage;\nDROP TABLE hitCounter;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE TABLE hitCounter\n(\n  page VARCHAR2(42),\n  hits NUMBER,\n  CONSTRAINT pk PRIMARY KEY (page)\n);\n\nCREATE PROCEDURE hitPage(pageIn VARCHAR2) AS\nBEGIN\n  INSERT INTO hitCounter VALUES (pageIn, 1);\nEXCEPTION\n  WHEN DUP_VAL_ON_INDEX THEN\n    UPDATE hitCounter SET hits = hits + 1 WHERE page = pageIn;\n  WHEN OTHERS THEN\n    DBMS_OUTPUT.PUT_LINE('An unknown error occured!');\nEND;\n/\n\nBEGIN\n  hitPage('index.html');\n  hitPage('index.html');\nEND;\n/\n\nSELECT * FROM hitCounter;\n\nDROP PROCEDURE hitPage;\nDROP TABLE hitCounter;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/396.html\">MITRE, CWE-396</a> - Declaration of Catch for Generic Exception </li>\n</ul>","debt":"1h"},{"summary":"Sections of code should not be \"commented out\"","type":"Code Smell","defaultSeverity":"Major","description":"<p>Programmers should not comment out code as it bloats programs and reduces readability.</p>\n<p>Unused code should be deleted and can be retrieved from source control history if required.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 2.4 - Sections of code should not be \"commented out\". </li>\n  <li> MISRA C++:2008, 2-7-2 - Sections of code shall not be \"commented out\" using C-style comments. </li>\n  <li> MISRA C++:2008, 2-7-3 - Sections of code should not be \"commented out\" using C++ comments. </li>\n  <li> MISRA C:2012, Dir. 4.4 - Sections of code should not be \"commented out\" </li>\n</ul>","debt":"5min"},{"summary":"\"WHEN\" clauses should not have too many lines","type":"Code Smell","defaultSeverity":"Major","description":"<p>The <code>CASE</code> statement should be used only to clearly define some new branches in the control flow. As soon as a <code>WHEN</code> clause\ncontains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of\n<code>WHEN</code> clause should be extracted in a dedicated function.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nCASE my_variable\n  WHEN 0 THEN -- 6 lines till next WHEN\n    procedure1;\n    procedure2;\n    procedure3;\n    procedure4;\n    procedure5;\n  WHEN 1 THEN\n-- ...\nEND CASE;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  PROCEDURE do_something AS\n  BEGIN\n    procedure1;\n    procedure2;\n    procedure3;\n    procedure4;\n    procedure5;\n  END;\nBEGIN\n  CASE my_variable\n    WHEN 0 THEN\n      do_something;\n    WHEN 1 THEN\n-- ...\n  END CASE;\nEND;\n/\n</pre>","debt":"5min"},{"summary":"\"VARCHAR2\" should be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>Currently, <code>VARCHAR</code> and <code>VARCHAR2</code> are identical data types. But to prevent future changes in behavior, Oracle recommends\nthe use of <code>VARCHAR2</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  var VARCHAR(42);  -- Noncompliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  var VARCHAR2(42);  -- Noncompliant\nBEGIN\n  NULL;\nEND;\n/\n</pre>","debt":"1min"},{"summary":"\"IF ... ELSEIF\" constructs should end with \"ELSE\" clauses","type":"Code Smell","defaultSeverity":"Critical","description":"<p>This rule applies whenever an <code>IF</code> statement is followed by one or </p>\n<p>more <code>ELSEIF</code> statements; the final <code>ELSEIF</code> should be followed by an <code>ELSE</code> statement.</p>\n<p>The requirement for a final <code>ELSE</code> statement is defensive programming. </p>\n<p>The <code>ELSE</code> statement should either take appropriate action or contain </p>\n<p>a suitable comment as to why no action is taken. This is consistent with the </p>\n<p>requirement to have a final <code>ELSE</code> clause in a <code>CASE</code></p>\n<p>statement. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nIF my_variable = 0 THEN\n  do_something;\nELSIF my_variable = 1 THEN\n  do_something_else;\nEND IF;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nIF my_variable = 0 THEN\n  do_something;\nELSIF my_variable = 1 THEN\n  do_something_else;\nELSE\n  -- Nothing has to be done.\n  NULL;\nEND IF;\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.10 - All if...else if constructs shall be terminated with an else clause. </li>\n  <li> MISRA C++:2008, 6-4-2 - All if...else if constructs shall be terminated with an else clause. </li>\n  <li> MISRA C:2012, 15.7 - All if...else if constructs shall be terminated with an else statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/YgE\">CERT, MSC01-C.</a> - Strive for logical completeness </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/JoIyAQ\">CERT, MSC01-CPP.</a> - Strive for logical completeness </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/PQHRAw\">CERT, MSC57-J.</a> - Strive for logical completeness </li>\n</ul>","debt":"5min"},{"summary":"\"CREATE OR REPLACE\" should be used instead of \"CREATE\"","type":"Code Smell","defaultSeverity":"Critical","description":"<p>When creating a function, procedure, package, package body, type, type body, trigger or library, it is a good practice replace the existing one to\navoid errors.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nCREATE FUNCTION my_function RETURN PLS_INTEGER AS -- Noncompliant\nBEGIN\n  RETURN 42;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nCREATE OR REPLACE FUNCTION my_function RETURN PLS_INTEGER AS -- Compliant, no error even if the function already exists\nBEGIN\n  RETURN 42;\nEND;\n/\n</pre>","debt":"1min"},{"summary":"\"EXCEPTION_INIT -20,NNN\" calls should be centralized","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Centralizing the definitions of custom exceptions comes with two major benefits:</p>\n<ul>\n  <li> The duplication of the exceptions declarations and <code>PRAGMA EXCEPTION_INIT</code> is avoided </li>\n  <li> The risk of associating multiple different exceptions to the same number is reduced </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  user_not_found EXCEPTION;\n  PRAGMA EXCEPTION_INIT(user_not_found, -20000); -- Noncompliant, user_not_found is bound to -20000\nBEGIN\n  NULL;\nEND;\n/\n\nDECLARE\n  user_not_found EXCEPTION;\n  PRAGMA EXCEPTION_INIT(user_not_found, -20000); -- Noncompliant, user_not_found is again bound to -20000, duplication\nBEGIN\n  NULL;\nEND;\n/\n\nDECLARE\n  wrong_password EXCEPTION;\n  PRAGMA EXCEPTION_INIT(wrong_password, -20000); -- Noncompliant, wrong_password is bound to -20000, conflicting with user_not_found\nBEGIN\n  NULL;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nCREATE PACKAGE exceptions AS\n user_not_found EXCEPTION;\n wrong_password EXCEPTION;\n\n PRAGMA EXCEPTION_INIT(user_not_found, -20000); -- Non-Compliant (flag as false-positive)\n PRAGMA EXCEPTION_INIT(wrong_password, -20001); -- Non-Compliant (flag as false-positive), conflicts are easier to avoid\nEND;\n/\n\nDROP PACKAGE exceptions;\n</pre>","debt":"30min"},{"summary":"Functions should end with \"RETURN\" statements","type":"Bug","defaultSeverity":"Critical","description":"<p>Always having a <code>RETURN</code> as the last statement in a function is a good practice for two reasons:</p>\n<ul>\n  <li> It prevents the <code>ORA-06503 PL/SQL: Function returned without value</code> error. </li>\n  <li> It prevents unreachable code from being added after the <code>RETURN</code>. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nCREATE FUNCTION incorrectFunction1 RETURN PLS_INTEGER IS -- Non-Compliant\nBEGIN\n  RETURN 42;\n\n   -- This is unreachable code\n   NULL;\nEND;\n/\n\nDROP FUNCTION incorrectFunction1;\n\nCREATE FUNCTION incorrectFunction2 RETURN PLS_INTEGER IS -- Non-Compliant\nBEGIN\n   NULL; -- This function was expected to return a PLS_INTEGER, but did not. Will lead to ORA-06503\nEND;\n/\n\nBEGIN\n  DBMS_OUTPUT.PUT_LINE('Ret = ' || incorrectFunction2); -- ORA-06503 PL/SQL: Function returned without value\nEND;\n/\n\nDROP FUNCTION incorrectFunction2;\n\nCREATE FUNCTION correctFunction RETURN PLS_INTEGER IS -- Compliant\nBEGIN\n  RETURN 42;\nEND;\n/\n\nDROP FUNCTION correctFunction;\n</pre>","debt":"10min"},{"summary":"Global public variables should not be defined","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>When data structures (scalar variables, collections, cursors) are declared in the package specification (not within any specific program), they can\nbe referenced directly by any program running in a session with <code>EXECUTE</code> rights to the package.</p>\n<p>Instead, declare all package-level data in the package body and provide getter and setter functions in the package specification. Developers can\nthen access the data using these methods and will automatically follow all rules you set upon data modification.</p>\n<p>By doing so you can guarantee data integrity, change your data structure implementation, and also track access to those data structures.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n-- Package specification\nCREATE PACKAGE employee AS\n   name VARCHAR2(42); -- Non-Compliant\nEND employee;\n/\n\nDROP PACKAGE employee;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n-- Package specification\nCREATE PACKAGE employee AS\n   PROCEDURE setName (newName VARCHAR2);\n   FUNCTION getName RETURN VARCHAR2;\nEND employee;\n/\n\n-- Package body\nCREATE PACKAGE BODY employee AS\n   name VARCHAR2(42);\n\n   PROCEDURE setName (newName VARCHAR2) IS\n   BEGIN\n     name := newName;\n   END;\n\n   FUNCTION getName RETURN VARCHAR2 IS\n   BEGIN\n     RETURN name;\n   END;\nEND employee;\n/\n\nDROP PACKAGE BODY employee;\n\nDROP PACKAGE employee;\n</pre>","debt":"2h"},{"summary":"Nested subqueries should be avoided","type":"Code Smell","defaultSeverity":"Major","description":"<p>Subqueries are nested when they appear in the <code>WHERE</code> clause of the parent statement. When an Oracle database evaluates a statement with\na nested subquery, it must evaluate the subquery portion multiple times and may overlook some efficient access paths or joins.</p>\n<p>Subquery unnesting unnests and merges the body of the subquery into the body of the statement that contains it, allowing the optimizer to consider\nthe queries together when evaluating access paths and joins. The optimizer can unnest most subqueries, with some exceptions. Those exceptions\ninclude:</p>\n<ul>\n  <li> hierarchical subqueries </li>\n  <li> subqueries that contain a <code>ROWNUM</code> pseudocolumn </li>\n  <li> subqueries that contain one of the set operators </li>\n  <li> subqueries that contain a nested aggregate function </li>\n  <li> subqueries that contain a correlated reference to a query block that is not the immediate outer query block of the subquery. </li>\n</ul>\n<p>Assuming no restrictions exist, the optimizer automatically unnests some (but not all) of the following nested subqueries:</p>\n<ul>\n  <li> Uncorrelated <code>IN</code> subqueries </li>\n  <li> <code>IN</code> and <code>EXISTS</code> correlated subqueries, as long as they do not contain aggregate functions or a <code>GROUP BY</code>\n  clause </li>\n</ul>\n<p>You can enable extended subquery unnesting by instructing the optimizer to unnest additional types of subqueries:</p>\n<ul>\n  <li> You can unnest an uncorrelated <code>NOT IN</code> subqueries by specifying the <code>HASH_AJ</code> or <code>MERGE_AJ</code> hint in the\n  subquery. </li>\n  <li> You can unnest other subqueries by specifying the <code>UNNEST</code> hint in the subquery. </li>\n</ul>\n<p>Because these optimizations are dependant on the version of Oracle used, it is best to avoid using nested subqueries in the first place when\npossible.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  SELECT col1\n  BULK COLLECT INTO result\n  FROM table1\n  WHERE col2 IN (SELECT col3 FROM table2); -- Noncompliant\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  SELECT col1                              -- Compliant\n  BULK COLLECT INTO result\n  FROM table1\n  JOIN table2 ON col2 = col3;\nEND;\n/\n</pre>","debt":"1h"},{"summary":"Nested loops should be labeled","type":"Code Smell","defaultSeverity":"Major","description":"<p>Labeled loops are useful, especially when the code is badly indented, to match the begin and end of each loop. When loops are nested, labeling them\ncan improve the code's readability. This rule detects nested loops which do not have a start label.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  LOOP\n    LOOP -- Noncompliant, this nested loop is not labeled\n      EXIT;\n    END LOOP;\n\n    EXIT;\n  END LOOP;\n\n  FOR i IN 1..10  LOOP\n    WHILE true LOOP -- Noncompliant, this nested loop has no start label\n      EXIT;\n    END LOOP nestedLoopLabel1;\n\n    EXIT;\n  END LOOP;\n\n  WHILE true LOOP\n    &lt;&lt;nestedLoopLabel2&gt;&gt;\n    LOOP -- Compliant, but better with an end label\n      EXIT;\n    END LOOP;\n\n    EXIT;\n  END LOOP;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  LOOP\n    &lt;&lt;nestedLoopLabel0&gt;&gt;\n    LOOP\n      EXIT;\n    END LOOP nestedLoopLabel0;\n\n    EXIT;\n  END LOOP;\n\n  FOR i IN 1..10  LOOP\n    &lt;&lt;nestedLoopLabel1&gt;&gt;\n    WHILE true LOOP\n      EXIT;\n    END LOOP nestedLoopLabel1;\n\n    EXIT;\n  END LOOP;\n\n  WHILE true LOOP\n    &lt;&lt;nestedLoopLabel2&gt;&gt;\n    LOOP\n      EXIT;\n    END LOOP nestedLoopLabel2;\n\n    EXIT;\n  END LOOP;\nEND;\n/\n</pre>","debt":"10min"},{"summary":"The \"RELIES_ON\" clause should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Since Oracle 11.2, <code>RELIES_ON</code> has been deprecated because the dependencies of result cache-enabled functions are automatically\ncomputed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nCREATE OR REPLACE FUNCTION foo RETURN PLS_INTEGER RESULT_CACHE RELIES_ON(DUAL) AS -- Noncompliant\nBEGIN\n  RETURN 0;\nEND;\n/\n\nDROP FUNCTION foo;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nCREATE OR REPLACE FUNCTION foo RETURN PLS_INTEGER RESULT_CACHE AS\nBEGIN\n  RETURN 0;\nEND;\n/\n\nDROP FUNCTION foo;\n</pre>","debt":"10min"},{"summary":"Weak \"REF CURSOR\" types should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Weak <code>REF CURSOR</code> types are harder to work with than ones with a return type. Indeed, the compiler's type-checker is unable to make some\nverifications, which are then delayed till runtime.</p>\n<p>When the use of weak <code>REF CURSOR</code> is required, it is best to use the <code>SYS_REFCURSOR</code> built-in type instead of defining a new\none.</p>\n<p>This rule's sysRefCursorAllowed parameter can be used to control whether or not the usage of <code>SYS_REFCURSOR</code> is allowed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDECLARE\n  TYPE dualCursorType IS REF CURSOR;                      -- Noncompliant\n  dualCursor dualCursorType;\n\n  otherCursor SYS_REFCURSOR;                              -- Compliant or non-compliant, depending on the \"sysRefCursorAllowed\" parameter\nBEGIN\n  otherCursor := dualCursor;                              -- Works\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  TYPE dualCursorType IS REF CURSOR RETURN DUAL%ROWTYPE;\n  dualCursor dualCursorType;\n\n  TYPE otherCursorType IS REF CURSOR RETURN a%ROWTYPE;\n  otherCursor otherCursorType;\nBEGIN\n  otherCursor := dualCursor;                              -- raises PLS-00382: expression is of wrong type, which makes debugging easier\nEND;\n/\n</pre>","debt":"20min"},{"summary":"\"EXIT\" should not be used in loops","type":"Code Smell","defaultSeverity":"Minor","description":"<p>FOR and WHILE loops are structured control flow statements.</p>\n<p>A FOR loop will iterate once for each element in the range, and the WHILE iterates for as long as a condition holds.</p>\n<p>However, inserting an <code>EXIT</code> statement within the loop breaks this structure, reducing the code's readability and making it harder to\ndebug.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  TYPE myCollectionType IS VARRAY(10) OF VARCHAR2(42);\n  myCollection myCollectionType := myCollectionType('Foo', 'Bar', NULL, 'Baz', 'Qux');\n\n  i PLS_INTEGER;\nBEGIN\n  i := 1;\n  WHILE i &lt;= myCollection.LAST LOOP\n    EXIT WHEN myCollection(i) IS NULL; -- Noncompliant, breaks the structure of the WHILE\n\n    DBMS_OUTPUT.PUT_LINE('Got: ' || myCollection(i));\n    i := i + 1;\n  END LOOP;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  TYPE myCollectionType IS VARRAY(10) OF VARCHAR2(42);\n  myCollection myCollectionType := myCollectionType('Foo', 'Bar', NULL, 'Baz', 'Qux');\n\n  i PLS_INTEGER;\nBEGIN\n  i := 1;\n  WHILE i &lt;= myCollection.LAST AND myCollection(i) IS NOT NULL LOOP\n    DBMS_OUTPUT.PUT_LINE('Got: ' || myCollection(i));\n    i := i + 1;\n  END LOOP;\nEND;\n/\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.5 - The continue statement shall not be used. </li>\n</ul>","debt":"20min"},{"summary":"Reserved words should be written in lower case","type":"Code Smell","defaultSeverity":"Minor","description":"<p>All reserved words should be written using the same case to ensure consistency in the code.</p>\n<p>This rule checks that reserved words are all in lower case.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nbegin\n  null;\n  NULL; -- Noncompliant\nend;\n/\n</pre>","debt":"1min"},{"summary":"\"END\" statements of labeled loops should be labeled","type":"Code Smell","defaultSeverity":"Major","description":"<p>Labeled loops are useful, especially when the code is badly indented, to match the begin and end of each loop. This rule raises an issue when the\nend of a labeled loop is unlabeled.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nBEGIN\n  &lt;&lt;myLoopLabel1&gt;&gt;\n  LOOP\n    EXIT;\n  END LOOP; -- Noncompliant; this labeled loop has no ending label\n\n  LOOP\n    EXIT;\n  END LOOP; -- Compliant; not a labeled loop\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nBEGIN\n  &lt;&lt;myLoopLabel1&gt;&gt;\n  LOOP\n    EXIT;\n  END LOOP myLoopLabel1;\n\n  LOOP\n    EXIT;\n  END LOOP;\nEND;\n/\n</pre>","debt":"5min"},{"summary":"Jump statements should not be followed by other statements","type":"Bug","defaultSeverity":"Major","description":"<p>Jump statements (<code>EXIT</code>, <code>CONTINUE</code>, <code>RETURN</code>, <code>RAISE</code>, and <code>RAISE_APPLICATION_ERROR</code>), move\ncontrol flow out of the current code block. Typically, any statements in a block that come after a jump are simply wasted keystrokes lying in wait to\nconfuse the unwary. </p>\n<p>This rule detects for statements that follow:</p>\n<ul>\n  <li> <code>EXIT</code> without a <code>WHEN</code> </li>\n  <li> <code>CONTINUE</code> without a <code>WHEN</code> </li>\n  <li> <code>RETURN</code> </li>\n  <li> <code>RAISE</code> </li>\n  <li> <code>RAISE_APPLICATION_ERROR</code> </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nBEGIN\n  LOOP\n    DBMS_OUTPUT.PUT_LINE('This will be printed out');\n    EXIT;\n\n    DBMS_OUTPUT.PUT_LINE('This will NEVER be printed out'); -- Non-Compliant\n  END LOOP;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nBEGIN\n  LOOP\n    DBMS_OUTPUT.PUT_LINE('This will be printed out');\n    EXIT;\n  END LOOP;\nEND;\n/\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.1 - There shall be no unreachable code </li>\n  <li> MISRA C++:2008, 0-1-1 - A project shall not contain unreachable code </li>\n  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code </li>\n  <li> MISRA C:2012, 2.1 - A project shall not contain unreachable code </li>\n  <li> MISRA C:2012, 2.2 - There shall be no dead code </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/561.html\">MITRE, CWE-561</a> - Dead Code </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/uQCSBg\">CERT, MSC56-J.</a> - Detect and remove superfluous code and values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/OYIyAQ\">CERT, MSC07-CPP.</a> - Detect and remove dead code </li>\n</ul>","debt":"30min"},{"summary":"Comments should not be located at the end of lines of code","type":"Code Smell","defaultSeverity":"Minor","description":"<p>This rule verifies that single-line comments are not located at the ends of lines of code. The main idea behind this rule is that in order to be\nreally readable, trailing comments would have to be properly written and formatted (correct alignment, no interference with the visual structure of\nthe code, not too long to be visible) but most often, automatic code formatters would not handle this correctly: the code would end up less readable.\nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\na := b + c; -- This is a trailing comment that can be very very long\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n-- This very long comment is better placed before the line of code\na := b + c;\n</pre>","debt":"1min"},{"summary":"Boolean literals should not be redundant","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Redundant Boolean literals should be removed from expressions to improve readability.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nSET SERVEROUTPUT ON\n\nDECLARE\n  foo BOOLEAN := TRUE;\nBEGIN\n  IF foo = FALSE THEN                     -- Noncompliant\n    DBMS_OUTPUT.PUT_LINE('foo = false!');\n  ELSIF foo = TRUE THEN                   -- Noncompliant\n    DBMS_OUTPUT.PUT_LINE('foo = true!');\n  END IF;\nEND;\n/\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nDECLARE\n  foo BOOLEAN := TRUE;\nBEGIN\n  IF NOT foo THEN                         -- Compliant\n    DBMS_OUTPUT.PUT_LINE('foo = false!');\n  ELSIF foo THEN                          -- Compliant\n    DBMS_OUTPUT.PUT_LINE('foo = true!');\n  END IF;\nEND;\n/\n</pre>","debt":"2min"},{"summary":"Failed unit tests should be fixed","type":"Bug","defaultSeverity":"Major","description":"Test failures or errors generally indicate that regressions have been introduced. Those tests should be handled as soon as possible to reduce the cost to fix the corresponding regressions."},{"summary":"Skipped unit tests should be either removed or fixed","type":"Code Smell","defaultSeverity":"Major","description":"Skipped unit tests are considered as dead code. Either they should be activated again (and updated) or they should be removed."},{"summary":"Source files should not have any duplicated blocks","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as there is at least one block of duplicated code on this file","debt":"10min"},{"summary":"Source files should have a sufficient density of comment lines","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the density of comment lines on this file is less than the required threshold. The number of comment lines to be written in order to reach the required threshold is provided by each issue message."},{"summary":"Lines should have sufficient coverage by tests","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the line coverage on this file is less than the required threshold. It gives the number of lines to be covered in order to reach the required threshold."},{"summary":"Branches should have sufficient coverage by tests","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the branch coverage on this file is less than the required threshold.It gives the number of branches to be covered in order to reach the required threshold."}]}