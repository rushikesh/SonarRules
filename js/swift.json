{"types":{"Vulnerability":3,"Code Smell":90,"Bug":14,"Other":0},"rules":[{"summary":"Track uses of \"TODO\" tags","type":"Code Smell","defaultSeverity":"Info","description":"<p><code>TODO</code> tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunc doSomething() {\n  // TODO\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"},{"summary":"Track uses of \"FIXME\" tags","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>FIXME</code> tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.</p>\n<p>Sometimes the developer will not have the time or will simply forget to get back to that tag.</p>\n<p>This rule is meant to track those tags and to ensure that they do not go unnoticed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunc divide(numerator:Int, denominator:Int) -&gt; Int {\n  return numerator / denominator              // FIXME denominator value might be  0\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/546.html\">MITRE, CWE-546</a> - Suspicious Comment </li>\n</ul>"},{"summary":"Enumeration types should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared naming conventions allow teams to collaborate efficiently. This rule checks that all <code>enum</code> names match a provided regular\nexpression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With default provided regular expression: <code>^[A-Z][a-zA-Z0-9]*</code></p>\n<pre>\nenum someEnumeration { // Non-Compliant\n    case Bar\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nenum SomeEnumeration {\n    case Bar\n}\n</pre>","debt":"5min"},{"summary":"Deprecated code should be removed","type":"Code Smell","defaultSeverity":"Info","description":"<p>This rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed.</p>\n<p>The following code illustrates this rule:</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class Foo {\n\n  @availability(*, deprecated=1.1)   // Noncompliant\n  public func bar() {\n  }\n\n  @availability(*, obsoleted=1.1)  // Noncompliant\n  public func baz() {\n  }\n}\n</pre>","debt":"10min"},{"summary":"Credentials should not be hard-coded","type":"Vulnerability","defaultSeverity":"Blocker","description":"<p>Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they're almost guaranteed to\nend up in the hands of an attacker. This is particularly true for applications that are distributed.</p>\n<p>Credentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar post:NSString = \"username=Steve&amp;password=123456\"  // Noncompliant\nvar postData:NSData = post.dataUsingEncoding(NSASCIIStringEncoding)!\n//...\nvar request:NSMutableURLRequest = NSMutableURLRequest(URL: url)\nrequest.HTTPBody = postData\n//...\nvar urlData: NSData? = NSURLConnection.sendSynchronousRequest(request, returningResponse:&amp;response, error:&amp;reponseError)\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar post:NSString = \"username=\\(getEncryptedUser())&amp;password=\\(getEncryptedPass())\"\nvar postData:NSData = post.dataUsingEncoding(NSASCIIStringEncoding)!\n//...\nvar request:NSMutableURLRequest = NSMutableURLRequest(URL: url)\nrequest.HTTPBody = postData\n//...\nvar urlData: NSData? = NSURLConnection.sendSynchronousRequest(request, returningResponse:&amp;response, error:&amp;reponseError)\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/798\">MITRE, CWE-798</a> - Use of Hard-coded Credentials </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/259\">MITRE, CWE-259</a> - Use of Hard-coded Password </li>\n  <li> <a href=\"http://www.sans.org/top25-software-errors/\">SANS Top 25</a> - Porous Defenses </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/qQCHAQ\">CERT, MSC03-J.</a> - Never hard code sensitive information </li>\n  <li> <a href=\"https://www.owasp.org/index.php/Top_10_2013-A2-Broken_Authentication_and_Session_Management\">OWASP Top Ten 2013 Category A2</a> -\n  Broken Authentication and Session Management </li>\n  <li> Derived from FindSecBugs rule <a href=\"http://h3xstream.github.io/find-sec-bugs/bugs.htm#HARD_CODE_PASSWORD\">Hard Coded Password</a> </li>\n</ul>","debt":"30min"},{"summary":"Enumeration members should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all enumeration member names match a provided regular\nexpression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With default provided regular expression: <code>^[a-z][a-zA-Z0-9]*$</code></p>\n<pre>\nenum SomeEnumeration {\n    case SomeMember  // Non-Compliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nenum SomeEnumeration {\n    case someMember\n}\n</pre>","debt":"5min"},{"summary":"Lines should not end with trailing whitespaces","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Trailing whitespaces are simply useless and should not stay in code. They may generate noise when comparing different versions of the same\nfile.</p>\n<p>If you encounter issues from this rule, this probably means that you are not using an automated code formatter - which you should if you have the\nopportunity to do so. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// Noncompliant; there are extra spaces after 'String'\nvar str:String\n</pre>","debt":"1min"},{"summary":"Fields and variables that are never updated should be constant","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Variables that are never updated will always return their default values and so they should be explicitly declared as constant. A\n<code>let</code>-declaration guarantees and clearly signals to the programmer that its value is supposed to and will never change.</p>\n<p>This rule applies to non-constant fields and variables which are not set within the codebase.</p>","debt":"2min"},{"summary":"Lines should not be too long","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.</p>","debt":"1min"},{"summary":"Tabulation characters should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Developers should not need to configure the tab width of their text editors in order to be able to read source code.</p>\n<p>So the use of the tabulation character must be banned.</p>","debt":"2min"},{"summary":"Files should not have too many lines of code","type":"Code Smell","defaultSeverity":"Major","description":"<p>A source file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to\nmaintain. Above a specific threshold, it is strongly advised to refactor it into smaller pieces of code which focus on well defined tasks. Those\nsmaller files will not only be easier to understand but also probably easier to test.</p>","debt":"1h"},{"summary":"Nested blocks of code should not be left empty","type":"Code Smell","defaultSeverity":"Major","description":"<p>Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (var i = 0; i &lt; 42; i++){}  // Empty on purpose or missing piece of code ?\n</pre>\n<h2>Exceptions</h2>\n<p>When a block contains a comment, this block is not considered to be empty.</p>","debt":"5min"},{"summary":"\"switch\" statements should have at least 3 \"case\" clauses","type":"Code Smell","defaultSeverity":"Minor","description":"<p><code>switch</code> statements are useful when there are many different cases depending on the value of the same expression.</p>\n<p>For just one or two cases however, the code will be more readable with <code>if</code> statements.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (variable) {\n  case 0:\n    doSomething();\n  default:\n    doSomethingElse();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (variable == 0) {\n  doSomething();\n} else {\n  doSomethingElse();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 15.5 - Every switch statement shall have at least one case clause. </li>\n  <li> MISRA C++:2008, 6-4-8 - Every switch statement shall have at least one case-clause. </li>\n  <li> MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses </li>\n</ul>","debt":"5min"},{"summary":"Functions should not be too complex","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The Cyclomatic Complexity of functions should not exceed a defined threshold. Complex code may perform poorly and can be difficult to test\nthoroughly.</p>","debt":"10min"},{"summary":"Unused \"private\" functions should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p><code>private</code> methods that are never executed are dead code: unnecessary, inoperative code that should be removed. Cleaning out dead code\ndecreases the size of the maintained codebase, making it easier to understand the program and preventing bugs from being introduced.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/OYIyAQ\">CERT, MSC07-CPP.</a> - Detect and remove dead code </li>\n</ul>","debt":"5min"},{"summary":"Functions should not contain too many return statements","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having too many return statements in a function increases the function's essential complexity because the flow of execution is broken each time a\nreturn statement is encountered. This makes it harder to read and understand the logic of the function.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold of 3:</p>\n<pre>\nfunc myMethod() -&gt; Bool { // Noncompliant as there are 4 return statements\n  if condition1 {\n    return true\n  } else {\n    if condition2 {\n      return false\n    } else {\n      return true\n    }\n  }\n  return false\n}\n</pre>","debt":"20min"},{"summary":"Modulus results should not be checked for direct equality","type":"Code Smell","defaultSeverity":"Critical","description":"<p>When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus of a variable for\nequality with a positive number (or a negative one) could result in unexpected results. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunc isOdd(x:Int) -&gt; Bool {\n  return x % 2 == 1  // Noncompliant; if x is negative, x % 2 == -1\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunc isOdd(x:Int) -&gt; Bool {\n  return x % 2 != 0\n}\n</pre>\n<p>or</p>\n<pre>\nfunc isOdd(x:Int) -&gt; Bool {\n  return abs(x % 2) == 1\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/xAHAAQ\">CERT, NUM51-J.</a> - Do not assume that the remainder operator always returns a\n  nonnegative result for integral operands </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NQBi\">CERT, INT10-C</a> - Do not assume a positive remainder when using the % operator\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/_YBLAQ\">CERT, INT10-CPP.</a> - Do not assume a positive remainder when using the %\n  operator </li>\n</ul>","debt":"5min"},{"summary":"Statements should be on separate lines","type":"Code Smell","defaultSeverity":"Major","description":"<p>For better readability, do not put more than one statement on a single line.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif someCondition { doSomething()}\n...\nvar result = doSomething(); return result\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif someCondition {\n  doSomething()\n}\n...\nvar result = doSomething()\nreturn result\n</pre>\n<h2>Exceptions</h2>\n<p>Variable declaration with initialising code block and closure expressions containing a single statement are ignored.</p>\n<pre>\nvar x : Int { return 0 }                                       // Variable declaration with initialising code block\ndoSomething({ (x: Int, y: Int) -&gt; Bool in return x &gt; y }, 5)   // Closure expression\n</pre>","debt":"1min"},{"summary":"Increment (++) and decrement (--) operators should not be used in a method call or mixed with other operators in an expression","type":"Code Smell","defaultSeverity":"Major","description":"<p>The use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:</p>\n<ul>\n  <li> It can significantly impair the readability of the code. </li>\n  <li> It introduces additional side effects into a statement, with the potential for undefined behavior. </li>\n  <li> It is safer to use these operators in isolation from any other arithmetic operators. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nu8a = ++u8b + u8c--\nfoo = bar++ / 4\n</pre>\n<h2>Compliant Solution</h2>\n<p>The following sequence is clearer and therefore safer:</p>\n<pre>\n++u8b\nu8a = u8b + u8c\nu8c--\nfoo = bar / 4\nbar++\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 12.1 - Limited dependence should be placed on the C operator precedence rules in expressions. </li>\n  <li> MISRA C:2004, 12.13 - The increment (++) and decrement (--) operators should not be mixed with other operators in an expression. </li>\n  <li> MISRA C++:2008, 5-2-10 - The increment (++) and decrement (--) operator should not be mixed with other operators in an expression. </li>\n  <li> MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit </li>\n  <li> MISRA C:2012, 13.3 - A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects\n  other than that cause by the increment or decrement operator </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/ZwE\">CERT, EXP30-C.</a> - Do not depend on the order of evaluation for side effects\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/fYAyAQ\">CERT, EXP50-CPP.</a> - Do not depend on the order of evaluation for side\n  effects </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/yQC7AQ\">CERT, EXP05-J.</a> - Do not follow a write by a subsequent write or read of the\n  same object within an expression </li>\n</ul>","debt":"5min"},{"summary":"The ternary operator should not return the same value regardless of the condition","type":"Bug","defaultSeverity":"Major","description":"<p>When the second and third operands of a ternary operator are the same, the operator will always return the same value regardless of the condition.\nEither the operator itself is pointless, or a mistake was made in coding it. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunc canVote(person:Person) -&gt; Bool {\n  return person.age &gt; 18 ? true : true // Noncompliant; is this what was intended?\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunc canVote(person:Person) -&gt; Bool {\n  return person.age &gt; 18 ? true : false\n}\n</pre>\n<h2>Deprecated</h2>\n<p>This rule is deprecated; use <a href='/coding_rules#rule_key=swift%3AS1871'>S1871</a> instead.</p>","debt":"5min"},{"summary":"\"switch\" statements should not be nested","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Nested <code>switch</code> structures are difficult to understand because you can easily confuse the cases of an inner <code>switch</code> as\nbelonging to an outer statement. Therefore nested <code>switch</code> statements should be avoided.</p>\n<p>Specifically, you should structure your code to avoid the need for nested <code>switch</code> statements, but if you cannot, then consider moving\nthe inner <code>switch</code> to another function.</p>","debt":"10min"},{"summary":"A field should not duplicate the name of its containing class","type":"Code Smell","defaultSeverity":"Major","description":"<p>It's confusing to have a class member with the same name (case differences aside) as its enclosing class. This is particularly so when you consider\nthe common practice of naming a class instance for the class itself.</p>\n<p>Best practice dictates that any field or member with the same name as the enclosing class be renamed to be more descriptive of the particular\naspect of the class it represents or holds.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class Foo {\n  private String foo;\n\n  public String getFoo() { }\n}\n\nFoo foo = new Foo();\nfoo.getFoo() // what does this return?\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class Foo {\n  private var name : String\n\n  public func getName() -&gt; String {\n      return name\n  }\n\n  //...\n\n}\n\nvar foo = Foo();\nfoo.getName()\n</pre>","debt":"10min"},{"summary":"Trailing closures should not begin on new lines","type":"Code Smell","defaultSeverity":"Minor","description":"<p>When the last argument to a function is a closure, it's possible and sometimes desirable to write that closure after the function's parentheses.\nThis is called a <em>trailing</em> closure. In order to help distinguish a trailing closure from an independent code block, it is best to begin the\nclosure on the same line as the function call.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunWithClosureArgument()\n{ // Noncompliant; looks like an independent code block\n   print(\"Hello world\")\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunWithClosureArgument() {\n   print(\"Hello world\")\n}\n</pre>","debt":"2min"},{"summary":"Protocol names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all\nprotocol names match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>^[A-Z][a-zA-Z0-9]*$</code>:</p>\n<pre>\npublic protocol myProtocol {...} // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic protocol MyProtocol {...}\n</pre>","debt":"10min"},{"summary":"Files should contain an empty new line at the end","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Some tools such as Git work better when files end with an empty line.</p>\n<p>This rule simply generates an issue if it is missing.</p>\n<p>For example, a Git diff looks like this if the empty line is missing at the end of the file:</p>\n<pre>\n+class Test {\n+}\n\\ No newline at end of file\n</pre>","debt":"1min"},{"summary":"Field names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that field\nnames match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>^[a-z][a-zA-Z0-9]*$</code>:</p>\n<pre>\nclass MyClass {\n  var MyField = 1\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass {\n  var myField = 1\n}\n</pre>","debt":"2min"},{"summary":"Constant names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions allow teams to collaborate efficiently. This rule checks that all constant names match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>^[a-z][a-zA-Z0-9]*$</code>:</p>\n<pre>\nlet Pi = 3.14\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlet pi = 3.14\n</pre>","debt":"2min"},{"summary":"Local variable and function parameter names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all local\nvariable and function parameter names match a provided regular expression.</p>","debt":"2min"},{"summary":"Type parameter names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared naming conventions make it possible for a team to collaborate efficiently. Following the established convention of single-letter type\nparameter names helps users and maintainers of your code quickly see the difference between a type parameter and a poorly named class.</p>\n<p>This rule check that all type parameter names match a provided regular expression. The following code snippets use the default regular\nexpression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default regular expression <code>^[A-Z]$</code>:</p>\n<pre>\npublic class MyClass&lt;TYPE&gt; {    // Noncompliant\n  func method&lt;TYPE&gt;(t : TYPE) { // Noncompliant\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class MyClass&lt;T&gt; {\n  func method&lt;T&gt;(t : T) {\n  }\n}\n</pre>","debt":"10min"},{"summary":"\"get\" should be omitted in read-only computed properties and subscripts","type":"Code Smell","defaultSeverity":"Minor","description":"<p>For read-only computed properties and subscript declarations, the <code>get</code> keyword and its braces are optional, and should be omitted for\nthe sake of brevity.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct Magic {\n  var number:Int {\n    get {  // Noncompliant\n      return 42\n    }\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct Magic {\n  var number:Int {\n    return 42\n  }\n}\n</pre>","debt":"2min"},{"summary":"Cognitive Complexity of functions should not be too high","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Cognitive Complexity is a measure of how hard the control flow of a function is to understand. Functions with high Cognitive Complexity will be\ndifficult to maintain.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://redirect.sonarsource.com/doc/cognitive-complexity.html\">Cognitive Complexity</a> </li>\n</ul>","debt":"5min"},{"summary":"\"self\" should only be used when required","type":"Code Smell","defaultSeverity":"Minor","description":"<p>The use of <code>self</code> is optional except when in closure expressions, and when it's needed to distinguish between property names and\narguments. For the sake of brevity, <code>self</code> should be omitted when it's not strictly required.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Car {\n  var color: Int\n\n  init(color: Int) {\n    self.color = color\n  }\n\n  func fade() {\n    self.color--  // Noncompliant\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Car {\n  var color: Int\n\n  init(color: Int) {\n    self.color = color\n  }\n\n  func fade() {\n    color--\n  }\n}\n</pre>","debt":"2min"},{"summary":"Jump statements should not be used unconditionally","type":"Bug","defaultSeverity":"Major","description":"<p>Having an unconditional <code>break</code>, <code>return</code> in a loop renders it useless; the loop will only execute once and the loop\nstructure itself is simply wasted keystrokes.</p>\n<p>Having an unconditional <code>continue</code> in a loop can render the loop meaningless, or is itself wasted keystrokes, depending on where in the\nloop it occurs.</p>\n<p>Having an unconditional <code>return</code> anywhere other than at the end of a function or method simply renders all the rest of the code in the\nmethod useless.</p>\n<p>For these reasons, unconditional jump statements should never be used except for the final <code>return</code> in a function.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar i:Int\nfor (i = 0; i &lt; 10; ++i) {\n    print(\"i is \\(i)\")\n    break  // loop only executes once\n}\n\nfor (i = 0; i &lt; 10; ++i) {\n    continue\n    print(\"i is \\(i)\")  // this is never executed\n}\n\nfor (i = 0; i &lt; 10; ++i) {\n    print(\"i is \\(i)\")\n    continue  // this is meaningless; the loop would continue anyway\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar i:Int\nfor (i = 0; i &lt; 10; ++i){\n    print(\"i is \\(i)\")\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.1 - There shall be no unreachable code. </li>\n  <li> MISRA C++:2008, 0-1-1 - A <em>project</em> shall not contain <em>unreachable code</em>. </li>\n  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code. </li>\n  <li> MISRA C:2012, 2.2 - There shall be no dead code </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C</a> - Detect and remove code that has no effect </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"5min"},{"summary":"Return values from functions without side effects should not be ignored","type":"Bug","defaultSeverity":"Major","description":"<p>When the call to a function doesn't have any side effects, what is the point of making the call if the results are ignored? In such case, either\nthe function call is useless and should be dropped or the source code doesn't behave as expected. </p>\n<p>This rule raises an issue on the following methods of the Swift standard library:</p>\n<ul>\n  <li> <code>abs</code> function </li>\n  <li> <code>signum</code> method </li>\n  <li> <code>distance</code> method </li>\n  <li> <code>advanced</code> method </li>\n  <li> <code>addingProduct</code> method </li>\n  <li> <code>squareRoot</code> method </li>\n  <li> <code>remainder</code>, <code>truncatingRemainder</code> methods </li>\n  <li> <code>rounded</code> method </li>\n  <li> <code>dropLast</code>, <code>drop</code>, <code>dropFirst</code> methods </li>\n  <li> <code>lowercased</code>, <code>uppercased</code> methods </li>\n  <li> <code>sorted</code>, <code>reversed</code> methods </li>\n  <li> <code>prefix</code>, <code>suffix</code> methods </li>\n</ul>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 17.7 - The value returned by a function having non-void return type shall be used </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/9YIRAQ\">CERT, EXP12-C.</a> - Do not ignore values returned by functions </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/eoAyAQ\">CERT, EXP12-CPP.</a> - Do not ignore values returned by functions or methods\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/9gEqAQ\">CERT, EXP00-J.</a> - Do not ignore values returned by methods </li>\n</ul>","debt":"10min"},{"summary":"Operators should be surrounded by whitespace in function definitions","type":"Code Smell","defaultSeverity":"Major","description":"<p>Surrounding your operators with whitespace in operator declarations will help maintainers derive meaning from what might otherwise look like a\nmeaningless jumble of punctuation.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunc &lt;*&gt;(a: MyClass, b: MyClass) -&gt; Boolean { // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunc &lt;*&gt; (a: MyClass, b: MyClass) -&gt; Boolean {\n</pre>","debt":"1min"},{"summary":"Two branches in a conditional structure should not have exactly the same implementation","type":"Code Smell","defaultSeverity":"Major","description":"<p>Having two <code>cases</code> in the same <code>switch</code> statement or branches in the same <code>if</code> structure with the same\nimplementation is at best duplicate code, and at worst a coding error. If the same logic is truly needed for both instances, then they should be\ncombined.</p>\n<p>Moreover when the second and third operands of a ternary operator are the same, the operator will always return the same value regardless of the\ncondition. Either the operator itself is pointless, or a mistake was made in coding it.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch i {\n  case 1:\n    doSomething()\n  case 2:\n    doSomethingDifferent()\n  case 3:  // Noncompliant; duplicates case 1's implementation\n    doSomething()\n  default:\n    doTheRest()\n}\n\nif a &gt;= 0 &amp;&amp; a &lt; 10 {\n  doTheThing()\n} else if a &gt;= 10 &amp;&amp; a &lt; 20 {\n  doTheOtherThing()\n} else if a &gt;= 20 &amp;&amp; a &lt; 50 {\n  doTheThing()  // Noncompliant; duplicates first condition\n} else {\n  doTheRest()\n}\n\nb = a ? 12 &gt; 4 : 4  // Noncompliant; always results in the same value\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch i {\n  case 1, 3:\n    doSomething()\n  case 2:\n    doSomethingDifferent()\n  default:\n    doTheRest()\n}\n\nif (a &gt;= 0 &amp;&amp; a &lt; 10) || (a &gt;= 20 &amp;&amp; a &lt; 50) {\n  doTheThing()\n} else if a &gt;= 10 &amp;&amp; a &lt; 20 {\n  doTheOtherThing()\n} else {\n  doTheRest()\n}\n\nb = 4\n</pre>\n<p>or </p>\n<pre>\nswitch i {\n  case 1:\n    doSomething()\n  case 2:\n    doSomethingDifferent()\n  case 3:\n    doThirdThing()\n  default:\n    doTheRest()\n}\n\nif a &gt;= 0 &amp;&amp; a &lt; 10 {\n  doTheThing()\n} else if a &gt;= 10 &amp;&amp; a &lt; 20 {\n  doTheOtherThing()\n} else if a &gt;= 20 &amp;&amp; a &lt; 50 {\n  doTheThirdThing()\n} else {\n  doTheRest()\n}\n\nb = a ? 12 &gt; 4 : 8\n</pre>\n<h2>Exceptions</h2>\n<p><code>case</code> labels that declare variables cannot have multiple patterns. Therefore this situation is ignored.</p>\n<pre>\nswitch a {\n    case .STR_CASE(let x):\n        print(x)\n    case .INT_CASE(let x):\n        print(x)\n    default:\n        print(\"default\")\n}\n</pre>","debt":"10min"},{"summary":"Backticks should not be used around symbol names","type":"Code Smell","defaultSeverity":"Major","description":"<p>You can't create a variable named \"for\". Unless you put backticks (<code>`</code>) around it.</p>\n<p>Since that would be the first step down a slippery slope of hopeless confusion, backticks should be removed from identifier names - whether they're\nkeywords or not - and the identifiers renamed as required.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar `for` = 1   // Noncompliant\nfor (var `in` = 0; `in` &lt; 10 &amp;&amp; `for` &gt; 0; `in`++) {  // Noncompliant\n  // ...\n}\n\nvar `x` = \"hello\"  // Noncompliant; why would you do this?\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar i = a\nfor (var j=0; j&lt; 10; j++) {\n  // ...\n}\n\nvar x = \"hello\"\n</pre>\n<h2>Exceptions</h2>\n<p>When Objective-C libraries are used in Swift, backticks may be needed around parameter names which are keywords in Swift but not in Objective C.\nTherefore this rule ignores backticks around parameter names.</p>\n<pre>\nvar protectionSpace: NSURLProtectionSpace = NSURLProtectionSpace(\n  host: host,\n  port: port,\n  `protocol`: prot,  // Compliant\n  realm: nil,\n  authenticationMethod: authenticationMethod\n);\n</pre>","debt":"1min"},{"summary":"Redundant pairs of parentheses should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>Useless parentheses can sometimes be misleading and so should be removed. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nreturn ((x + 1))       // Noncompliant\nvar x = ((y / 2 + 1))  // Noncompliant\nif ((x &gt; 0)) { ... }   // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nreturn (x + 1)\nreturn x + 1\nvar x = (y / 2 + 1)\nvar x = y / 2 + 1\nif (x &gt; 0) { ... }\nif x &gt; 0 { ... }\n</pre>","debt":"1min"},{"summary":"Tuples should not be too large","type":"Code Smell","defaultSeverity":"Minor","description":"<p>An unordered pair is easy to handle, but the longer an unordered set gets, the harder it is to deal with.</p>\n<p>This rule raises an issue when a tuple of more than the allowed number of elements is returned.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold of 2</p>\n<pre>\nfunc doTheThing() -&gt; (Int, Int, Int) {}  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunc doTheThing() -&gt; MyIntStruct {}\n</pre>","debt":"10min"},{"summary":"URIs should not be hardcoded","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Hard coding a URI makes it difficult to test a program: path literals are not always portable across operating systems, a given absolute path may\nnot exist on a specific test environment, a specified Internet URL may not be available when executing the tests, production environment filesystems\nusually differ from the development environment, ...etc. For all those reasons, a URI should never be hard coded. Instead, it should be replaced by\ncustomizable parameter.</p>\n<p>Further even if the elements of a URI are obtained dynamically, portability can still be limited if the path-delimiters are hard-coded.</p>\n<p>This rule raises an issue when URI's or path delimiters are hard coded.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class Foo {\n    public func listUsers() -&gt; [User] {\n        var users:[User]\n        let location = \"/home/mylogin/Dev/users.txt\"     // Non-Compliant\n        let fileContent = NSString(contentsOfFile: location, encoding: NSUTF8StringEncoding, error: nil)\n        users = parse(fileContent!)\n        return users\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class Foo {\n    // Configuration is a class that returns customizable properties: it can be mocked to be injected during tests.\n    private var config:Configuration\n    public init(myConfig:Configuration) {\n        config = myConfig\n    }\n    public func listUsers() -&gt; [User] {\n        var users:[User]\n        // Find here the way to get the correct folder, in this case using the Configuration object\n        let location = config.getProperty(\"myApplication.listingFile\")\n        // and use this parameter instead of the hard coded path\n        let fileContent = NSString(contentsOfFile: location, encoding: NSUTF8StringEncoding, error: nil)\n        users = parse(fileContent!)\n        return users\n    }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/qQCHAQ\">CERT, MSC03-J.</a> - Never hard code sensitive information </li>\n</ul>","debt":"20min"},{"summary":"Function type parameters should come at the end of the parameter list","type":"Code Smell","defaultSeverity":"Major","description":"<p>Trailing closure syntax can only be used with the last argument to a function call. Place a function type parameter anywhere else in the list and\nyou limit the options of the caller.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunc foo(p1: Int-&gt;Int, p2: Int){  // Noncompliant; p1 should come at the end\n  print(p1(p2))\n}\n\nfoo({a in a * 2}, 42) // Trailing closure syntax can't be used here\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunc foo(p2: Int, p1: Int-&gt;Int){\n  print(p1(p2))\n}\n\nfoo(42) {a in a * 2}\n</pre>","debt":"5min"},{"summary":"Trailing closure syntax should be used for the last argument","type":"Code Smell","defaultSeverity":"Minor","description":"<p>The use of trailing closure syntax can make code clearer, but it should only be used when the call only requires a single function type\nparameter.</p>\n<p>This rule raises an issue when trailing closure syntax is not used for the last argument in a call that requires only a single function type\nparameter.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nUIView.animateWithDuration(1.0, animations: {  // Noncompliant\n  self.myView.alpha = 0\n})\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nUIView.animateWithDuration(1.0) {\n  self.myView.alpha = 0\n}\n</pre>","debt":"5min"},{"summary":"Optionals should not be force-unwrapped","type":"Bug","defaultSeverity":"Minor","description":"<p>The point of declaring an optional variable is to make explicit the fact that it might contain no valid value, i.e. <code>nil</code>.\nForce-unwrapping an optional will lead to a runtime error if the optional does contain <code>nil</code>. Even if the value is tested first, it's still\nconsidered a bad practice to use force-unwrapping. Instead, optional binding or optional chaining should be used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar greeting: String?\n\n// ...\nprintln( \\(greeting!))  // Noncompliant; could cause a runtime error\n\nif greeting != nil {\n  println( \\(greeting!))  // Noncompliant; better but still not great\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar greeting: String?\n\n// ...\nif let howdy = greeting {\n  println(howdy)\n}\n</pre>","debt":"15min"},{"summary":"Implicitly unwrapped optionals should not be used","type":"Bug","defaultSeverity":"Critical","description":"<p>The point of using an optional is to signal that the value may be <code>nil</code> and to provide graceful ways of dealing with it if it is\n<code>nil</code>. While implicitly unwrapped optionals still provide means of dealing with <code>nil</code> values, they also signal that the value\nwon't be <code>nil</code>, and unwrap it automatically. In addition to sending a decidedly mixed signal, this could lead to runtime errors if the\nvalue ever is <code>nil</code>. </p>\n<p>It is safest, and clearest to use either an optional or a plain type and avoid the boggy middle ground of implicitly unwrapped optionals.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar greeting : String!  // Noncompliant\n\nprintln(greeting)  // At this point the value is nil. Runtime error results\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar greeting : String?\n\nif let howdy = greeting {\n  println(howdy)\n}\n</pre>","debt":"15min"},{"summary":"Local variables should not have the same name as fields or \"enum\" cases","type":"Code Smell","defaultSeverity":"Major","description":"<p>Shadowing fields or <code>enum</code> <code>case</code>s with a local variable is a bad practice that reduces code readability: It makes it\nconfusing to know whether the field or the variable is being used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class Foo {\n  public var myField:Int = 0\n\n  public func doSomething() {\n    var myField = 0\n    ...\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/2ADEAw\">CERT, DCL51-J.</a> - Do not shadow or obscure identifiers in subscopes </li>\n</ul>","debt":"5min"},{"summary":"Types should be defined in separate source files","type":"Code Smell","defaultSeverity":"Major","description":"<p>A file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain. This\nis doubly true for a file with multiple independent classes, extensions, protocols, enumerations or structures. It is strongly advised to define each\nindividual type in separate source file.</p>\n<h2>Exceptions</h2>\n<p>The case when file contains only class and its extensions is ignored.</p>\n<pre>\nclass MyViewController: UIViewController {\n  // class stuff here\n}\n\nextension MyViewController: UITableViewDataSource {\n  // table view data source methods\n}\n\nextension MyViewController: UIScrollViewDelegate {\n  // scroll view delegate methods\n}\n</pre>"},{"summary":"Files should not be too complex","type":"Code Smell","defaultSeverity":"Major","description":"<p>Most of the time, a very complex file breaks the Single Responsibility Principle and should be re-factored into several different files.</p>\n<h2>Deprecated</h2>\n<p>This rule is deprecated, and will eventually be removed.</p>","debt":"30min"},{"summary":"Classes should not have too many lines of code","type":"Code Smell","defaultSeverity":"Major","description":"<p>A class that grows too much tends to aggregate too many responsibilities, and inevitably becomes harder to understand and to maintain. Above a\nspecific threshold, it is strongly advised to refactor the class into smaller ones which focus on well-defined topics.</p>\n<p>This rule raises an issue when classes, structs, or enums have more than the allowed number of lines.</p>","debt":"1h"},{"summary":"\"IBOutlet\" variables should be private","type":"Code Smell","defaultSeverity":"Major","description":"<p>Marking a variable with <code>IBOutlet</code> allows it to be connected with a Storyboard component through the Interface Builder. Allowing such a\nvariable to be accessed outside the class, may result in other classes making assignments that override the automatic dependency injection from the\nStoryboard itself.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n  @IBOutlet var label: UILabel!  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n  @IBOutlet private var label: UILabel!\n</pre>","debt":"5min"},{"summary":"\"IBInspectable\" should be used correctly","type":"Code Smell","defaultSeverity":"Major","description":"<p>Adding <code>IBInspectable</code> to a properly-typed variable makes it available in Xcode's Interface Builder. But that only works if variable\ntype is declared explicitly as one of the following: </p>\n<ul>\n  <li> <code>Int</code> types, <code>Double</code>, <code>Float</code>, <code>Bool</code> </li>\n  <li> <code>String</code> (or its optional) </li>\n  <li> <code>CGFloat</code>, <code>CGPoint</code>, <code>CGSize</code>, <code>CGRect</code> </li>\n  <li> <code>UIColor</code>, <code>UIImage</code> (and their optionals) </li>\n  <li> <code>NSString</code>, <code>NSColor</code>, <code>NSImage</code> (and their optionals) </li>\n  <li> <code>NSRect</code>, <code>NSPoint</code>, <code>NSSize</code>, </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\n@IBInspectable  // Noncompliant; type is implicit\npublic var cornerRadius = 2.0 {\n  didSet {\n     //...\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n@IBInspectable\npublic var cornerRadius: CGFloat  = 2.0 {\n  didSet {\n     //...\n  }\n}\n</pre>","debt":"5min"},{"summary":"Identical expressions should not be used on both sides of a binary operator","type":"Bug","defaultSeverity":"Major","description":"<p>Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste\nerror and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical\noperators, having the same value on both sides of an operator yields predictable results, and should be simplified.</p>\n<p>This rule ignores <code>*</code>, <code>+</code>. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif a == a { // always true\n  doZ()\n}\nif  a != a  { // always false\n  doY()\n}\nif a == b &amp;&amp; a == b { // if the first one is true, the second one is too\n  doX()\n}\nif a == b || a == b { // if the first one is true, the second one is too\n  doW()\n}\n\nvar j = 5 / 5 //always 1\nvar k = 5 - 5 //always 0\n</pre>\n<h2>Exceptions</h2>\n<p>Left-shifting 1 onto 1 is common in the construction of bit masks, and is ignored.</p>\n<pre>\nvar i = 1 &lt;&lt; 1; // Compliant\nvar j = a &lt;&lt; a; // Noncompliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C</a> - Detect and remove code that has no effect </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP</a> - Detect and remove code that has no effect. </li>\n</ul>","debt":"2min"},{"summary":"\"struct\" names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all <code>struct</code> names match a provided\nregular expression.</p>\n<p>Using the default regular expression: \"^[A-Z][a-zA-Z0-9]*$\"</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstruct my_struct {\n    var one : Int\n    var two : Int\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstruct MyStruct {\n    var one : Int\n    var two : Int\n}\n</pre>","debt":"10min"},{"summary":"Jump statements should not be followed by other statements","type":"Bug","defaultSeverity":"Major","description":"<p>Jump statements (<code>return</code>, <code>break</code>, <code>continue</code>, and <code>fallthrough</code>) move control flow out of the current\ncode block. Typically, any statements in a block that come after a jump are simply wasted keystrokes lying in wait to confuse the unwary. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunc fun(a:Int)-&gt;Int{\n  var i = 10;\n  return i + a;\n  i++;             // this is never executed\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunc fun(a:Int)-&gt;Int{\n  var i = 10;\n  return i + a;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.1 - There shall be no unreachable code </li>\n  <li> MISRA C++:2008, 0-1-1 - A project shall not contain unreachable code </li>\n  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code </li>\n  <li> MISRA C:2012, 2.1 - A project shall not contain unreachable code </li>\n  <li> MISRA C:2012, 2.2 - There shall be no dead code </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/561.html\">MITRE, CWE-561</a> - Dead Code </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/uQCSBg\">CERT, MSC56-J.</a> - Detect and remove superfluous code and values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/OYIyAQ\">CERT, MSC07-CPP.</a> - Detect and remove dead code </li>\n</ul>","debt":"5min"},{"summary":"Floating point numbers should not be tested for equality","type":"Bug","defaultSeverity":"Major","description":"<p>Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a <code>Float</code> or a <code>Double</code> through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.</p>\n<p>Even simple floating point assignments are not simple:</p>\n<pre>\nvar f: Float = 0.1 // 0.1000000014901161193847656\nvar d: Double = 0.1 // 0.1000000000000000055511151\n</pre>\n<p>Therefore, the use of the equality (<code>==</code>) and inequality (<code>!=</code>) operators on <code>Float</code> or <code>Double</code> values\nis almost always an error. </p>\n<p>This rule checks for the use of direct and indirect equality/inequailty tests on floats and doubles.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar myNumber: Float = 0.3 + 0.6\n\nif myNumber == 0.9 { // Noncompliant. Because of floating point imprecision, this will be false\n    // ...\n}\n\nif myNumber &lt;= 0.9 &amp;&amp; myNumber &gt;= 0.9 { // Noncompliant indirect equality test\n  // ...\n}\n\nif myNumber &lt; 0.9 || myNumber &gt; 0.9 { // Noncompliant indirect inequality test\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality. </li>\n  <li> MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality </li>\n</ul>","debt":"5min"},{"summary":"Parentheses should be omitted when trailing closure is the only argument","type":"Code Smell","defaultSeverity":"Minor","description":"<p>If a closure expression is provided as the function or method’s only argument and you provide that expression as a trailing closure, you do not\nneed to write a pair of parentheses () after the function or method’s name when you call the function. This makes the code somewhat easier to\nread.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nreversedNames = names.sorted() { $0 &gt; $1 } // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\neversedNames = names.sorted { $0 &gt; $1 }\n</pre>","debt":"1min"},{"summary":"Class names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all class\nnames match a provided regular expression.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With default provided regular expression <code>^[A-Z][a-zA-Z0-9]*$</code>:</p>\n<pre>\nclass my_class {...}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass {...}\n</pre>","debt":"5min"},{"summary":"Function names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared naming conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.</p>","debt":"5min"},{"summary":"\"try!\" should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The use of Swift 2.0's <code>try!</code> lets you execute code that might throw an exception without using the <code>do</code> and\n<code>catch</code> syntax normally required for such code. By using it, you're guaranteeing that the executed code will never fail. Murphy's Law\nguarantees you're wrong. And when it does fail, the program will exit abruptly, probably without cleaning up after itself.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlet myvar = try! dangerousCode(foo);  // Noncompliant\n// ...\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ndo {\n  let myvar = try dangerousCode(foo);\n  // ...\n} catch {\n  // handle error\n}\n</pre>","debt":"10min"},{"summary":"Unused local variables should be removed","type":"Code Smell","defaultSeverity":"Minor","description":"<p>If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will\nnot wonder what the variable is used for.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic func numberOfMinutes(hours:Int) -&gt; Int {\n  var seconds = 0   // seconds is never used\n  return hours * 60;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic func numberOfMinutes(hours:Int) -&gt; Int{\n  return hours * 60\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Simple <code>for-in</code> loop counters are ignored by this rule because while they are often legitimately unused, their declaration is required\nby the syntax.</p>\n<pre>\nfor i in 1...10 {  // Ignored\n  print(\"Hello! \");\n}\n\nfor (a, b) in someElements {  // Noncompliant; b unused\n  print(a)\n}\n</pre>","debt":"5min"},{"summary":"Underscores should be used to make large numbers readable","type":"Code Smell","defaultSeverity":"Minor","description":"<p>In Swift it is possible to add underscores ('_') to numeric literals to enhance readability. The addition of underscores in this manner has no\nsemantic meaning, but makes it easier for maintainers to understand the code.</p>\n<p>The number of digits to the left of a decimal point needed to trigger this rule varies by base.</p>\n<table>\n  <tbody>\n    <tr>\n      <th>Base</th>\n      <th> Minimum digits</th>\n    </tr>\n    <tr>\n      <td>binary</td>\n      <td> 9 </td>\n    </tr>\n    <tr>\n      <td>decimal</td>\n      <td> 6 </td>\n    </tr>\n    <tr>\n      <td>octal</td>\n      <td> 9 </td>\n    </tr>\n    <tr>\n      <td>hexadecimal</td>\n      <td> 9 </td>\n    </tr>\n  </tbody>\n</table>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlet i = 10000000  // Noncompliant; is this 10 million or 100 million?\nlet j = 0b01101001010011011110010101011110  // Noncompliant\nlet l = 0x7fffffffffffffff  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlet i = 10_000_000\nlet j = 0b01101001_01001101_11100101_01011110\nlet l = 0x7fff_ffff_ffff_ffff\n</pre>","debt":"5min"},{"summary":"Track lack of copyright and license headers","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Each source file should start with a header stating file ownership and the license which must be used to distribute the application. </p>\n<p>This rule must be fed with the header text that is expected at the beginning of every file.</p>\n<h2>Compliant Solution</h2>\n<pre>\n/*\n * SonarQube, open source software quality management tool.\n * Copyright (C) 2008-2013 SonarSource\n * mailto:contact AT sonarsource DOT com\n *\n * SonarQube is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * SonarQube is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n</pre>","debt":"5min"},{"summary":"Force casts should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>Because force casting (<code>as!</code>) does not perform any type safety validations, it is capable of performing dangerous conversions between\nunrelated types. When the types are truly unrelated, the cast will cause a system crash.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfoo as! MyClass  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfoo as? MyClass\n</pre>\n<h2>See</h2>\n<ul>\n  <li> CppCoreGuidelines, Type safety profile - Type.1: Don't use reinterpret_cast. </li>\n</ul>","debt":"20min"},{"summary":"Infix operators that end with \"=\" should update their left operands","type":"Bug","defaultSeverity":"Major","description":"<p>The conventional expectation of operators that end with <code>=</code>, such as <code>+=</code>, <code>-=</code>, <code>*=</code>, and so on, is\nthat the result of the operation will be assigned to the operand on the left-hand side of the operator.</p>\n<p>Define any other behavior and you almost guarantee that the users of your code will misunderstand and therefore misuse your operator.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunc **= (p1:Int, p2:Int) -&gt; Int {   // Noncompliant. Change operator name or update value of first parameter\n    return p1 ** p2\n}\n\nfunc =&gt; (p1:Int, p2:Int) -&gt; Int {  // Compliant; doesn't end with '='\n    return p1 ** p1 ** p2\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunc **= (inout p1:Int, p2:Int) {\n    p1 = p1 ** p2\n}\n\nfunc =&gt; (p1:Int, p2:Int) -&gt; Int {\n    return p1 ** p1 ** p2\n}\n</pre>","debt":"15min"},{"summary":"Conditional compilation should not be used","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Conditional compilation is generally recognized as a bad practice that is occasionally necessary when dealing with platform-specific code. As much\nas possible, code should be refactored to minimize or eliminate conditionally-compiled, platform-specific code because even when necessary and\nwell-intentioned, such code segments can leave your codebase in a hopeless tangle.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n#if os(OSX) // Noncompliant\n    let a = 2\n#else\n    let a = 3\n#endif\n</pre>","debt":"30min"},{"summary":"Files should not be empty","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Files with no lines of code clutter a project and should be removed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n//import Foundation\n//\n//public class Bar {}\n</pre>","debt":"5min"},{"summary":"Dead stores should be removed","type":"Bug","defaultSeverity":"Major","description":"<p>A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value\nonly to then overwrite it or throw it away, could indicate a serious error in the code. Even if it's not an error, it is at best a waste of resources.\nTherefore all calculated values should be used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunc calculateRate(a:Int, b:Int) {\n  var i:Int\n\n  i = a + b // Noncompliant; calculation result not used before value is overwritten\n  i = doSomething()  // Noncompliant; retrieved value not used\n  for i = 0; i &lt; 10; i++ {\n    //  ...\n  }\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunc calculateRate(a:Int, b:Int) {\n  var i:Int\n\n  i = doSomething()\n  i += a + b\n  storeI(i)\n\n  for i = 0; i &lt; 10; i++ {\n    //  ...\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/563.html\">MITRE, CWE-563</a> - Assignment to Variable without Use ('Unused Variable') </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/QYA5\">CERT, MSC13-C.</a> - Detect and remove unused values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/S4IyAQ\">CERT, MSC13-CPP.</a> - Detect and remove unused values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/uQCSBg\">CERT, MSC56-J.</a> - Detect and remove superfluous code and values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"15min"},{"summary":"Unused function parameters should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunc doSomething(a: Int, b: Int) {     // \"b\" is unused\n  compute(a)\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid doSomething(a: Int) {\n  compute(a)\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Override methods are excluded.</p>\n<pre>\noverride doSomething(a: Int, b: Int) {     // no issue reported on b\n  compute(a)\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. </li>\n  <li> MISRA C:2012, 2.7 - There should be no unused parameters in functions </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"5min"},{"summary":"Track parsing failures","type":"Code Smell","defaultSeverity":"Major","description":"<p>When the parser fails, it is possible to record the failure as an issue on the file. This way, not only is it possible to track the number of files\nthat do not parse but also to easily find out why they do not parse.</p>","debt":"30min"},{"summary":"\"break\" should be the only statement in a \"case\"","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Because <code>case</code> statements in a Swift <code>switch</code> do not fall through, there is no need to use <code>break</code> at the end of a\n<code>case</code> unless it would otherwise be empty. Since an empty <code>case</code> isn't allowed, an explicit <code>break</code> is needed to make\nsuch code compilable. There is no other reason to use <code>break</code> in a <code>case</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch weekday {\n  case sunday:\n    break\n  case monday:\n    getUpEarly()\n    break  // Noncompliant\n  case tuesday\n    // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch weekday {\n  case sunday:\n    break\n  case monday:\n    getUpEarly()\n  case tuesday\n    // ...\n}\n</pre>","debt":"2min"},{"summary":"Related \"if/else if\" statements and \"cases\" in a \"switch\" should not have the same condition","type":"Bug","defaultSeverity":"Major","description":"<p>A <code>switch</code> and a chain of <code>if</code>/<code>else if</code> statements is evaluated from top to bottom. At most, only one branch will\nbe executed: the first one with a condition that evaluates to <code>true</code>. </p>\n<p>Therefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it's simply dead code and\nat worst, it's a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif param == 1 {\n  openWindow()\n} else if param == 2 {\n  closeWindow()\n} else if param == 1 {            // Noncompliant\n  moveWindowToTheBackground()\n}\n\nswitch i {\n  case 1:\n    //...\n  case 3:\n    //...\n  case 1:                         // Noncompliant\n    //...\n  default:\n    // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif param == 1 {\n  openWindow()\n} else if param == 2 {\n  closeWindow()\n} else if param == 3 {\n  moveWindowToTheBackground()\n}\n\nswitch i {\n  case 1:\n    //...\n  case 3:\n    //...\n  default:\n    // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"10min"},{"summary":"Functions should not return constants","type":"Code Smell","defaultSeverity":"Minor","description":"<p>There's no point in forcing the overhead of a function or method call for a function that always returns the same constant value. Even worse, the\nfact that a function call must be made will likely mislead developers who call the method thinking that something more is done. Declare a constant\ninstead. </p>\n<p>This rule raises an issue on functions that contain only one statement: the <code>return</code> of a constant value. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunc getBestNumber() -&gt; Int {\n  return 12  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlet bestNumber = 12;\n</pre>\n<h2>Exceptions</h2>\n<p>Methods which are members of a class having a type inheritance clause are ignored.</p>","debt":"5min"},{"summary":"Access control should be specified for top-level definitions","type":"Vulnerability","defaultSeverity":"Minor","description":"<p>The access level defaults to <code>internal</code> if left unspecified. Since that doesn't make sense for most top-level declarations, access\nlevels should always be specified explicitly, even when <code>internal</code> is what's intended.</p>\n<p>This rule raises an issue when the access level is not specified on any top-level declaration.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Foo {  // Noncompliant\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class Foo {\n  // ...\n}\n</pre>","debt":"5min"},{"summary":"Expressions should not be too complex","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The complexity of an expression is defined by the number of <code>&amp;&amp;</code>, <code>||</code> and <code>condition ? ifTrue : ifFalse</code>\noperators it contains.</p>\n<p>A single expression's complexity should not become too high to keep the code readable.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold value 3</p>\n<pre>\n  if ((condition1 &amp;&amp; condition2) || (condition3 &amp;&amp; condition4)) &amp;&amp; condition5 { ... }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n  if (myFirstCondition() || mySecondCondition()) &amp;&amp; myLastCondition() { ... }\n</pre>","debt":"5min"},{"summary":"Closures should not have too many lines","type":"Code Smell","defaultSeverity":"Major","description":"<p>Closures are a very convenient and compact way to inject a behaviour without having to create a dedicated function. But those closures should be\nused only if the behaviour to be injected can be defined in a few lines of code, otherwise the source code can quickly become unreadable.</p>","debt":"20min"},{"summary":"Collapsible \"if\" statements should be merged","type":"Code Smell","defaultSeverity":"Major","description":"<p>Merging collapsible <code>if</code> statements increases the code's readability.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif condition1 {\n  if condition2 {\n    doSomething()\n  }\n}\n\nif let y = someOptional {\n  if x &gt; 0 {\n    doSomething()\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif condition1 &amp;&amp; condition2 {\n  doSomething()\n}\n\nif let y = someOptional where x &gt; 0 {\n  doSomething()\n}\n\nif x &gt; 0, let y = someOptional {\n  doSomething()\n}\n</pre>","debt":"5min"},{"summary":"Unused labels should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>If a label is declared but not used in the program, it can be considered as dead code and should therefore be removed.</p>\n<p>This will improve maintainability as developers will not wonder what this label is used for.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nwhileLoopLabel: while x &gt; 0 {    // Noncompliant\n    x -= 1\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nwhile x &gt; 0 {\n    x -= 1\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 2.6 - A function should not contain unused label declarations </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>","debt":"2min"},{"summary":"Functions and closures should not be empty","type":"Code Smell","defaultSeverity":"Critical","description":"<p>There are several reasons for a function or closure not to have a body:</p>\n<ul>\n  <li> It is an unintentional omission, and should be fixed to prevent unexpected behavior in production. </li>\n  <li> It is not yet, or never will be, supported. In this case an exception should be thrown. </li>\n  <li> The function is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunc fun(p1:Int) {\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunc fun(p1:Int) {\n  var a = doSomething(p1)\n  var threshold = 42\n  if a &gt; threshold {\n    // ...\n  }\n}\n</pre>\n<p>or </p>\n<pre>\nfunc fun(p1:Int) {\n  // Intentionally unimplemented...\n}\n</pre>","debt":"5min"},{"summary":"Statements should not end with semicolons","type":"Code Smell","defaultSeverity":"Minor","description":"<p>The semicolon (<code>;</code>) is optional as a statement separator except in traditional <code>for</code> loops and when several statements are\ncombined on one line (which is a bad practice). For cleaner code, semicolons should be omitted.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint a;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint a\n</pre>","debt":"1min"},{"summary":"A close curly brace should be located at the beginning of a line","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Shared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the\nbeginning of a line.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif condition {\n  doSomething()}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif condition {\n  doSomething()\n}\n</pre>\n<h2>Exceptions</h2>\n<p>When blocks are inlined (open and close curly braces on the same line), no issue is triggered.</p>\n<pre>\nif condition {doSomething()}\n</pre>","debt":"1min"},{"summary":"\"return\" should be omitted from single-expression closures","type":"Code Smell","defaultSeverity":"Minor","description":"<p>When a closure contains only a <code>return</code> statement, the <code>return</code> itself can be omitted.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nsomeList.sort { a, b in\n  return a &gt; b\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nsomeList.sort { a, b in a &gt; b }\n</pre>","debt":"2min"},{"summary":"Trailing closure syntax should not be used when multiple parameters are of function type","type":"Code Smell","defaultSeverity":"Major","description":"<p>Using trailing closure syntax for the last parameter in a call is often the most elegant way to handle it. But if the call requires multiple\nfunction-type arguments, the use of a trailing closure can be messy and confusing. In such cases, it's better to pass closure expressions as normal\narguments.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar x = complexOperation(\n  arg: 2,\n  op1: {$0 + 10}\n) {$0 * $0}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar x = complexOperation(\n  arg: 2,\n  op1: {$0 + 10},\n  op2: {$0 * $0}\n)\n</pre>","debt":"5min"},{"summary":"An open curly brace should be located at the end of a line","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Sharing some coding conventions is a key point to make it possible for a team to efficiently collaborate. This rule makes it mandatory to place\nopen curly braces at the end of lines of code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif condition\n{\n  doSomething()\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif condition {\n  doSomething()\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Closure and inlined blocks (left and right curly braces on the same line) are ignored by this rule. </p>\n<pre>\nif condition {doSomething()} // Compliant\nreversed = sorted(\n    names,\n    { (s1: String, s2: String) -&gt; Bool in  // Compliant\n        return s1 &gt; s2\n    })\n</pre>","debt":"1min"},{"summary":"Operator functions should call existing functions","type":"Code Smell","defaultSeverity":"Minor","description":"<p>Making an operator a convenience wrapper around an existing function or method provides additional flexibility to users in how the functionality is\ncalled and in what options are passed in.</p>\n<p>This rule raises an issue when the function that defines the operation of a operator consists of something other than a single function call.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ninfix operator &gt;&lt; { associativity right precedence 90 }\nfunc &gt;&lt; (left: Double, right: Double) -&gt; Double {  // Noncompliant\n  let leftD = (left % 1) * 100\n  let rightD = (right % 1) * 100\n  let leftW = (left - leftD) / 100\n  let rightW = (right - rightD) / 100\n  return (leftD + leftW) * (rightD + rightW)\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ninfix operator &gt;&lt; { associativity right precedence 90 }\nfunc &gt;&lt; (left: Double, right: Double) -&gt; Double {\n  return fubar(left, right)\n}\n\nfunc fubar(left: Double, right: Double) -&gt; Double {\n  let leftD = (left % 1) * 100\n  let rightD = (right % 1) * 100\n  let leftW = (left - leftD) / 100\n  let rightW = (right - rightD) / 100\n  return (leftD + leftW) * (rightD + rightW)\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Operators that end with <code>=</code> are expected to update their left-hand operands, and are therefore ignored.</p>\n<pre>\nfunc **= (inout p1:Int, p2:Int) {\n    p1 = p1 ** p2\n}\n</pre>","debt":"5min"},{"summary":"Closure expressions should not be nested too deeply","type":"Code Smell","defaultSeverity":"Major","description":"<p>The point of using closure expressions is to clearly express a succinct bit of logic. Start nesting closure expressions too deeply and you create a\nlogic snarl that will likely snare both you and future maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the maximum depth of 2:</p>\n<pre>\nfoo(42) { (x: Int) in\n    bar(x) { (x: Int) in\n      foobar(x) { // Noncompliant\n        print(x * 42)\n      }\n      print(x + 42)\n    }\n    print(x - 42)\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunc multPlus(x:Int) {\n  foobar(x) {\n    print(x * 42)\n  }\n  print(x + 42)\n}\n\nfoo(42) { (x: Int) in\n    bar(x, multPlus)\n    print(x - 42)\n}\n</pre>","debt":"15min"},{"summary":"Filter conditions should be used as predicates to \"first\"","type":"Code Smell","defaultSeverity":"Major","description":"<p>If you only want one instance that matches certain criteria out of a collection, it's far more efficient to grab the first matching item than it is\nto fully filter the collection for your criteria and then only use a single value.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlet one = arr.filter { $0.containsString(\"yo\") }.first  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlet one = arr.first(where: { $0.containsString(\"yo\") })\n</pre>","debt":"5min"},{"summary":"Precedence and associativity of standard operators should not be changed","type":"Bug","defaultSeverity":"Major","description":"<p>It is acceptable to override standard operators to provide appropriate behaviors for your classes. But it is not appropriate to change those\noperators' associativity or precedence from the standard. Doing so will inevitably lead to misuse and mistakes for users of the class.</p>\n<p>Instead of overriding an existing operator's associativity or precedence, you should either let them use the default values or define a completely\nnew operator.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ninfix operator - {associativity right precedence 140}  // Noncompliant. For a different behavior create a different operator\nfunc - (lhs: MyInt, rhs: MyInt) -&gt; MyInt {\n  // ...\n}\n\nvar a = MyInt(10), b = MyInt(5), c = MyInt(5)\nprint(a - b - c) // against expectations, this outputs 10\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ninfix operator &lt;- {associativity right precedence 140}\nfunc &lt;- (lhs: MyInt, rhs:MyInt) -&gt; MyInt {\n  // ...\n}\n\nvar a = MyInt(10), b = MyInt(5), c = MyInt(5)\nprint(a - b - c) // prints 0 as expected\nprint(a &lt;- b &lt;- c) // prints 10\n</pre>","debt":"20min"},{"summary":"IP addresses should not be hardcoded","type":"Vulnerability","defaultSeverity":"Minor","description":"<p>Hardcoding an IP address into source code is a bad idea for several reasons:</p>\n<ul>\n  <li> a recompile is required if the address changes </li>\n  <li> it forces the same address to be used in every environment (dev, sys, qa, prod) </li>\n  <li> it places the responsibility of setting the value to use in production on the shoulders of the developer </li>\n  <li> it allows attackers to decompile the code and thereby discover a potentially sensitive address </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar host : NSHost = NSHost(address: \"127.0.0.1\")\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar host : NSHost = NSHost(address: configuration.ipAddress)\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/qQCHAQ\">CERT, MSC03-J.</a> - Never hard code sensitive information </li>\n</ul>","debt":"30min"},{"summary":"Comments should not be nested","type":"Code Smell","defaultSeverity":"Major","description":"<p>Nested comments are confusing and can lead maintainers to misunderstand which code is active.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n/*\n  This is a comment block.\n  It may be difficult to figure out that the following line of code is actually commented\n\n\nvariable = function_call();\n/* variable contains the result. Noncompliant; inner comment */\n*/\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 2.3 - The character sequence /* shall not be used within a comment. </li>\n  <li> MISRA C++:2008, 2-7-1 - The character sequence /* shall not be used within a C-style comment. </li>\n  <li> MISRA C:2012, 3.1 - The character sequences /* and // shall not be used within a comment </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/L4IyAQ\">CERT, MSC04-CPP.</a> - Use comments consistently and in a readable fashion\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KgQ\">CERT, MSC04-C.</a> - Use comments consistently and in a readable fashion </li>\n</ul>","debt":"15min"},{"summary":"Classes should not be too complex","type":"Code Smell","defaultSeverity":"Critical","description":"<p>The cyclomatic complexity of a class should not exceed a defined threshold. Complex code can perform poorly and will in any case be difficult to\nunderstand and therefore to maintain.</p>\n<h2>Deprecated</h2>\n<p>This rule is deprecated, and will eventually be removed.</p>","debt":"10min"},{"summary":"Sequential tests should not check the same condition","type":"Code Smell","defaultSeverity":"Minor","description":"<p>When the same condition is checked twice in a row, it is either confusing - why have separate checks? - or an error - some other condition should\nhave been checked in the second test.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif a == b { // Compliant; a reassigned in previous block\n  doSomething(b)\n}\nif a == b {  // Noncompliant; is this really what was intended?\n  doTheThing(c)\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif a == b {\n  doTheThing(b)\n  doTheThing(c)\n}\n</pre>\n<p>or</p>\n<pre>\nif a == b {\n  doTheThing(b)\n}\nif b == c {\n  doTheThing(c)\n}\n</pre>","debt":"5min"},{"summary":"Control flow statements \"if\", \"for\", \"for in\", \"while\", \"do while\" and \"switch\" should not be nested too deeply","type":"Code Smell","defaultSeverity":"Critical","description":"<p>Nested <code>if</code>, <code>for</code>, <code>for in</code>, <code>while</code>, <code>do while</code> and <code>switch</code> statements are a\nkey ingredient for making what's known as \"Spaghetti code\".</p>\n<p>Such code is hard to read, refactor and therefore maintain.</p>\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold of 3:</p>\n<pre>\n  if condition1 {                  // Compliant - depth = 1\n    /* ... */\n    if condition2 {                // Compliant - depth = 2\n      /* ... */\n      for var i = 0; i &lt; 10; i++ {  // Compliant - depth = 3, not exceeding the limit\n        /* ... */\n        if condition4 {            // Non-Compliant - depth = 4\n          if condition5 {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4\n            /* ... */\n          }\n        }\n      }\n    }\n  }\n</pre>","debt":"10min"},{"summary":"Statements should end with semicolons","type":"Code Smell","defaultSeverity":"Minor","description":"<p>In Swift, the semicolon (<code>;</code>) is optional as a statement separator, but omitting semicolons can be confusing.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar x = 1\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar x = 1;\n</pre>","debt":"2min"},{"summary":"Functions and variables should not be defined outside of classes","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Defining and using global variables and global functions, when the convention dictates OOP can be confusing and difficult to use properly for\nmultiple reasons:</p>\n<ul>\n  <li> You run the risk of name clashes. </li>\n  <li> Global functions must be stateless, or they can cause difficult-to-track bugs. </li>\n  <li> Global variables can be updated from anywhere and may no longer hold the value you expect. </li>\n  <li> It is difficult to properly test classes that use global functions. </li>\n</ul>\n<p>Instead of being declared globally, such variables and functions should be moved into a class, potentially marked <code>static</code>, so they can\nbe used without a class instance. </p>\n<p>This rule checks that only object-oriented programming is used and that no functions or procedures are declared outside of a class.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar name = \"Bob\"    // Noncompliant\n\nfunc doSomething() {   // Noncompliant\n  //...\n}\n\nclass MyClass {\n    //...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class MyClass {\n  public static var name = \"Bob\"\n\n  public class func doSomething() {              // Compliant\n    //...\n  }\n  //...\n}\n</pre>\n<h2>Exceptions</h2>\n<p>The operator function is a function with a name that matches the operator to be overloaded. Because such functions can only be defined in a global\nscope, they are ignored by this rule.</p>\n<pre>\npublic class Vector2D {\n    var x = 0.0, y = 0.0\n    // ...\n}\n\nfunc + (left: Vector2D, right: Vector2D) -&gt; Vector2D {\n    return Vector2D(x: left.x + right.x, y: left.y + right.y)\n}\n</pre>","debt":"15min"},{"summary":"\"switch case\" clauses should not have too many lines of code","type":"Code Smell","defaultSeverity":"Major","description":"<p>The <code>switch</code> statement should be used only to clearly define some new branches in the control flow. As soon as a <code>case</code>\nclause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of the\n<code>case</code> clause should be extracted into a dedicated method.</p>\n<h2>Noncompliant Code Example</h2>\n<p>The following code snippet illustrates this rule with the default threshold of 5:</p>\n<pre>\nswitch myVariable {\n  case 0: // 6 lines till next case\n    methodCall1(\"\")\n    methodCall2(\"\")\n    methodCall3(\"\")\n    methodCall4(\"\")\n    methodCall5(\"\")\n  case 1:\n  ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch myVariable {\n  case 0:\n    doSomething()\n  case 1:\n  ...\n}\n...\nfunc doSomething(){\n    methodCall1(\"\")\n    methodCall2(\"\")\n    methodCall3(\"\")\n    methodCall4(\"\")\n    methodCall5(\"\")\n}\n</pre>","debt":"5min"},{"summary":"Sections of code should not be \"commented out\"","type":"Code Smell","defaultSeverity":"Major","description":"<p>Programmers should not comment out code as it bloats programs and reduces readability.</p>\n<p>Unused code should be deleted and can be retrieved from source control history if required.</p>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 2.4 - Sections of code should not be \"commented out\". </li>\n  <li> MISRA C++:2008, 2-7-2 - Sections of code shall not be \"commented out\" using C-style comments. </li>\n  <li> MISRA C++:2008, 2-7-3 - Sections of code should not be \"commented out\" using C++ comments. </li>\n  <li> MISRA C:2012, Dir. 4.4 - Sections of code should not be \"commented out\" </li>\n</ul>","debt":"5min"},{"summary":"\"if ... else if\" constructs should end with \"else\" clauses","type":"Code Smell","defaultSeverity":"Critical","description":"<p>This rule applies whenever an <code>if</code> statement is followed by one or more <code>else if</code> statements; the final <code>else if</code>\nshould be followed by an <code>else</code> statement.</p>\n<p>The requirement for a final <code>else</code> statement is defensive programming.</p>\n<p>The <code>else</code> statement should either take appropriate action or contain a suitable comment as to why no action is taken. This is\nconsistent with the requirement to have a final <code>default</code> clause in a <code>switch</code> statement.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif x == 0 {\n  doSomething()\n} else if x == 1 {\n  doSomethingElse()\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif x == 0 {\n  doSomething()\n} else if x == 1 {\n  doSomethingElse()\n} else {\n  NSException(name:\"IllegalStateException\", reason:\"Unreachable else clause is reached\", userInfo:nil).raise()\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.10 - All if...else if constructs shall be terminated with an else clause. </li>\n  <li> MISRA C++:2008, 6-4-2 - All if...else if constructs shall be terminated with an else clause. </li>\n  <li> MISRA C:2012, 15.7 - All if...else if constructs shall be terminated with an else statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/YgE\">CERT, MSC01-C.</a> - Strive for logical completeness </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/JoIyAQ\">CERT, MSC01-CPP.</a> - Strive for logical completeness </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/PQHRAw\">CERT, MSC57-J.</a> - Strive for logical completeness </li>\n</ul>","debt":"5min"},{"summary":"Duplicate values should not be passed as arguments","type":"Code Smell","defaultSeverity":"Major","description":"<p>There are valid cases for passing a variable multiple times into the same method call, but usually doing so is a mistake, and something else was\nintended for one of the arguments.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif equal(myPoint.x, myPoint.x) {  // Noncompliant\n  //...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif equal(myPoint.x, myPoint.y) {\n  //...\n}\n</pre>","debt":"5min"},{"summary":"Collection sizes comparisons should make sense","type":"Bug","defaultSeverity":"Major","description":"<p>The number of elements in a collection, an array or a string are always greater than or equal to zero. So testing that a size or length is greater\nthan or equal to zero doesn't make sense, since the result is always <code>true</code>. Similarly testing that it is less than zero will always return\n<code>false</code>. Perhaps the intent was to check the non-emptiness instead. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (myArray.count &gt;= 0) { ... }\n\nif (myString.characters.count &lt; 0) { ... }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (myArray.isEmpty) { ... }\n\nif (myString.isEmpty) { ... }\n</pre>","debt":"2min"},{"summary":"Methods and field names should not be the same or differ only by capitalization","type":"Code Smell","defaultSeverity":"Blocker","description":"<p>Looking at the set of methods in a <code>class</code>, <code>struct</code>, <code>enum</code>, or <code>extension</code> and finding two methods\nthat differ only by capitalization is confusing to users of the class. It is similarly confusing to have a method and a field or a case which differ\nonly in capitalization.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass SomeClass {\n    var lookUp = false\n    func lookup(){ }        // Noncompliant; method name differs from field name only by capitalization\n    func lookUP(){ }        // Noncompliant; method name differs from field and another method name only by capitalization\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass SomeClass {\n    var lookUp = false\n    func getLookUp(){ }\n}\n</pre>","debt":"10min"},{"summary":"Classes should not be empty","type":"Code Smell","defaultSeverity":"Minor","description":"<p>There is no good excuse for an empty class. If it's being used simply as a common extension point, it should be replaced with a\n<code>protocol</code>. If it was stubbed in as a placeholder for future development it should be fleshed-out. In any other case, it should be\neliminated.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class Nothing {  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic protocol Nothing {\n}\n</pre>","debt":"5min"},{"summary":"Comments should not be located at the end of lines of code","type":"Code Smell","defaultSeverity":"Minor","description":"<p>This rule verifies that single-line comments are not located at the ends of lines of code. The main idea behind this rule is that in order to be\nreally readable, trailing comments would have to be properly written and formatted (correct alignment, no interference with the visual structure of\nthe code, not too long to be visible) but most often, automatic code formatters would not handle this correctly: the code would end up less readable.\nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar a1 = b + c // This is a trailing comment that can be very very long\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// This very long comment is better placed before the line of code\nvar a2 = b + c\n</pre>","debt":"1min"},{"summary":"Failed unit tests should be fixed","type":"Bug","defaultSeverity":"Major","description":"Test failures or errors generally indicate that regressions have been introduced. Those tests should be handled as soon as possible to reduce the cost to fix the corresponding regressions."},{"summary":"Skipped unit tests should be either removed or fixed","type":"Code Smell","defaultSeverity":"Major","description":"Skipped unit tests are considered as dead code. Either they should be activated again (and updated) or they should be removed."},{"summary":"Source files should not have any duplicated blocks","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as there is at least one block of duplicated code on this file","debt":"10min"},{"summary":"Source files should have a sufficient density of comment lines","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the density of comment lines on this file is less than the required threshold. The number of comment lines to be written in order to reach the required threshold is provided by each issue message."},{"summary":"Lines should have sufficient coverage by tests","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the line coverage on this file is less than the required threshold. It gives the number of lines to be covered in order to reach the required threshold."},{"summary":"Branches should have sufficient coverage by tests","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the branch coverage on this file is less than the required threshold.It gives the number of branches to be covered in order to reach the required threshold."}]}