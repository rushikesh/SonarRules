{"types":{"Vulnerability":3,"Code Smell":57,"Bug":22},"standards":{},"tags":[{"name":"convention","count":11},{"name":"brain-overload","count":3},{"name":"suspicious","count":9},{"name":"confusing","count":7},{"name":"cwe","count":8},{"name":"error-handling","count":2},{"name":"cert","count":14},{"name":"misra","count":8},{"name":"pitfall","count":7},{"name":"bad-practice","count":2},{"name":"owasp-a3","count":1},{"name":"user-experience","count":1},{"name":"unused","count":6},{"name":"design","count":1},{"name":"obsolete","count":4},{"name":"owasp-a6","count":1},{"name":"redundant","count":3},{"name":"unpredictable","count":1},{"name":"finding","count":1},{"name":"clumsy","count":5},{"name":"es2015","count":4},{"name":"api-design","count":2},{"name":"duplicate","count":1}],"rules":[{"summary":"Variables should be declared before they are used","type":"Code Smell","defaultSeverity":"Blocker","inDefaultProfile":true,"ruleKey":"RSPEC-1526","tags":["pitfall"],"description":"<p>Variables declared with <code>var</code> have the special property that regardless of where they're declared in a function they \"float\" to the top\nof the function and are available for use even before they're declared. That makes scoping confusing, especially for new coders. To keep confusion to\na minimum, <code>var</code> declarations should happen before the variables they declare are used for the first time.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar x = 1;\n\nfunction fun(){\n  alert(x); // Noncompliant as x is declared later in the same scope\n  if(something) {\n    var x = 42; // Declaration in function scope (not block scope!) shadows global variable\n  }\n}\n\nfun(); // Unexpectedly alerts \"undefined\" instead of \"1\"\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar x = 1;\n\nfunction fun() {\n  print(x);\n  if (something) {\n    x = 42;\n  }\n}\n\nfun(); // Print \"1\"\n</pre>\n\n"},{"summary":"Code should not be dynamically injected and executed","type":"Vulnerability","defaultSeverity":"Critical","inDefaultProfile":true,"ruleKey":"RSPEC-1523","tags":["cwe","owasp-a3"],"description":"<p>The <code>eval</code> function is a way to run arbitrary code at run-time. Generally it is considered to be very dangerous because it allows\nexecution of arbitrary code. Its use is thus discouraged. If you have carefully verified that there is no other option than to use this construct, pay\nspecial attention not to pass any user-provided data into it without properly validating it beforehand.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\neval(code_to_be_dynamically_executed)\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/95.html\">MITRE CWE-95</a> - CWE-95: Improper Neutralization of Directives in Dynamically\n  Evaluated Code ('Eval Injection') </li>\n  <li> <a href=\"https://www.owasp.org/index.php/Top_10_2013-A3-Cross-Site_Scripting_(XSS)\">OWASP Top Ten 2013 Category A3</a> - Cross-Site Scripting\n  (XSS) </li>\n</ul>\n\n"},{"summary":"Getters and setters should access the expected fields","type":"Bug","defaultSeverity":"Critical","inDefaultProfile":true,"ruleKey":"RSPEC-4275","tags":["pitfall"],"description":"<p>Getters and setters provide a way to enforce encapsulation by providing <code>public</code> methods that give controlled access to\n<code>private</code> fields. However in classes with multiple fields it is not unusual that cut and paste is used to quickly create the needed getters\nand setters, which can result in the wrong field being accessed by a getter or setter.</p>\n<p>This rule raises an issue in any of these cases:</p>\n<ul>\n  <li> A setter does not update the field with the corresponding name. </li>\n  <li> A getter does not access the field with the corresponding name. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass A {\n  private _x: number = 0;\n  private y: number = 0;\n\n  public get x() {  // Noncompliant: field 'x' is not used in the return value\n    return this.y;\n  }\n\n  public setX(val: number) { // Noncompliant: field 'x' is not updated\n    if (val &gt;= 0 &amp;&amp; val &lt; 10) {\n      this.y = val;\n    }\n  }\n\n  public getY() { // Noncompliant: field 'y' is not used in the return value\n    return this.x;\n  }\n}{code}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass A {\n  private _x: number = 0;\n  private y: number = 0;\n\n  public get x() {\n    return this._x;\n  }\n\n  public setX(val: number) {\n    if (val &gt;= 0 &amp;&amp; val &lt; 10) {\n      this.x = val;\n    }\n  }\n\n  public getY() {\n    return this.y;\n  }\n}{code}\n</pre>\n\n"},{"summary":"\"super()\" should only be invoked once","type":"Bug","defaultSeverity":"Critical","inDefaultProfile":true,"ruleKey":"RSPEC-3854","tags":[],"description":"<p><code>super()</code> should only be invoked once in a constructor. Additional invocations will result in runtime errors.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Dog extends Animal {\n  constructor(name) {\n    super();\n    this.name = name;\n    super();         // Noncompliant\n    super.doSomething();\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Dog extends Animal {\n  constructor(name) {\n    super();\n    this.name = name;\n    super.doSomething();\n  }\n}\n</pre>\n\n"},{"summary":"Conditionals should start on new lines","type":"Code Smell","defaultSeverity":"Critical","inDefaultProfile":true,"ruleKey":"RSPEC-3972","tags":["suspicious"],"description":"<p>Code is clearest when each statement has its own line. Nonetheless, it is a common pattern to combine on the same line an <code>if</code> and its\nresulting <em>then</em> statement. However, when an <code>if</code> is placed on the same line as the closing <code>} </code> from a preceding\n<code>else</code> or <code>else if</code>, it is either an error - <code>else</code> is missing - or the invitation to a future error as maintainers\nfail to understand that the two statements are unconnected.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition1) {\n  // ...\n} if (condition2) {  // Noncompliant\n  //...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition1) {\n  // ...\n} else if (condition2) {\n  //...\n}\n</pre>\n<p>Or</p>\n<pre>\nif (condition1) {\n  // ...\n}\n\nif (condition2) {\n  //...\n}\n</pre>\n\n"},{"summary":"Non-empty statements should change control flow or have at least one side-effect","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-905","tags":["cwe","misra","cert","unused"],"description":"<p>Any statement (other than a null statement, which means a statement containing only a semicolon <code>;</code>) which has no side effect and does\nnot result in a change of control flow will normally indicate a programming error, and therefore should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\na == 1; // Noncompliant; was assignment intended?\na &lt; b; // Noncompliant; have we forgotten to assign the result to a variable?\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/482\">MITRE, CWE-482</a> - Comparing instead of Assigning </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n  <li> MISRA C:2004, 14.2 - All non-null statements shall either have at least one side-effect however executed, or cause control flow to change.\n  </li>\n</ul>\n\n"},{"summary":"Collection elements should not be replaced unconditionally","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-4143","tags":["suspicious"],"description":"<p>It is highly suspicious when a value is saved for a key or index and then unconditionally overwritten. Such replacements are likely in error.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n fruits[1] = \"banana\";\n fruits[1] = \"apple\";  // Noncompliant - value on index 1 is overwritten\n\n myMap.set(\"key\", 1);\n myMap.set(\"key\", 2); // Noncompliant - value for key \"key\" is replaced\n\n mySet.add(1);\n mySet.add(1); // Noncompliant - element is already in the set\n</pre>\n\n"},{"summary":"Constructors should not be declared inside interfaces","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-4124","tags":[],"description":"<p>Declare a constructor inside an <code>interface</code>, and you will get a simple method with the name \"constructor\". The same thing will happen if\nyou create a <code>new</code> method inside the <code>interface</code>: you'll get a simple method named \"new\".</p>\n<p>Instead, the intent was probably to specify that the type did not originate from a TypeScript file. In such cases, just use the <code>declare\nclass</code> syntax.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ninterface TypeDeclaredElsewhere {\n  someMethod(): number;\n  new(b: boolean): TypeDeclaredElsewhere; // Noncompliant\n  constructor(b: boolean): void; // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ndeclare class TypeDeclaredElsewhere {\n  someMethod(): number;\n  constructor(b: boolean);\n}\n</pre>\n<p> </p>\n\n"},{"summary":"\"Array.reverse\" should not be used misleadingly","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-4043","tags":[],"description":"<p>Many of JavaScript's <code>Array</code> methods return an altered version of the array while leaving the source array intact.\n<code>Array.reverse()</code> is not one of those. Instead, it alters the source array <em>in addition to</em> returning the altered version, which is\nlikely not what was intended. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar b = a.reverse(); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar b = [...a].reverse();  // de-structure and create a new array, so reverse doesn't impact 'a'\n\na.reverse();\n</pre>\n\n"},{"summary":"Errors should not be created without being thrown","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-3984","tags":[],"description":"<p>Creating a new <code>Error</code> without actually throwing it is useless and is probably due to a mistake.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (x &lt; 0) {\n  new Error(\"x must be nonnegative\");\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (x &lt; 0) {\n  throw new Error(\"x must be nonnegative\");\n}\n</pre>\n\n"},{"summary":"Collection sizes and array length comparisons should make sense","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-3981","tags":[],"description":"<p>The size of a collection and the length of an array are always greater than or equal to zero. So testing that a size or length is greater than or\nequal to zero doesn't make sense, since the result is always <code>true</code>. Similarly testing that it is less than zero will always return\n<code>false</code>. Perhaps the intent was to check the non-emptiness of the collection or array instead. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (someSet.size &gt;= 0) {...} // Noncompliant\n\nif (someMap.size &lt; 0) {...} // Noncompliant\n\nconst result = someArray.length &gt;= 0;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (someSet.size &gt; 0) {...}\n\nif (someMap.size == 0) {...}\n\nconst result = someArray.length &gt; 0;\n</pre>\n\n"},{"summary":"All branches in a conditional structure should not have exactly the same implementation","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-3923","tags":[],"description":"<p>Having all branches in a <code>switch</code> or <code>if</code> chain with the same implementation is an error. Either a copy-paste error was made\nand something different should be executed, or there shouldn't be a <code>switch</code>/<code>if</code> chain at all. Note that this rule does not\napply to <code>if</code> chains without <code>else</code>-s, or to <code>switch</code>-es without <code>default</code> clauses.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (b == 0) {  // Noncompliant\n  doOneMoreThing();\n}\nelse {\n  doOneMoreThing();\n}\n\nlet a = (b == 0) ? getValue() : getValue();   // Noncompliant\n\nswitch (i) {  // Noncompliant\n  case 1:\n    doSomething();\n    break;\n  case 2:\n    doSomething();\n    break;\n  case 3:\n    doSomething();\n    break;\n  default:\n    doSomething();\n}\n</pre>\n\n"},{"summary":"Destructuring patterns should not be empty","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-3799","tags":[],"description":"<p>Destructuring is a convenient way of extracting multiple values from data stored in (possibly nested) objects and arrays. However, it is possible\nto create an empty pattern that has no effect. When empty curly braces or brackets are used to the right of a property name most of the time the\nintent was to use a default value instead.</p>\n<p>This rule raises an issue when empty destructuring pattern is used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar {a: {}, b} = myObj; // Noncompliant\nfunction foo({first: [], second}) { // Noncompliant\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar {a = {}, b} = myObj;\nfunction foo({first = [], second}) {\n  // ...\n}\n</pre>\n\n"},{"summary":"The output of functions that don't return anything should not be used","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-3699","tags":[],"description":"<p>If a function does not return anything, it makes no sense to use its output. Specifically, passing it to another function, or assigning its\n\"result\" to a variable is probably a bug because such functions return <code>undefined</code>, which is probably not what was intended.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction foo() {\n}\n\na = foo();\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction foo() {\n}\n\nfoo();\n</pre>\n\n"},{"summary":"Non-existent operators '=+', '=-' and '=!' should not be used","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-2757","tags":[],"description":"<p>The use of operators pairs (<code>=+</code>, <code>=-</code> or <code>=!</code>) where the reversed, single operator was meant (<code>+=</code>,\n<code>-=</code> or <code>!=</code>) will compile and run, but not produce the expected results.</p>\n<p>This rule raises an issue when <code>=+</code>, <code>=-</code> and <code>=!</code> are used without any space between the two operators and when\nthere is at least one whitespace after.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlet target =-5;\nlet num = 3;\n\ntarget =- num;  // Noncompliant; target = -3. Is that really what's meant?\ntarget =+ num; // Noncompliant; target = 3\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlet target = -5;\nlet num = 3;\n\ntarget = -num;  // Compliant; intent to assign inverse value of num is clear\ntarget += num;\n</pre>\n\n"},{"summary":"\"NaN\" should not be used in comparisons","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-2688","tags":["cert"],"description":"<p><code>NaN</code> is not equal to anything, even itself. Testing for equality or inequality against <code>NaN</code> will yield predictable results,\nbut probably not the ones you want. </p>\n<p>Instead, the best way to see whether a variable is equal to <code>NaN</code> is to use <code>Number.isNaN()</code>, since ES2015, or (perhaps\ncounter-intuitively) to compare it to itself. Since <code>NaN !== NaN</code>, when <code>a !== a</code>, you know it must equal <code>NaN</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar a = NaN;\n\nif (a === NaN) {  // Noncompliant; always false\n  console.log(\"a is not a number\");  // this is dead code\n}\nif (a !== NaN) { // Noncompliant; always true\n  console.log(\"a is not NaN\"); // this statement is not necessarily true\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (Number.isNaN(a)) {\n  console.log(\"a is not a number\");\n}\nif (!Number.isNaN(a)) {\n  console.log(\"a is not NaN\");\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/7AEqAQ\">CERT, NUM07-J.</a> - Do not attempt comparisons with NaN </li>\n</ul>\n\n"},{"summary":"Return values from functions without side effects should not be ignored","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-2201","tags":["misra","cert"],"description":"<p>When the call to a function doesn't have any side effects, what is the point of making the call if the results are ignored? In such case, either\nthe function call is useless and should be dropped or the source code doesn't behave as expected. </p>\n<p>To prevent generating any false-positives, this rule triggers an issues only on a predefined list of known objects &amp; functions. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n'hello'.lastIndexOf('e'); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlet char = 'hello'.lastIndexOf('e');\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 17.7 - The value returned by a function having non-void return type shall be used </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/9YIRAQ\">CERT, EXP12-C.</a> - Do not ignore values returned by functions </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/eoAyAQ\">CERT, EXP12-CPP.</a> - Do not ignore values returned by functions or methods\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/9gEqAQ\">CERT, EXP00-J.</a> - Do not ignore values returned by methods </li>\n</ul>\n\n"},{"summary":"Values should not be uselessly incremented","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-2123","tags":["unused"],"description":"<p>A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlet i = 0;\ni = i++; // Noncompliant; i is still zero\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlet i = 0;\ni++;\n</pre>\n\n"},{"summary":"Related \"if/else if\" statements and \"cases\" in a \"switch\" should not have the same condition","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-1862","tags":["cert","unused","pitfall"],"description":"<p>A <code>switch</code> and a chain of <code>if</code>/<code>else if</code> statements is evaluated from top to bottom. At most, only one branch will\nbe executed: the first one with a condition that evaluates to <code>true</code>.</p>\n<p>Therefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it's simply dead code and\nat worst, it's a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior.</p>\n<p>For a <code>switch</code>, if the first case ends with a <code>break</code>, the second case will never be executed, rendering it dead code. Worse\nthere is the risk in this situation that future maintenance will be done on the dead case, rather than on the one that's actually used.</p>\n<p>On the other hand, if the first case does not end with a <code>break</code>, both cases will be executed, but future maintainers may not notice\nthat.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (param == 1)\n  openWindow();\nelse if (param == 2)\n  closeWindow();\nelse if (param == 1)  // Noncompliant\n  moveWindowToTheBackground();\n\n\nswitch(i) {\n  case 1:\n    //...\n    break;\n  case 3:\n    //...\n    break;\n  case 1:  // Noncompliant\n    //...\n    break;\n  default:\n    // ...\n    break;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (param == 1)\n  openWindow();\nelse if (param == 2)\n  closeWindow();\nelse if (param == 3)\n  moveWindowToTheBackground();\n\n\nswitch(i) {\n  case 1:\n    //...\n    break;\n  case 3:\n    //...\n    break;\n  default:\n    // ...\n    break;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>\n\n"},{"summary":"Identical expressions should not be used on both sides of a binary operator","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-1764","tags":["cert"],"description":"<p>Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste\nerror and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical\noperators, having the same value on both sides of an operator yields predictable results, and should be simplified.</p>\n<p>This rule ignores <code>*</code>, <code>+</code>, and <code>=</code>. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ( a == a ) { // always true\n  doZ();\n}\nif ( a != a ) { // always false\n  doY();\n}\nif ( a == b &amp;&amp; a == b ) { // if the first one is true, the second one is too\n  doX();\n}\nif ( a == b || a == b ) { // if the first one is true, the second one is too\n  doW();\n}\n\nvar j = 5 / 5; //always 1\nvar k = 5 - 5; //always 0\n</pre>\n<h2>Exceptions</h2>\n<p>The specific case of testing one variable against itself is a valid test for <code>NaN</code> and is therefore ignored.</p>\n<p>Similarly, left-shifting 1 onto 1 is common in the construction of bit masks, and is ignored. </p>\n<p>Moreover comma operator <code>,</code> and <code>instanceof</code> operator are ignored as there are use-cases when there usage is valid.</p>\n<pre>\nif(f !== f) { // test for NaN value\n  console.log(\"f is NaN\");\n}\n\nvar i = 1 &lt;&lt; 1; // Compliant\nvar j = a &lt;&lt; a; // Noncompliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n  <li> {rule:typescript:S1656} - Implements a check on <code>=</code>. </li>\n</ul>\n\n"},{"summary":"Variables should not be self-assigned","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-1656","tags":["cert"],"description":"<p>There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction setName(name) {\n    name = name;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction setName(name) {\n    this.name = name;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>\n\n"},{"summary":"Jump statements should not occur in \"finally\" blocks","type":"Bug","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-1143","tags":["cwe","error-handling","cert"],"description":"<p>Using <code>return</code>, <code>break</code>, <code>throw</code>, and <code>continue</code> from a <code>finally</code> block overwrites similar\nstatements from the suspended <code>try</code> and <code>catch</code> blocks.</p>\n<p>This rule raises an issue when a jump statement (<code>break</code>, <code>continue</code>, <code>return</code> and <code>throw</code>) would force\ncontrol flow to leave a <code>finally</code> block. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction foo() {\n    try {\n        return 1; // We expect 1 to be returned\n    } catch(err) {\n        return 2; // Or 2 in cases of error\n    } finally {\n        return 3; // Noncompliant: 3 is returned before 1, or 2, which we did not expect\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction foo() {\n    try {\n        return 1; // We expect 1 to be returned\n    } catch(err) {\n        return 2; // Or 2 in cases of error\n    }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/584.html\">MITRE, CWE-584</a> - Return Inside Finally Block </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/mIEbAQ\">CERT, ERR04-J.</a> - Do not complete abruptly from a finally block </li>\n</ul>\n\n"},{"summary":"Functions should not have identical implementations","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-4144","tags":["confusing","duplicate","suspicious"],"description":"<p>When two functions have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but\nmay be confusing to maintainers. In the latter case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass MyClass {\n  private readonly CODE = \"bounteous\";\n\n  public calculateCode(): string {\n    doTheThing();\n    doOtherThing();\n    return this.CODE;\n  }\n\n  public getName(): string {  // Noncompliant\n    doTheThing();\n    doOtherThing();\n    return this.CODE;\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass {\n  private readonly CODE = \"bounteous\";\n\n  public calculateCode(): string {\n    doTheThing();\n    doOtherThing();\n    return this.CODE;\n  }\n\n  public getName(): string {\n    return this.calculateCode();\n  }\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Functions with fewer than 3 lines are ignored.</p>\n\n"},{"summary":"Array contents should be used","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-4030","tags":["unused","suspicious"],"description":"<p>When a collection is populated but its contents are never used, then it is surely some kind of mistake. Either refactoring has rendered the\ncollection moot, or an access is missing.</p>\n<p>This rule raises an issue when no methods are called on a collection other than those that add or remove values.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getLength(a: string, b: string, c: string) {\n  const strings = [];  // Noncompliant\n  strings.push(a);\n  strings.push(b);\n  strings.push(c);\n\n  return a.length + b.length + c.length;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getLength(a: string, b: string, c: string) {\n  return a.length + b.length + c.length;\n}\n</pre>\n\n"},{"summary":"\"delete\" should not be used on arrays","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-2870","tags":[],"description":"<p>The <code>delete</code> operator can be used to remove a property from any object. Arrays are objects, so the <code>delete</code> operator can be\nused here too, but if it is, a hole will be left in the array because the indexes/keys won't be shifted to reflect the deletion. </p>\n<p>The proper method for removing an element at a certain index would be:</p>\n<ul>\n  <li> <code>Array.prototype.splice</code> - add/remove elements from the array </li>\n  <li> <code>Array.prototype.pop</code> - add/remove elements from the end of the array </li>\n  <li> <code>Array.prototype.shift</code> - add/remove elements from the beginning of the array </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar myArray = ['a', 'b', 'c', 'd'];\n\ndelete myArray[2];  // Noncompliant. myArray =&gt; ['a', 'b', undefined, 'd']\nconsole.log(myArray[2]); // expected value was 'd' but output is undefined\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar myArray = ['a', 'b', 'c', 'd'];\n\n// removes 1 element from index 2\nremoved = myArray.splice(2, 1);  // myArray =&gt; ['a', 'b', 'd']\nconsole.log(myArray[2]); // outputs 'd'\n</pre>\n\n"},{"summary":"Variables should not be redeclared","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-2814","tags":["confusing"],"description":"<p>This rule checks that a declaration doesn't use a name that is already in use. Indeed, it is possible to use the same symbol multiple times as\neither a variable or a function, but doing so is likely to confuse maintainers. Further it's possible that such reassignments are made in error, with\nthe developer not realizing that the value of the variable is overwritten by the new assignment.</p>\n<p>This rule also applies to function parameters.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction myFunc(arg) {\n  var a = \"Ayyyyye\";\n  var arg = \"event\"; // Noncompliant, argument value is lost\n  var a = \"Howdy\";  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar a = 'foo';\nfunction otherName() {}\nconsole.log(a);\n\nfunction myFunc(arg) {\n  var newName = \"event\";\n}\n\nfun(); // prints \"foo\"\n\nfunction fun() {\n  print(\"foo\");\n}\n\nfun(); // prints \"foo\"\n\nfunction printBar() {\n  print(\"bar\");\n}\n\nprintBar(); // prints \"bar\"\n</pre>\n\n"},{"summary":"Multiline blocks should be enclosed in curly braces","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-2681","tags":["cwe","cert"],"description":"<p>Curly braces can be omitted from a one-line block, such as with an <code>if</code> statement or <code>for</code> loop, but doing so can be\nmisleading and induce bugs. </p>\n<p>This rule raises an issue when the whitespacing of the lines after a one line block indicates an intent to include those lines in the block, but\nthe omission of curly braces means the lines will be unconditionally executed once.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition)\n  firstActionInBlock();\n  secondAction();  // Noncompliant; executed unconditionally\nthirdAction();\n\nif (condition) firstActionInBlock(); secondAction();  // Noncompliant; secondAction executed unconditionally\n\nif (condition) firstActionInBlock();  // Noncompliant\n  secondAction();  // Executed unconditionally\n\nif (condition); secondAction();  // Noncompliant; secondAction executed unconditionally\n\nlet str: string|null = null;\nfor (let i = 0; i &lt; array.length; i++)\n  str = array[i];\n  doTheThing(str);  // Noncompliant; executed only on last array element\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition) {\n  firstActionInBlock();\n  secondAction();\n}\nthirdAction();\n\nstr: string|null = null;\nfor (let i = 0; i &lt; array.length; i++) {\n  str = array[i];\n  doTheThing(str);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/483.html\">MITRE, CWE-483</a> - Incorrect Block Delimitation </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/3wHEAw\">CERT, EXP52-J.</a> - Use braces for the body of an if, for, or while statement\n  </li>\n</ul>\n\n"},{"summary":"Conditions should not always evaluate to 'true' or to 'false'","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-2589","tags":["cwe","misra","cert","redundant"],"description":"<p>If an expression doesn't change the evaluation of the condition, then it is either unnecessary, and condition can be removed, or it makes some code being never executed. In any case, the code should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n  function checkState(state: boolean) {\n    if (state) {\n      console.log(\"Checking the state\");\n      if (state) { // Noncompliant, condition is always true\n        doSomething();\n      }\n    }\n  }\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. </li>\n  <li> MISRA C:2012, 14.3 - Controlling expressions shall not be invariant </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/489\">MITRE, CWE-489</a> - Leftover Debug Code </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/571\">MITRE, CWE-571</a> - Expression is Always True </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>\n\n"},{"summary":"Two branches in a conditional structure should not have exactly the same implementation","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-1871","tags":["design","suspicious"],"description":"<p>Having two <code>cases</code> in a <code>switch</code> statement or two branches in an <code>if</code> chain with the same implementation is at\nbest duplicate code, and at worst a coding error. If the same logic is truly needed for both instances, then in an <code>if</code> chain they should\nbe combined, or for a <code>switch</code>, one should fall through to the other. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nswitch (i) {\n  case 1:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  case 3:  // Noncompliant; duplicates case 1's implementation\n    doFirstThing();\n    doSomething();\n    break;\n  default:\n    doTheRest();\n}\n\nif (a &gt;= 0 &amp;&amp; a &lt; 10) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20) {\n  doTheOtherThing();\n}\nelse if (a &gt;= 20 &amp;&amp; a &lt; 50) {\n  doFirstThing();\n  doTheThing();  // Noncompliant; duplicates first condition\n}\nelse {\n  doTheRest();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nswitch (i) {\n  case 1:\n  case 3:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  default:\n    doTheRest();\n}\n\nif ((a &gt;= 0 &amp;&amp; a &lt; 10) || (a &gt;= 20 &amp;&amp; a &lt; 50)) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20) {\n  doTheOtherThing();\n}\nelse {\n  doTheRest();\n}\n</pre>\n<p>or </p>\n<pre>\nswitch (i) {\n  case 1:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  case 3:\n    doFirstThing();\n    doThirdThing();\n    break;\n  default:\n    doTheRest();\n}\n\nif (a &gt;= 0 &amp;&amp; a &lt; 10) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20) {\n  doTheOtherThing();\n}\nelse if (a &gt;= 20 &amp;&amp; a &lt; 50) {\n  doFirstThing();\n  doTheThirdThing();\n}\nelse {\n  doTheRest();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Blocks in an <code>if</code> chain that contain a single line of code are ignored, as are blocks in a <code>switch</code> statement that contain a\nsingle line of code with or without a following <code>break</code>.</p>\n\n"},{"summary":"Dead stores should be removed","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-1854","tags":["cwe","cert","unused"],"description":"<p>A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction or when an object property is\nassigned a value that is not subsequently used. Calculating or retrieving a value only to then overwrite it or throw it away, could indicate a serious\nerror in the code. Even if it's not an error, it is at best a waste of resources. Therefore all calculated values should be used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction pow(a: number, b: number) {\n  if(b == 0) {\n    return 0;\n  }\n  let x = a;\n  for(let i = 1; i &lt; b; i++) {\n    x = a * i;  //Dead store because the last return statement should return x instead of returning a\n  }\n  return a;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction pow(a: number, b: number) {\n  if(b == 0) {\n    return 0;\n  }\n  let x = a;\n  for(let i = 1; i &lt; b; i++) {\n    x = a * i;\n  }\n  return x;\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule ignores initializations to -1, 0, 1, <code>null</code>, <code>true</code>, <code>false</code>, <code>\"\"</code>, <code>[]</code> and\n<code>{}</code>.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/563.html\">MITRE, CWE-563</a> - Assignment to Variable without Use ('Unused Variable') </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/QYA5\">CERT, MSC13-C.</a> - Detect and remove unused values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/S4IyAQ\">CERT, MSC13-CPP.</a> - Detect and remove unused values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/uQCSBg\">CERT, MSC56-J.</a> - Detect and remove superfluous code and values </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>\n\n"},{"summary":"Jump statements should not be used unconditionally","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-1751","tags":["misra","cert","unused"],"description":"<p>Having an unconditional <code>break</code>, <code>return</code> or <code>throw</code> in a loop renders it useless; the loop will only execute once\nand the loop structure itself is simply wasted keystrokes.</p>\n<p>Having an unconditional <code>continue</code> in a loop is itself wasted keystrokes.</p>\n<p>For these reasons, unconditional jump statements should never be used except for the final <code>return</code> in a function or method.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (i = 0; i &lt; 10; i++) {\n  console.log(\"i is \" + i);\n  break;  // loop only executes once\n}\n\nfor (i = 0; i &lt; 10; i++) {\n  console.log(\"i is \" + i);\n  continue;  // this is meaningless; the loop would continue anyway\n}\n\nfor (i = 0; i &lt; 10; i++) {\n  console.log(\"i is \" + i);\n  return;  // loop only executes once\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfor (i = 0; i &lt; 10; i++) {\n  console.log(\"i is \" + i);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.1 - There shall be no unreachable code. </li>\n  <li> MISRA C++:2008, 0-1-1 - A <em>project</em> shall not contain <em>unreachable code</em>. </li>\n  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code. </li>\n  <li> MISRA C:2012, 2.2 - There shall be no dead code </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never\n  executed </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>\n</ul>\n\n"},{"summary":"Redundant pairs of parentheses should be removed","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-1110","tags":["confusing"],"description":"<p>The use of parentheses, even those not required to enforce a desired order of operations, can clarify the intent behind a piece of code. But\nredundant pairs of parentheses could be misleading, and should be removed. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlet x = (y / 2 + 1);   // Compliant even if those parenthesis are useless for the compiler\n\nif (a &amp;&amp; ((x+y &gt; 0))) {  // Noncompliant\n  //...\n}\n\nreturn ((x + 1));  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlet x = (y / 2 + 1);\n\nif (a &amp;&amp; (x+y &gt; 0)) {\n  //...\n}\n\nreturn (x + 1);\n</pre>\n\n"},{"summary":"Nested blocks of code should not be left empty","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":true,"ruleKey":"RSPEC-108","tags":["suspicious"],"description":"<p>Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (var i = 0; i &lt; length; i++) {}  // Empty on purpose or missing piece of code ?\n</pre>\n<h2>Exceptions</h2>\n<p>When a block contains a comment, this block is not considered to be empty. Moreover <code>catch</code> blocks are ignored.</p>\n\n"},{"summary":"Debugger statements should not be used","type":"Vulnerability","defaultSeverity":"Minor","inDefaultProfile":true,"ruleKey":"RSPEC-1525","tags":["cwe","user-experience"],"description":"<p>The debugger statement can be placed anywhere in procedures to suspend execution. Using the debugger statement is similar to setting a breakpoint\nin the code. By definition such statement must absolutely be removed from the source code to prevent any unexpected behavior or added vulnerability to\nattacks in production.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (i = 1; i&lt;5; i++) {\n  // Print i to the Output window.\n  Debug.write(\"loop index is \" + i);\n  // Wait for user to resume.\n  debugger;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfor (i = 1; i&lt;5; i++) {\n  // Print i to the Output window.\n  Debug.write(\"loop index is \" + i);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/489.html\">MITRE, CWE-489</a> - Leftover Debug Code </li>\n</ul>\n\n"},{"summary":"Function parameters, caught exceptions and foreach variables' initial values should not be ignored","type":"Bug","defaultSeverity":"Minor","inDefaultProfile":true,"ruleKey":"RSPEC-1226","tags":["misra"],"description":"<p>While it is technically correct to assign to parameters from within function bodies, doing so before the parameter value is read is likely a bug.\nInstead, initial values of parameters, caught exceptions, and foreach parameters should be, if not treated as read-only, then at least read before\nreassignment.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doTheThing(str : string, i: number, strings: string[]) {\n  str = i.toString();  // Noncompliant\n\n  for (let s in strings) {\n    s = \"hello world\" + str;  // Noncompliant\n    console.log(s);\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2012, 17.8 - A function parameter should not be modified </li>\n</ul>\n\n"},{"summary":"Wrapper objects should not be used for primitive types","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":true,"ruleKey":"RSPEC-1533","tags":["pitfall"],"description":"<p>The use of wrapper objects for primitive types is gratuitous, confusing and dangerous. If you use a wrapper object constructor for type conversion,\njust remove the <code>new</code> keyword, and you'll get a primitive value automatically. If you use a wrapper object as a way to add properties to a\nprimitive, you should re-think the design. Such uses are considered bad practice, and should be refactored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlet x = new Number(\"0\");\nif (x) {\n  alert('hi');  // Shows 'hi'.\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlet x = Number(\"0\");\nif (x) {\n  alert('hi');\n}\n</pre>\n\n"},{"summary":"Multiline string literals should not be used","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":true,"ruleKey":"RSPEC-1516","tags":["bad-practice"],"description":"<p>Continuing a string across a linebreak is supported in most script engines, but it is not a part of ECMAScript. Additionally, the whitespace at the\nbeginning of each line can't be safely stripped at compile time, and any whitespace after the slash will result in tricky errors.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar myString = 'A rather long string of English text, an error message \\\n                actually that just keeps going and going -- an error \\\n                message to make the Energizer bunny blush (right through \\\n                those Schwarzenegger shades)! Where was I? Oh yes, \\\n                you\\'ve got an error and all the extraneous whitespace is \\\n                just gravy.  Have a nice day.';  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar myString = 'A rather long string of English text, an error message ' +\n    'actually that just keeps going and going -- an error ' +\n    'message to make the Energizer bunny blush (right through ' +\n    'those Schwarzenegger shades)! Where was I? Oh yes, ' +\n    'you\\'ve got an error and all the extraneous whitespace is ' +\n    'just gravy.  Have a nice day.';\n</pre>\n\n"},{"summary":"Track lack of copyright and license headers","type":"Code Smell","defaultSeverity":"Blocker","inDefaultProfile":false,"ruleKey":"RSPEC-1451","tags":[],"description":"<p>Each source file should start with a header stating file ownership and the license which must be used to distribute the application. </p>\n<p>This rule must be fed with the header text that is expected at the beginning of every file.</p>\n<h2>Compliant Solution</h2>\n<pre>\n/*\n * SonarQube, open source software quality management tool.\n * Copyright (C) 2008-2013 SonarSource\n * mailto:contact AT sonarsource DOT com\n *\n * SonarQube is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * SonarQube is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n</pre>\n\n"},{"summary":"\"await\" should only be used with promises","type":"Code Smell","defaultSeverity":"Critical","inDefaultProfile":false,"ruleKey":"RSPEC-4123","tags":["confusing"],"description":"<p>It is possible to use <code>await</code> on values which are not <code>Promise</code>s, but it's useless and misleading. The point of\n<code>await</code> is to pause execution until the <code>Promise</code>'s asynchronous code has run to completion. With anything other than a\n<code>Promise</code>, there's nothing to wait for. </p>\n<p>This rule raises an issue when an <code>await</code>ed value is guaranteed not to be a <code>Promise</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlet x = 42;\nawait x; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlet x = new Promise(resolve =&gt; resolve(42));\nawait x;\n\nlet y = p ? 42 : new Promise(resolve =&gt; resolve(42));\nawait y;\n</pre>\n\n"},{"summary":"Variables should be declared with \"let\" or \"const\"","type":"Code Smell","defaultSeverity":"Critical","inDefaultProfile":false,"ruleKey":"RSPEC-3504","tags":["es2015","bad-practice"],"description":"<p>The distinction between the variable types created by <code>var</code> and by <code>let</code> is significant, and a switch to <code>let</code>\nwill help alleviate many of the variable scope issues which have caused confusion in the past. </p>\n<p>This rule raises an issue when <code>var</code> is used instead of <code>const</code> or <code>let</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar color = \"blue\";\nvar size = 4;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst color = \"blue\";\nlet size = 4;\n</pre>\n\n"},{"summary":"Functions should not be too complex","type":"Code Smell","defaultSeverity":"Critical","inDefaultProfile":false,"ruleKey":"RSPEC-1541","tags":["brain-overload"],"description":"<p>The Cyclomatic Complexity of functions should not exceed a defined threshold. Complex code may perform poorly and can be difficult to test\nthoroughly.</p>\n\n"},{"summary":"Variables should not be shadowed","type":"Code Smell","defaultSeverity":"Critical","inDefaultProfile":false,"ruleKey":"RSPEC-1524","tags":["misra","cert","suspicious"],"description":"<p>Overriding a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of code.\nFurther, it could lead maintainers to introduce bugs because they think they're using one variable but are really using another.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction foo() {\n  let x = bar(1);\n  if (x &gt; 0) {\n      let x = bar(2); // Noncompliant\n      console.log(x);\n  } else {\n     console.log(\"Wrong Value\");\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction foo() {\n  let x = bar(1);\n  if (x &gt; 0) {\n      let y = bar(2);\n      console.log(y);\n  } else {\n     console.log(\"Wrong Value\");\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 5.2 - Identifiers in an inner scope shall not use the same name as an identifier in an outer scope, and therefore hide that\n  identifier </li>\n  <li> MISRA C++:2008, 2-10-2 - Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope </li>\n  <li> MISRA C:2012, 5.3 - An identifier declared in an inner scope shall not hide an identifier declared in an outer scope </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/VwE\">CERT, DCL01-C.</a> - Do not reuse variable names in subscopes </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/cwAhAQ\">CERT, DCL01-CPP.</a> - Do not reuse variable names in subscopes </li>\n</ul>\n\n"},{"summary":"Control structures should use curly braces","type":"Code Smell","defaultSeverity":"Critical","inDefaultProfile":false,"ruleKey":"RSPEC-121","tags":["misra","cert","pitfall"],"description":"<p>While not technically incorrect, the omission of curly braces can be misleading, and may lead to the introduction of errors during maintenance.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition)  // Noncompliant\n  executeSomething();\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition) {\n  executeSomething();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C:2004, 14.8 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement </li>\n  <li> MISRA C:2004, 14.9 - An if (expression) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement </li>\n  <li> MISRA C++:2008, 6-3-1 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement </li>\n  <li> MISRA C++:2008, 6-4-1 - An if (condition) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement </li>\n  <li> MISRA C:2012, 15.6 - The body of an iteration-statement or a selection-statement shall be a compound-statement </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/1QGMAg\">CERT, EXP19-C.</a> - Use braces for the body of an if, for, or while statement\n  </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/3wHEAw\">CERT, EXP52-J.</a> - Use braces for the body of an if, for, or while statement\n  </li>\n</ul>\n\n"},{"summary":"Template literal placeholder syntax should not be used in regular strings","type":"Bug","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-3786","tags":[],"description":"<p>Template strings allow developers to embed variables or expressions in strings using template literals, instead of string concatenation. This is\ndone by using expressions like <code>${variable} </code> in a string between two back-ticks (<code>`</code>). However, when used in a regular string\nliteral (between double or single quotes) the template will not be evaluated and will be used as a literal, which is probably not what was\nintended.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconsole.log(\"Today is ${date}\"); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconsole.log(`Today is ${date}`);\n</pre>\n\n"},{"summary":"Dependencies should be explicit","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-4328","tags":[],"description":"<p>Dependencies should be explicitly listed in the <code>package.json</code> file. Importing a module that is not declared as a dependency makes it an\nimplicit one and is bound to create problems.</p>\n\n"},{"summary":"\"this\" should not be assigned to a variable","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-4327","tags":["clumsy"],"description":"<p>Assigning <code>this</code> to a local variable is a way to reference parent context inside inner functions. In TypeScript when using arrow\nfunctions this happens automatically.</p>\n<p>This rule raises an issue when <code>this</code> is assigned to a local variable.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction Foo() {\n  let that = this;  // Noncompliant\n  that.val = 0;\n\n  setInterval(function() {\n    that.val++;\n  }, 1000);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction Foo() {\n  this.val = 0;\n\n  setInterval(() =&gt; {\n    this.val++;\n  }, 1000);\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule ignores <code>this</code> used for destructuring.</p>\n<pre>\nconst { foo, bar } = this;\n</pre>\n\n"},{"summary":"The \"any\" type should not be used","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-4204","tags":["pitfall"],"description":"<p>Variables can be declared with or without types. Variables declared without a type will be implicitly typed if the declaration includes an\ninitialization, and compiler type checking will be automatically applied to any typed variable. But if you declare a variable with the\n<code>any</code> \"type\" then you've explicitly told the compiler not to do any type checking, which is risky. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlet a = 42;  // implicitly typed to number\nlet b: number = 42;  // explicitly typed to number\nlet c: any = 42;  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlet a = 42;\nlet b: number = 42;\nlet c: number = 42;\n</pre>\n\n"},{"summary":"Sparse arrays should not be declared","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-4140","tags":["suspicious"],"description":"<p>An array declared with missing (\"sparse\") elements is likely to be an error: an extra comma was inserted or perhaps the developer meant to insert\nthe missing value and forgot.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar a = [1, , 3, 6, 9];  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar a = [1, 3, 6, 9];\n</pre>\n\n"},{"summary":"\"for in\" should not be used with iterables","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-4139","tags":[],"description":"<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use\n<code>for in</code> and you'll iterate the properties, rather than the values.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value in arr) {  // Noncompliant\n  console.log(value);  // logs 0, 1, 2, 3\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>\n\n"},{"summary":"Functions should use \"return\" consistently","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-3801","tags":["api-design","confusing"],"description":"<p>In TypeScript a function can return a value explicitly, by using a <code>return</code> statement with a value, or implicitly, at the end of the\nfunction or by a <code>return</code> with no value, resulting in the function returning <code>undefined</code>. Implicit returns of\n<code>undefined</code> not declared in the function signature, can be confusing for the maintainer.</p>\n<p>This rule ensures that <code>returns</code> are either all explicit or all implicit, or the function signatures makes the implicit\n<code>return</code> obvious.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction foo(a) { // Noncompliant, function exits without \"return\"\n  if (a == 1) {\n    return true;\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction foo(a): boolean | undefined {\n  if (a == 1) {\n    return true;\n  }\n}\n</pre>\n\n"},{"summary":"Strings should not be thrown","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-3696","tags":["error-handling","api-design","misra"],"description":"<p>It is a bad practice to <code>throw</code> something that's not derived at some level from <code>Error</code>. If you can't find an existing\n<code>Error</code> type that suitably conveys what you need to convey, then you should extend <code>Error</code> to create one.</p>\n<p>Specifically, part of the point of throwing <code>Error</code>s is to communicate about the conditions of the error, but strings have far less\nability to communicate meaningfully than <code>Error</code>s because they don't include stacktraces.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nthrow \"Invalid negative index.\";        // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nthrow new Error(\"Invalid negative index.\");\n</pre>\n<h2>See</h2>\n<ul>\n  <li> MISRA C++:2008, 15-1-2 - NULL shall not be thrown explicitly. </li>\n</ul>\n\n"},{"summary":"\"arguments.callee\" should not be used","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-2685","tags":["obsolete"],"description":"<p>The <code>arguments.callee</code> property holds the current function. It could be useful in an anonymous function, but its usage would make quite\na few optimizations impossible so it was deprecated in the latest versions of JavaScript. In fact, EcmaScript 5 forbids its use in <code>strict</code>\nmode, according to the docs:</p>\n<blockquote>\n  Arguments objects for strict mode functions define non-configurable accessor properties named \"caller\" and \"callee\" which throw a TypeError\n  exception on access.\n</blockquote>\n<p>This rule raises an issue when <code>arguments.callee</code> is used.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[1, 2, 3, 4, 5].map(function(n) {\n  if (n === 0) {\n    return 1;\n  } else {\n    return arguments.callee(n - 1) * n;\n  }\n});\n</pre>\n\n"},{"summary":"\"===\" and \"!==\" should be used instead of \"==\" and \"!=\"","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-1440","tags":["suspicious"],"description":"<p>The <code>==</code> and <code>!=</code> operators do type coercion before comparing values. This is bad because it can mask type errors. For\nexample, it evaluates <code>' \\t\\r\\n' == 0</code> as <code>true</code>.</p>\n<p>It is best to always use the side-effect-less <code>===</code> and <code>!==</code> operators instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (var == 'howdy') {...} // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (var === 'howdy') {...}\n</pre>\n<h2>Exceptions</h2>\n<p>Even if testing the equality of a variable against <code>null</code> doesn't do exactly what most TypeScript developers believe, the use of\n<code>==</code> or <code>!=</code> is tolerated in such contexts. As shown below, if <code>foo</code> hasn't been initialized, its default value is\nnot <code>null</code> but <code>undefined</code>. Nevertheless <code>undefined == null</code>, so TypeScript developers get the expected behavior.</p>\n<pre>\nif (foo == null) {...}  // ignored\n</pre>\n\n"},{"summary":"Only \"while\", \"do\", \"for\" and \"switch\" statements should be labelled","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-1439","tags":["pitfall"],"description":"<p>Any statement or block of statements can be identified by a label, but those labels should be used only on <code>while</code>,\n<code>do-while</code>, <code>for</code> and <code>switch</code> statements. Using labels in any other context leads to unstructured, confusing code.\n</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nmyLabel: if (i % 2 == 0) {  // Noncompliant\n  if (i == 12) {\n    console.log(\"12\");\n    break myLabel;\n  }\n  console.log(\"Odd number, but not 12\");\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nmyLabel: for (i = 0; i &lt; 10; i++) {   // Compliant\n  console.log(\"Loop\");\n  break myLabel;\n}\n</pre>\n\n"},{"summary":"Magic numbers should not be used","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-109","tags":["brain-overload"],"description":"<p>A magic number is a number that comes out of nowhere, and is directly used in a statement. Magic numbers are often used, for instance to limit the\nnumber of iterations of a loops, to test the value of a property, etc.</p>\n<p>Using magic numbers may seem obvious and straightforward when you're writing a piece of code, but they are much less obvious and straightforward at\ndebugging time.</p>\n<p>That is why magic numbers must be demystified by first being assigned to clearly named variables before being used.</p>\n<p>-1, 0 and 1 are not considered magic numbers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doSomething() {\n  for (let i = 0; i &lt; 4; i++) {    // Noncompliant, 4 is a magic number\n    // ...\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction doSomething() {\n  const numberOfCycles = 4;\n  for (let i = 0; i &lt; numberOfCycles; i++) {\n    // ...\n  }\n}\n</pre>\n\n"},{"summary":"Files should not have too many lines of code","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-104","tags":["brain-overload"],"description":"<p>A source file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to\nmaintain. Above a specific threshold, it is strongly advised to refactor it into smaller pieces of code which focus on well defined tasks. Those\nsmaller files will not only be easier to understand but also probably easier to test.</p>\n\n"},{"summary":"Lines should not be too long","type":"Code Smell","defaultSeverity":"Major","inDefaultProfile":false,"ruleKey":"RSPEC-103","tags":["convention"],"description":"<p>Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.</p>\n\n"},{"summary":"Console logging should not be used","type":"Vulnerability","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-2228","tags":["owasp-a6"],"description":"<p>Debug statements are always useful during development. But include them in production code - particularly in code that runs client-side - and you\nrun the risk of inadvertently exposing sensitive information, slowing down the browser, or even erroring-out the site for some users.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconsole.log(password_entered); // Noncompliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure\">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure\n  </li>\n</ul>\n\n"},{"summary":"Non-null assertions should not be used","type":"Bug","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-2966","tags":["unpredictable"],"description":"<p>The point of declaring an optional property or parameter is to make explicit the fact that it might contain no valid value, i.e. <code>null</code>\nor <code>undefined</code>. Using a non-null assertion (the <code>!.</code> operator) will lead to a runtime error if the optional does contain\n<code>null</code> or <code>undefined</code>. Even if the value is tested first, it's still considered a bad practice to use a non-null assertion. </p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction doTheThing(foo?: Foo) {\n  let s = foo!.bar;  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction doTheThing(foo?: Foo) {\n  if (foo) {\n    let s = foo.bar;\n  }\n}\n</pre>\n\n"},{"summary":"Unnecessary \"await\" should be avoided","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-4326","tags":["redundant"],"description":"<p>An <code>async</code> function always wraps the return value in a <code>Promise</code>. Using <code>return await</code> is therefore redundant.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nasync function foo() {\n  // ...\n}\n\nasync function bar() {\n  // ...\n  return await foo(); // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nasync function foo() {\n  // ...\n}\n\nasync function bar() {\n  // ...\n  return foo();\n}\n</pre>\n\n"},{"summary":"Redundant casts and not-null assertions should be avoided","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-4325","tags":["redundant"],"description":"<p>The TypeScript compiler automatically casts a variable to the relevant type inside conditionals where it is possible to infer (usage of\n<code>typeof</code>, <code>instanceof</code> etc). These compiler feature makes casts and not-<code>null</code> assertions unnecessary.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x!); // Noncompliant\n\n    if (typeof x === \"string\")\n      return (x as string); // Noncompliant\n    else\n      return (x as UserName).name; // Noncompliant\n  }\n  return \"NoName\";\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction getName(x?: string | UserName) {\n  if (x) {\n    console.log(\"Getting name for \" + x);\n\n    if (typeof x === \"string\")\n      return x;\n    else\n      return x.name;\n  }\n  return \"NoName\";\n}\n</pre>\n\n"},{"summary":"Type aliases should be used","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-4323","tags":[],"description":"<p>Union and intersection types are very convenient but can make code a bit harder to read and to maintain. So if a particular union or intersection\nis used in multiple places it is highly recommended to use a type alias.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction foo(x:string|null|number) {\n  // ...\n}\nfunction bar(x:string|null|number) { // Noncompliant\n  // ...\n}\nfunction zoo(): string|null|number {\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ntype MyType = string | null | number;\n\nfunction foo(x: MyType) {\n  // ...\n}\nfunction bar(x: MyType) {\n  // ...\n}\nfunction zoo():  MyType {\n  // ...\n}\n</pre>\n\n"},{"summary":"Default type parameters should be omitted","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-4157","tags":["clumsy"],"description":"<p>There's no reason to repeat a default type unless it is early in a list and other, non-default types come after it. Instead, leave it out and only\nsupply type when it is something other than the default.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction foo&lt;N = number, S = string&gt;() {}\nfoo&lt;number, string&gt;();  // Noncompliant; both types redundant\nfoo&lt;string, string&gt;();  // Noncompliant; 2nd string is redundant\nfoo&lt;number, number&gt;();  // Ignored; number is redundant but required\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction foo&lt;N = number, S = string&gt;() {}\nfoo();\nfoo&lt;string&gt;();\nfoo&lt;number, number&gt;();\n</pre>\n\n"},{"summary":"\"module\" should not be used","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-4156","tags":["obsolete"],"description":"<p>Each file is considered an \"external\" module. The use of the <code>module</code> keyword creates an internal module, and was used before the\nECMAScript 2015 addition of <code>namespace</code>s for the same purpose. Now that <code>namespace</code> is available, the use of <code>module</code>\nis deprecated because it does the same thing, and its use could confuse maintainers unaware of the history of the language.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nmodule myMod {  // Noncompliant\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nnamespace myMod {\n  // ...\n}\n</pre>\n\n"},{"summary":"\"for of\" should be used with Iterables","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-4138","tags":["clumsy"],"description":"<p>If you have an iterable, such as an array, set, or list, your best option for looping through its values is the <code>for of</code> syntax. Use a\ncounter, and ... well you'll get the right behavior, but your code just isn't as clean or clear.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let i = 0; i &lt; arr.length; i++) {  // Noncompliant\n  console.log(arr[i]);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst arr = [4, 3, 2, 1];\n\nfor (let value of arr) {\n  console.log(value);\n}\n</pre>\n\n"},{"summary":"Type assertions should use \"as\"","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-4137","tags":["confusing"],"description":"<p>Type assertion can be done in two ways: with <code>as MyType</code> or with <code>&lt;MyType&gt;</code>. But since there is an ambiguity in the\nlatter when using JSX and there is no ambiguity in the former, <code>as</code> is preferred.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar foo = &lt;any&gt;\"foo\";  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar foo = \"foo\" as any;\n</pre>\n\n"},{"summary":"Method overloads should be grouped together","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-4136","tags":["convention"],"description":"<p>For clarity, all overloads of the same method should be grouped together. That lets both users and maintainers quickly understand all the current\navailable options.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ninterface MyInterface {\n  doTheThing(): number;\n  doTheOtherThing(): string;\n  doTheThing(str: string): string;  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ninterface MyInterface {\n  doTheThing(): number;\n  doTheThing(str: string): string;\n  doTheOtherThing(): string;\n}\n</pre>\n\n"},{"summary":"Interfaces should not be empty","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-4023","tags":[],"description":"<p>An empty interface is equivalent to an empty object ('{}'). Normally you cannot directly assign an object literal to a type when the object literal\ncontains more properties than are specified in the type. But in the case of an empty interface, this check is not done, and such assignments will be\nsuccessful. The result is highly likely to confuse maintainers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ninterface MyFace {}  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ninterface MyFace {\n  foo: number;\n}\n</pre>\n\n"},{"summary":"Imports from the same modules should be merged","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-3863","tags":[],"description":"<p>Multiple imports from the same module should be merged together to improve readability.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nimport { B1 } from 'b';\nimport { B2 } from 'b'; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nimport { B1, B2 } from 'b';\n</pre>\n\n"},{"summary":"\"import\" should be used to include external code","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-3533","tags":["convention","es2015","obsolete"],"description":"<p>TypeScript provides the <code>import</code> and <code>export</code> keywords as language-standard mechanisms for module management. Javascript's\n<code>require()</code> usages should be converted to the new syntax.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n// circle.js\nmodule.exports = function (r) {\n  return PI * r * r;\n};\n\n// foo.js\nconst circle = require('./circle.js');  // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n// circle.ts\nexport default function (r) {\n  return PI * r * r;\n}\n\n// foo.ts\nimport circle from \"./circle.ts\"\n</pre>\n\n"},{"summary":"Template strings should be used instead of concatenation","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-3512","tags":["es2015","clumsy"],"description":"<p>ECMAScript 2015 added the ability to use template literals instead of concatenation. Since their use is clearer and more concise, they are\npreferred.</p>\n<p>This rule raises an issue when a string is created from the result of two or more concatenations.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction sayHello(name) {\n  console.log(\"hello \" + name);  // ignored\n}\n\nfunction madLib(verb, noun) {\n  console.log(\"I really \" + verb + \" one or two \" + noun);  // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction sayHello(name) {\n  console.log(`hello ${name}`);  // no issue raised before, but this is better\n}\n\nfunction madLib(verb, noun) {\n  console.log(`I really ${verb} one or two ${noun}`);\n}\n</pre>\n\n"},{"summary":"Object literal shorthand syntax should be used","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-3498","tags":["convention","es2015"],"description":"<p>When an already-defined variable is given the same name within a new object, object-shorthand syntax is preferred as being more compact. Similarly,\nobject-shorthand is also preferred for the definition of functions in object literals.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlet a = 1;\n\nlet myObj = {\n  a : a,  // Noncompliant\n  fun: function () {  // Noncompliant\n    //...\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlet a = 1;\n\nlet myObj = {\n  a,\n  fun () {\n    //...\n  }\n}\n</pre>\n\n"},{"summary":"Strings and non-strings should not be added","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-3402","tags":["confusing"],"description":"<p>Use a <code>+</code> with two numbers and you'll get addition. But use it with a string and anything else, and you'll get concatenation. This could\nbe confusing, specially if it's not obvious that one of the operands is a string. It is recommended to explicitly convert the non-string component to\nmake it easier to understand to future maintainers.</p>\n<p>This rule raises an issue when <code>+</code> is used with a string and a non-string.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar x = 5 + 8;  // okay\nvar z = \"8\"\nvar y = 5 + z;  // Noncompliant; yields string \"58\"\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar x = 5 + 8;\nvar z = \"8\";\nvar y = 5 + Number(z);\n</pre>\n\n"},{"summary":"Primitive types should be omitted from initialized or defaulted declarations","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-3257","tags":["finding","clumsy"],"description":"<p>Unnecessarily verbose declarations and initializations make it harder to read the code, and should be simplified. Specifically, primitive\n(<code>number</code>, <code>string</code>, and <code>boolean</code>) types should be omitted from variable and parameter declaration when they can be\neasily inferred from the initialized or defaulted value.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst n: number = 1; // Noncompliant, \"number\" can be omitted\n\nfunction foo(s: string = \"\") {} // Noncompliant, \"string\" can be omitted\n\nclass Bar {\n  b: boolean = true;  // Noncompliant, \"boolean\" can be omitted\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst n = 1;\n\nfunction foo(s = \"\") {}\n\nclass Bar {\n  b = true;\n}\n</pre>\n\n"},{"summary":"Deprecated APIs should not be used","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-1874","tags":["cwe","obsolete","cert"],"description":"<p>Once deprecated, classes, and interfaces, and their members should be avoided, rather than used, inherited or extended. Deprecation is a warning\nthat the class or interface has been superseded, and will eventually be removed. The deprecation period allows you to make a smooth transition away\nfrom the aging, soon-to-be-retired technology.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nexport interface LanguageService {\n  /**\n  * @deprecated Use getEncodedSyntacticClassifications instead.\n  */\n  getSyntacticClassifications(fileName: string, span: TextSpan): ClassifiedSpan[];\n}\n\nconst syntacticClassifications = getLanguageService().getSyntacticClassifications(file, span); // Noncompliant\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/477.html\">MITRE, CWE-477</a> - Use of Obsolete Functions </li>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/KgAVAg\">CERT, MET02-J.</a> - Do not use deprecated or obsolete classes or methods </li>\n</ul>\n\n"},{"summary":"Quotes for string literals should be used consistently","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-1441","tags":["convention"],"description":"<p>Shared code conventions allow teams to collaborate efficiently. This rule checks that all non-JSX string literals use the same kind of quotes, and\nrequires double quotes in JSX code, regardless of the parameter value.</p>\n<h2>Noncompliant Code Example</h2>\n<p>Using the parameter default (forcing single quotes):</p>\n<pre>\nlet message = \"Hello, World!\"; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nlet message = 'Hello, World!';\n</pre>\n<h2>Exceptions</h2>\n<p>Strings that contain quotes are ignored.</p>\n<pre>\nlet heSaid = \"Then he said 'What?'.\"  // ignored\nlet sheSaid = '\"Whatever!\" she replied.'  // ignored\n</pre>\n\n"},{"summary":"Statements should end with semicolons","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-1438","tags":["convention"],"description":"<p>In JavaScript, the semicolon (<code>;</code>) is optional as a statement separator, but omitting semicolons can be confusing, and lead to\nunexpected results because a semicolon is implicitly inserted at the end of each line.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfunction fun() {\n  return  // Noncompliant. ';' implicitly inserted at end of line\n       5   // Noncompliant. ';' implicitly inserted at end of line\n}\nprint(fun());  // prints \"undefined\", not \"5\"\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfunction fun() {\n  return 5;\n}\nprint(fun());\n</pre>\n\n"},{"summary":"Variable names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-117","tags":["convention"],"description":"<p>Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all\nvariable names match one of the following patterns: <code>lowerCamelCase</code>, <code>PascalCamelCase</code> or <code>UPPER_CASED</code>. This rule\nalso allows leading underscore.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nconst foo_bar = 1;\nconst baz_ = 2;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nconst fooBar = 1;\nconst _baz = 2;\n</pre>\n\n"},{"summary":"Files should contain an empty newline at the end","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-113","tags":["convention"],"description":"<p>Some tools work better when files end with an empty line.</p>\n<p>This rule simply generates an issue if it is missing.</p>\n<p>For example, a Git diff looks like this if the empty line is missing at the end of the file:</p>\n<pre>\n+class Test {\n+}\n\\ No newline at end of file\n</pre>\n\n"},{"summary":"An open curly brace should be located at the end of a line","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-1105","tags":["convention"],"description":"<p>Shared naming conventions allow teams to collaborate effectively. This rule raises an issue when an open curly brace is not placed at the end of a\nline of code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (condition)\n{                                                      //Noncompliant\n  doSomething();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (condition) {                                   //Compliant\n  doSomething();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Object literals appearing as arguments can start on their own line.</p>\n<pre>\nfunctionWithObject(\n   {                                                 //Compliant\n        g: \"someValue\"\n   }\n);\n</pre>\n\n"},{"summary":"Tabulation characters should not be used","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-105","tags":["convention"],"description":"<p>Developers should not need to configure the tab width of their text editors in order to be able to read source code.</p>\n<p>So the use of the tabulation character must be banned.</p>\n\n"},{"summary":"Class and interface names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","inDefaultProfile":false,"ruleKey":"RSPEC-101","tags":["convention"],"description":"<p>Shared coding conventions allow teams to collaborate effectively. This rule raises an issue when class or interface names are not in\n<em>PascalCase</em> (i.e. camel case with an initial capital letter).</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass my_class {...}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass {...}\n</pre>\n\n"}]}