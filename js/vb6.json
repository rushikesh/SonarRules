{"types":{"Vulnerability":1,"Code Smell":38,"Bug":2,"Other":0},"rules":[{"summary":"IP addresses should not be hardcoded","type":"Vulnerability","defaultSeverity":"Major","description":"<p>Hardcoding an IP address into source code is a bad idea for several reasons:</p>\n<ul>\n<li> a recompile is required if the address changes\n</li><li> it forces the same address to be used in every environment (dev, sys, qa, prod)\n</li><li> it places the responsibility of setting the value to use in production on the shoulders of the developer\n</li><li> it allows attackers to decompile the code and thereby discover a potentially sensitive address\n</li></ul>\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nPrivate Sub cmdConnect_Click()\n    sockMain.RemoteHost = \"127.0.0.1\"\n    sockMain.RemotePort = \"80\"\n    sockMain.Connect\nEnd Sub\n</pre>\n<h2>Compliant Solution</h2>\n\n<pre>\nPrivate Sub cmdConnect_Click()\n    sockMain.RemoteHost = txtHost.Text\n    sockMain.RemotePort = txtPort.Text\n    sockMain.Connect\nEnd Sub\n</pre>\n<h2>See</h2>\n\n<ul>\n<li> <a href=\"https://www.securecoding.cert.org/confluence/x/qQCHAQ\">CERT, MSC03-J</a> - Never hard code sensitive information\n</li></ul>","debt":"30min"},{"summary":"Loop invariants should not be calculated inside the loop","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nLoop invariants are expressions whose values do not change during the execution of a loop. \nPlacing the calculation of an invariant inside a loop is inefficient because the resulting value will always be the same, \nyet it must be re-calculated each time through the loop. \nTherefore invariants should be calculated and stored before loop execution begins.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nFor y = 0 to Height-1\n   For x = 0 to Width-1\n      i = y*Width + x   ' y*Width is invariant\n      '...\n   Next x\nNext y\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nFor y = 0 to Height-1\n   Dim temp as Integer = y*Width\n   For x = 0 to Width-1\n      i = temp + x\n      '...\n   Next x\nNext y\n</pre>","debt":"3min"},{"summary":"\"Asc[W]\" should not be called on string constants","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nBecause the value returned never changes, it is inefficient to call <code>Asc</code>/<code>AscW</code> on a String constant. \nUse the numeric value instead.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nintCode = Asc(\"*\")\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nintCode = 42\n</pre>","debt":"3min"},{"summary":"'$' should not be used in string variable names","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nAppending '$' to any identifier forces it to the String data type, \nbut this usage is obsolete and should only appear when differentiating string-specific functions from variant functions, \nsuch as <code>Left$()</code> versus <code>Left()</code>.\n</p>\n\n<p>\nInstead, Strings should be explicitly declared with the String datatype.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nDim Text$ As String\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nDim Text As String\n</pre>","debt":"10min"},{"summary":"\"Chr[W]$()\" should not be used for certain characters","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nIt is more efficient to skip the function invocation and use the predefined string constants rather \nthan calling <code>Chr$()</code> or <code>ChrW$()</code> for the following numbers:\n<ul>\n<li>0 - <code>vbNullChar</code></li>\n<li>8 - <code>vbBack</code></li>\n<li>9 - <code>vbTab</code></li>\n<li>10 - <code>vbLf</code></li>\n<li>11 - <code>vbVerticalTab</code></li>\n<li>12 - <code>vbFormFeed</code></li>\n<li>13 - <code>vbCr</code></li>\n<li>13+10 - <code>vbCrLf</code> | <code>vbNewLine</code></li>\n<li>34 - <code>\"\"</code></li>\n</ul>\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nDim myChar As Char \nmyChar = Chr$(0)\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nDim myChar As Char \nmyChar = vbNullChar\n</pre>","debt":"3min"},{"summary":"\"Select\" statements should end with a \"Case Else\" clause","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nThe requirement for a final <code>Case Else</code> clause is defensive programming.\nThe clause should either take appropriate action or contain a suitable comment as to why no action is taken.\nEven when the <code>Select</code> covers all current values of an <code>enum</code>, a <code>Case Else</code> case should still be used because there is no guarantee that the <code>enum</code> won't be extended.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nDim number As Integer = 8\nSelect Case number   'Non-Compliant, what to do when number is not between 1 and 10 ?\n    Case 1 To 5\n        Debug.WriteLine(\"Between 1 and 5, inclusive\")\n        ' The following is the only Case clause that evaluates to True.\n    Case 6, 7, 8\n        Debug.WriteLine(\"Between 6 and 8, inclusive\")\n    Case 9 To 10\n        Debug.WriteLine(\"Equal to 9 or 10\")\nEnd Select\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nDim number As Integer = 8\nSelect Case number\n    Case 1 To 5\n        Debug.WriteLine(\"Between 1 and 5, inclusive\")\n        ' The following is the only Case clause that evaluates to True.\n    Case 6, 7, 8\n        Debug.WriteLine(\"Between 6 and 8, inclusive\")\n    Case 9 To 10\n        Debug.WriteLine(\"Equal to 9 or 10\")\n    Case Else\n        Debug.WriteLine(\"Greater than 10\")\nEnd Select\n</pre>\n\n<h2>See</h2>\n<ul>\n    <li>MISRA C:2004, 15.0 - The MISRA C switch syntax shall be used.</li>\n    <li>MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause</li>\n    <li>MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement.</li>\n    <li>MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause</li>\n    <li>MISRA C:2012, 16.1 - All switch statements shall be well-formed</li>\n    <li>MISRA C:2012, 16.4 - Every switch statement shall have a default label</li>\n    <li>MISRA C:2012, 16.5 - A default label shall appear as either the first or the last switch label of a switch statement</li>\n    <li><a href=\"http://cwe.mitre.org/data/definitions/478.html\">MITRE, CWE-478</a> - Missing Default Case in Switch Statement</li>\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/YgE\">CERT, MSC01-C</a> - Strive for logical completeness</li>\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/JoIyAQ\">CERT, MSC01-CPP</a> - Strive for logical completeness</li>\n</ul>","debt":"5min"},{"summary":"Lines should not end with trailing whitespaces","type":"Code Smell","defaultSeverity":"Minor","description":"<p>\nTrailing whitespaces are simply useless and should not stay in code. \nThey may generate noise when comparing different versions of the same file.\n</p>\n<p>\nIf you encounter issues from this rule, this probably means that you are not using an automated code formatter - \nwhich you should if you have the opportunity to do so.\n</p>","debt":"1min"},{"summary":"Multiple variables should not be declared on the same line","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nDeclaring multiple variable on one line is difficult to read \nand potentially misleading since the <code>As</code> typing only applies to the last variable on the line.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nPublic AAA, BBB, CCC As String  ' AAA and BBB are variants\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nPublic AAA as String\nPublic BBB as String\nPublic CCC as String\n</pre>","debt":"2min"},{"summary":"Error handlers should not declare their own error handlers","type":"Bug","defaultSeverity":"Critical","description":"<p>\nIt is not possible to handle errors that arise inside error-handling code. \nTherefore, the declaration of a new error handler within an error-handling section will lead to unpredictable behavior, \nsince the second error-handling routine is activated only after the first error handler has exited.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nSub InitializeMatrix(Var1 As Integer, Var2 As Integer, Var3 As Integer, Var4 As Integer)\n    On Error GoTo ErrorHandler\n    '. . .\n    Exit Sub\nErrorHandler:\n   On Error GoTo ErrorHandlerLastResort\n    '. . .\n    Resume Next\nErrorHandlerLastResort:\n   '. . .\n   Resume Next\nEnd Sub\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nSub InitializeMatrix(Var1 As Integer, Var2 As Integer, Var3 As Integer, Var4 As Integer)\n    On Error GoTo ErrorHandler\n    '. . .\n    Exit Sub\nErrorHandler:\n    '. . .\n    Resume Next\nEnd Sub\n</pre>","debt":"30min"},{"summary":"\"Option Base\" should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nThe use of <code>Option Base</code> to change the lower bound of an array's index values results in confusing code.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nOption Explicit\nOption Base 1\n\n'...\n    Dim MyArray(1 To 3) As Integer\n    For I = 1 To 3\n        MsgBox MyArray(I)\n    Next I\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nOption Explicit\n\n'...\n    Dim MyArray(0 To 2) As Integer\n    For I = 0 To 2\n        MsgBox MyArray(I)\n    Next I\n</pre>","debt":"10min"},{"summary":"\"Select Case\" statements should not have too many \"Case\" clauses","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nWhen <code>Select Case</code> statements have a large set of <code>Case</code> clauses, it is usually an attempt to map two sets of data. \nA real map structure would be more readable and maintainable, and should be used instead.\n</p>","debt":"30min"},{"summary":"Empty statements should be removed","type":"Code Smell","defaultSeverity":"Minor","description":"<p>\nEmpty statements, i.e. <code>:</code>, are usually introduced by mistake, for example because:\n<ul>\n<li>It was meant to be replaced by an actual statement, but this was forgotten.</li>\n<li>There was a typo which lead the colon to be doubled, i.e. <code>::</code>.</li>\n</ul>\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nDim i, j As Integer\ni = 1 :: j=2   ' Noncompliant - double :\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nDim i, j As Integer\ni = 1 : j=2\n</pre>\n\n<h2>See</h2>\n\n<ul>\n    <li>MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that the first character following the null statement is a white-space character.</li>\n    <li>MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided that the first character following the null statement is a white-space character.</li>\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C</a> - Detect and remove code that has no effect</li>\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP</a> - Detect and remove code that has no effect</li>\n</ul>","debt":"2min"},{"summary":"\"GoTo\" statement should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>\n<code>GoTo</code> is an unstructured control flow statement. It makes code less readable and maintainable. \nStructured control flow statements such as <code>If</code>, <code>For</code>, <code>While</code>, \nor <code>Exit</code> should be used instead.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\n    Sub gotoStatementDemo()\n        Dim number As Integer = 1\n        Dim sampleString As String\n        ' Evaluate number and branch to appropriate label.\n        If number = 1 Then GoTo Line1 Else GoTo Line2\nLine1:\n        sampleString = \"Number equals 1\"\n        GoTo LastLine\nLine2:\n        ' The following statement never gets executed because number = 1.\n        sampleString = \"Number equals 2\"\nLastLine:\n        ' Write \"Number equals 1\" in the Debug window.\n        Debug.WriteLine(sampleString)\n    End Sub\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\n    Sub gotoStatementDemo()\n        Dim number As Integer = 1\n        Dim sampleString As String\n        ' Evaluate number and branch to appropriate label.\n        If number = 1 Then\n            sampleString = \"Number equals 1\"\n        Else\n            sampleString = \"Number equals 2\"\n        End If\n        Debug.WriteLine(sampleString)\n    End Sub\n</pre>\n\n<h2>Exceptions</h2>\n\n<code>On Error GoTo</code> statements are ignored as correct error handling.\n\n<h2>See</h2>\n<ul>\n    <li>MISRA C:2004, 14.4 - The goto statement shall not be used.</li>\n    <li>MISRA C:2012, 15.1 - The goto statement should not be used</li>\n</ul>","debt":"10min"},{"summary":"Lines should not be too long","type":"Code Smell","defaultSeverity":"Minor","description":"<p>\nHaving to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.\n</p>","debt":"1min"},{"summary":"\"Case\" clauses should not have too many lines","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nThe <code>Select</code> statement should be used only to clearly define some new branches in the control flow. \nAs soon as a <code>Case</code> clause contains too many statements this highly decreases the readability \nof the overall control flow statement. \nIn such case, the content of <code>Case</code> clause should be extracted in a dedicated sub or function.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nSelect Case number\n    Case 1 To 5\n        Debug.WriteLine(\"Between 1 and 5, inclusive\")\n    Case 6, 7, 8\n        Debug.WriteLine(\"Between 6 and 8, inclusive\")\n    Case 9 To 10                 'Noncompliant, too many nested statements\n        doSomething1()\n        doSomething2()\n        doSomething3()\n        ...\n        doSomethingN()\n    Case Else\n        Debug.WriteLine(\"Not between 1 and 10, inclusive\")\nEnd Select\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nSelect Case number\n    Case 1 To 5\n        Debug.WriteLine(\"Between 1 and 5, inclusive\")\n    Case 6, 7, 8\n        Debug.WriteLine(\"Between 6 and 8, inclusive\")\n    Case 9 To 10\n        doSomething1toN()\n    Case Else\n        Debug.WriteLine(\"Not between 1 and 10, inclusive\")\nEnd Select\n</pre>","debt":"5min"},{"summary":"Magic numbers should not be used","type":"Code Smell","defaultSeverity":"Minor","description":"<p>\nA magic number is a number that comes out of nowhere, and is directly used in a statement. \nMagic numbers are often used, for instance to limit the number of iterations of a loops, to test the value of a property, etc.\n</p>\n<p>\nUsing magic numbers may seem obvious and straightforward when you're writing a piece of code, \nbut they are much less obvious and straightforward at debugging time.\n</p>\n<p>\nThat is why magic numbers must be demystified by first being assigned to clearly named constants before being used.\n</p>\n<p>\n-1, 0 and 1 are not considered magic numbers.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nFunction blnCheckSize(dblParameter As Double) As Boolean\n  If dblParameter > 1024 Then\n    blnCheckSize = True\n  End If\nEnd Function\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nFunction blnCheckSize(dblParameter As Double) As Boolean\n  Dim threshold As Integer = 1024\n\n  If dblParameter > threshold Then\n    blnCheckSize = True\n  End If\nEnd Function\n</pre>","debt":"5min"},{"summary":"Return of boolean expressions should not be wrapped into an \"if-then-else\" statement","type":"Code Smell","defaultSeverity":"Minor","description":"<p>\nReturn of boolean literal statements wrapped into <code>If-Then-Else</code> ones should be simplified.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nFunction MyFunction\n  If condition Then\n    MyFunction = True\n  Else\n    MyFunction = False\n  End If\nEnd Function\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nFunction MyFunction\n  MyFunction = condition\nEnd Function\n</pre>","debt":"2min"},{"summary":"\"Select Case\" statements should have at least 3 \"Case\" clauses","type":"Code Smell","defaultSeverity":"Minor","description":"<p>\n<code>Select Case</code> statements are useful when there are many different cases depending on the value of the same expression.\nFor just one or two cases however, the code will be more readable with <code>If</code> statements.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nSelect Case number\n    Case 1 To 5\n        MsgBox(\"Between 1 and 5, inclusive\")\n    Case Else\n        MsgBox(\"Not between 1 and 5, inclusive\")\nEnd Select\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nIf ( number >= 1 And number <= 5 ) then\n  MsgBox(\"Between 1 and 5, inclusive\")\nElse\n  MsgBox(\"Not between 1 and 5, inclusive\")\nEnd If\n</pre>\n\n<h2>See</h2>\n<ul>\n    <li>MISRA C:2004, 15.5 - Every switch statement shall have at least one case clause.</li>\n    <li>MISRA C++:2008, 6-4-8 - Every switch statement shall have at least one case-clause.</li>\n    <li>MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses</li>\n</ul>","debt":"5min"},{"summary":"Literal boolean values should not be used in condition expressions","type":"Code Smell","defaultSeverity":"Minor","description":"<p>\nRemove literal boolean values from conditional expressions to improve readability. \nAnything that can be tested for equality with a boolean value must itself be a boolean value, \nand boolean values can be tested atomically.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nIf BooleanVariable = True Then ...\nIf BooleanVariable <> True Then ...\nIf BooleanVariable OR False Then ...\nDoSomething(Not False)\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nIf BooleanVariable Then ...\nIf Not BooleanVariable Then ...\nIf BooleanVariable Then ...\nDoSomething(True)\n</pre>","debt":"2min"},{"summary":"Sub and function names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nShared coding conventions allow teams to collaborate efficiently. This rule checks that all function names match a provided regular expression.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<p>With default provided regular expression: ^[A-Z][a-zA-Z0-9_]*$</p>\n\n<pre>\nPrivate Sub doSomething()\n...\nEnd Sub\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nPrivate Sub DoSomething()\n...\nEnd Sub\n</pre>","debt":"10min"},{"summary":"Unused private variables should be removed","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nIf a private variable is declared but not used in the program, it can be considered dead code and should therefore be removed.\nThis will improve maintainability because developers will not wonder what the variable is used for.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nPrivate Foo as Integer\n\nFunction Compute(A As Integer)\n   Compute = A * 42\nEnd Function\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nFunction Compute(A As Integer)\n   Compute = A * 42\nEnd Function\n</pre>","debt":"5min"},{"summary":"Sub and function should not be too complex","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nThe cyclomatic complexity of sub and function should not exceed a defined threshold.\nComplex code can perform poorly and will in any case be difficult to understand and therefore to maintain.\n</p>","debt":"10min"},{"summary":"Expressions should not be too complex","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nThe difficulty of understanding an expression increases \nfor each of the <code>And</code>, <code>Or</code> and <code>Xor</code> operators it contains.\nA single expression's complexity should not become too high to keep the code readable.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n<p>With the default threshold value of 3</p>\n<pre>\nIf ( (condition1 And condition2) Or (condition3 And condition4) Or (condition5 And condition6) )\n...\nEnd If\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nIf ( myFirstCondition() Or mySecondCondition() Or myThirdCondition() )\n...\nEnd If\n</pre>","debt":"5min"},{"summary":"Parsing should not fail","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nWhen the parser fails, it is possible to record the failure as an issue on the file. This way, not only is it possible to track the number of files that do not parse but also to easily find out why they do not parse.\n</p>","debt":"30min"},{"summary":"The bang (\"!\") operator should not be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nUse of the bang (<code>!</code>) operator leads to late binding and results in inefficient code. \nUse the slightly more verbose dot (<code>.</code>) notation instead.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nMsgBox ObjectWithDefaultProperty!Param\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nMsgBox ObjectWithDefaultProperty.DefaultProperty(\"Param\")\n</pre>","debt":"3min"},{"summary":"Source code should be indented consistently","type":"Code Smell","defaultSeverity":"Minor","description":"<p>\nProper indentation is a simple and effective way to improve the code's readability. Consistent indentation among the developers on a team also reduces the differences that are committed to source control systems, making code reviews easier.\n</p>\n<p>\nBy default this rule checks that each block of code is indented but not the size of this indent. The parameter \"indentSize\" allows the expected indent size to be defined. Only the first line of a badly indented section is reported.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<p>With an indent size of 2:</p>\n<pre>\n  Public Sub OutputObject(oOutput As Object)\n    Set oObject = oOutput\n    \n  If TypeOf oObject Is Form Then\n  oObject.Cls\n  ElseIf TypeOf oObject Is PictureBox Then\n        oObject.Cls\n    ElseIf TypeOf oObject Is ListBox Then\n        oObject.Clear\n    End If\nEnd Sub\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nPublic Sub OutputObject(oOutput As Object)\n    Set oObject = oOutput\n    \n    If TypeOf oObject Is Form Then\n        oObject.Cls\n    ElseIf TypeOf oObject Is PictureBox Then\n        oObject.Cls\n    ElseIf TypeOf oObject Is ListBox Then\n        oObject.Clear\n    End If\nEnd Sub\n</pre>","debt":"1min"},{"summary":"Statements should be on separate lines","type":"Code Smell","defaultSeverity":"Minor","description":"<p>\nFor better readability, do not put more than one statement on a single line.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nsampleString  = \"Hello World\" : MsgBox(sampleString)\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nsampleString  = \"Hello World\"\nMsgBox(sampleString)\n</pre>","debt":"1min"},{"summary":"String-specific functions should be used","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nVariant functions are inefficient by nature, and should not be used with strings when string-specific versions, \ndenoted by a <code>$</code> at the end of the name, are available.\n\nThis rule flags instances of these functions:\n<code>Left()</code>, <code>Mid()</code>, <code>Right()</code>, <code>Chr()</code>, <code>ChrW()</code>, \n<code>UCase()</code>, <code>LCase()</code>, <code>LTrim()</code>, <code>RTrim()</code>, <code>Trim()</code>, \n<code>Space()</code>, <code>String()</code>, <code>Format()</code>, <code>Hex()</code>, <code>Oct(),</code> \n<code>Str()</code>, <code>Error()</code>\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nTrimString = Trim(TestString)\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nTrimString = Trim$(TestString)\n</pre>","debt":"5min"},{"summary":"Strings should not be set to empty string","type":"Code Smell","defaultSeverity":"Major","description":"<p>\n<code>vbNullString</code> is a special constant that denotes a null string (0), while <code>\"\"</code> is a  literal empty string. \nFor most purposes, the two are equivalent, but <code>vbNullString</code> is faster to assign and process, and takes less memory. \n<code>vbNullString</code> is therefore preferred, however some non-VB APIs or components may not properly handle null strings, \nand their use should be tested.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nText = \"\"\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nText = vbNullString\n</pre>","debt":"30min"},{"summary":"Variable data types should be declared explicitly","type":"Code Smell","defaultSeverity":"Major","description":"<p>Variables declared without the explicit specification of a data type are <code>Variants</code>. Variants can be inefficient to use because at each interaction they are converted to the appropriate type for that interaction. Variants may be required for COM interactions, but even then their type should be specified explicitly.</p>\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nDim Count\nDim Bool\n</pre>\n<h2>Compliant Solution</h2>\n\n<pre>\nDim Count As Integer\nDim Bool As Boolean\n</pre>","debt":"5min"},{"summary":"Strings should not be compared with empty string","type":"Code Smell","defaultSeverity":"Major","description":"<p>It is far faster to compare the length of a string to 0 than it is to compare the string itself to empty string. Further, the <code>LenB</code> implementation is faster than the <code>Len</code> implementation, and is therefore preferred.</p>\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nIf Text = \"\" Then\nIf Text &lt;&gt; \"\" Then\n</pre>\n<h2>Compliant Solution</h2>\n\n<pre>\nIf LenB(Text) = 0 Then\nIf LenB(Text) &lt;&gt; 0 Then\n</pre>","debt":"3min"},{"summary":"The \"&\" operator should be used to concatenate strings","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nBoth the \"+\" operator and the \"&\" operator can be used to concatenate strings. \nHowever, there is a complicated set of rules around the actual  behavior of the \"+\" operator, \nand whether you will get a concatenation operation, addition, a compiler error, or a <code>Type mismatch</code> error. \nOn the other hand, the \"&\" operator can only perform concatenation, and is therefore preferred.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\nDim y As String = \"Con\" + \"caten\" + \"ation\" \n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nDim y As String = \"Con\" & \"caten\" & \"ation\" \n</pre>","debt":"2min"},{"summary":"Sub and function should not have too many lines","type":"Code Smell","defaultSeverity":"Major","description":"<p>\nA sub or function that grows too large tends to aggregate too many responsibilities.\nSuch sub or function inevitably become harder to understand and therefore harder to maintain.\n</p>\n\n<p>\nAbove a specific threshold, it is strongly advised to refactor into smaller subs or functions which focus on well-defined tasks.\nThose smaller subs or functions will not only be easier to understand, but also probably easier to test.\n</p>","debt":"20min"},{"summary":"Constant names should comply with a naming convention","type":"Code Smell","defaultSeverity":"Minor","description":"<p>\nShared coding conventions allow teams to collaborate efficiently. This rule checks that all constant names match a provided regular expression.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<p>With the default regular expression <code>^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$</code>:</p>\n<pre>\nGlobal Const WdgtStatusOk = 0\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\nGlobal Const WDGT_STATUS_OK = 0\n</pre>","debt":"2min"},{"summary":"Comments should not be located at the end of lines of code","type":"Code Smell","defaultSeverity":"Info","description":"<p>\nThis rule verifies that single-line comments are not located at the end of a line of code. \nThe main idea behind this rule is that in order to be really readable, \ntrailing comments would have to be properly written and formatted \n(correct alignment, no interference with the visual structure of the code, not too long to be visible) \nbut most often, automatic code formatters would not handle this correctly: the code would end up less readable. \nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.\n</p>\n\n<h2>Noncompliant Code Example</h2>\n\n<pre>\na = b + c   ' This is a trailing comment that could be very very long\nd = a + 9 REM This is another trailing comment which could be very very long\n</pre>\n\n<h2>Compliant Solution</h2>\n\n<pre>\n' This very long comment is better placed before the line of code\na = b + c\nREM This is very long comment which is better placed before the line of code\nd = a + 9\n</pre>\n\n<h2>Exceptions</h2>\n\n<p>By default, the property \"legalTrailingCommentPattern\" allows to ignore comments containing only one word:</p>\n\n<pre>\na = b + c   ' FIXME\n</pre>","debt":"1min"},{"summary":"Failed unit tests should be fixed","type":"Bug","defaultSeverity":"Major","description":"Test failures or errors generally indicate that regressions have been introduced. Those tests should be handled as soon as possible to reduce the cost to fix the corresponding regressions."},{"summary":"Skipped unit tests should be either removed or fixed","type":"Code Smell","defaultSeverity":"Major","description":"Skipped unit tests are considered as dead code. Either they should be activated again (and updated) or they should be removed."},{"summary":"Source files should not have any duplicated blocks","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as there is at least one block of duplicated code on this file","debt":"10min"},{"summary":"Source files should have a sufficient density of comment lines","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the density of comment lines on this file is less than the required threshold. The number of comment lines to be written in order to reach the required threshold is provided by each issue message."},{"summary":"Lines should have sufficient coverage by tests","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the line coverage on this file is less than the required threshold. It gives the number of lines to be covered in order to reach the required threshold."},{"summary":"Branches should have sufficient coverage by tests","type":"Code Smell","defaultSeverity":"Major","description":"An issue is created on a file as soon as the branch coverage on this file is less than the required threshold.It gives the number of branches to be covered in order to reach the required threshold."}]}